<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spellshape - Narrative UI</title>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <style>
    :root {
      --bg: #121214;
      --panel: #1e1e24;
      --card: #2b2b33;
      --border: #333;
      --accent: #646cff;
      --text: #ececec;
      --text-dim: #888;
      --var: #ffae57;
    }

    body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Inter', system-ui, sans-serif; color: var(--text); }
    .app { display: flex; height: 100vh; width: 100vw; }
    
    /* SIDEBAR */
    .sidebar {
      width: 400px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      z-index: 10;
      box-shadow: 4px 0 20px rgba(0,0,0,0.4);
    }

    .header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }
    .header h1 { margin: 0; font-size: 18px; font-weight: 700; }
    .header p { margin: 4px 0 0 0; font-size: 12px; color: var(--text-dim); }

    /* RECIPE LIST */
    .recipe-list {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      scrollbar-width: thin;
      scrollbar-color: #444 transparent;
    }

    /* STEP CARD */
    .step-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
      position: relative;
      transition: border-color 0.2s;
    }
    .step-card:hover { border-color: #555; }

    /* Connector Line */
    .step-card:not(:last-child)::after {
      content: ''; position: absolute; left: 24px; bottom: -18px; 
      width: 2px; height: 18px; background: var(--border);
    }

    .step-header { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }
    .step-num { 
      background: #333; color: #aaa; font-size: 11px; font-weight: 700;
      width: 20px; height: 20px; border-radius: 50%; 
      display: flex; align-items: center; justify-content: center;
    }
    .step-title { font-size: 13px; font-weight: 600; color: #fff; }

    /* CONTROLS INSIDE CARD */
    .step-controls {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.05);
    }
    .control { margin-bottom: 10px; }
    .control:last-child { margin-bottom: 0; }
    
    .control-label { 
      display: flex; justify-content: space-between; 
      font-size: 11px; margin-bottom: 6px; 
    }
    .var-name { color: var(--var); font-family: monospace; }
    .var-val { color: #ccc; font-family: monospace; }

    input[type=range] {
      width: 100%; -webkit-appearance: none; background: transparent; cursor: pointer;
    }
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%; height: 4px; background: #444; border-radius: 2px;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%;
      background: var(--accent); margin-top: -4px; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }

    /* VIEWPORT */
    .viewport { flex: 1; position: relative; background: radial-gradient(circle at center, #222 0%, #111 100%); }
    canvas { display: block; width: 100%; height: 100%; }
    
    .stats {
      position: absolute; bottom: 20px; right: 20px;
      font-family: monospace; font-size: 10px; color: #666;
      background: rgba(0,0,0,0.5); padding: 8px 12px; border-radius: 4px;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <div class="app">
    <div class="sidebar">
      <div class="header">
        <h1>Spellshape Narrative</h1>
        <p>Adjust logic steps directly</p>
      </div>
      <div class="recipe-list" id="recipe-container">
        <!-- Cards Injected Here -->
      </div>
    </div>

    <div class="viewport">
      <canvas id="gl"></canvas>
      <div class="stats" id="stats">Ready</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { ProceduralExecutor } from './src/modules/interpreter/procedural-executor.js';

    // --- SCHEMA (v4.6) ---
    const schema = {
      "version": "4.6",
      "type": "emergent_procedure",
      "intent": "Complete Checkerboard Tower",
      "materials": {
        "wall": { "color": "#1a3a5c", "roughness": 0.7, "metalness": 0.1 },
        "window": { "color": "#b3d9ff", "roughness": 0.1, "metalness": 0.8, "transparent": true, "opacity": 0.6 },
        "core": { "color": "#c1440e", "roughness": 0.6, "metalness": 0 },
        "column": { "color": "#2a2a2a", "roughness": 0.8, "metalness": 0.3 },
        "floor_slab": { "color": "#b8b8b8", "roughness": 0.7, "metalness": 0.1 }
      },
      "globalParameters": {
        "floors": { "value": 15, "type": "integer", "min": 3, "max": 30 },
        "floorHeight": { "value": 3.5, "type": "number", "min": 2, "max": 5 },
        "coreWidth": { "value": 8, "type": "number", "min": 4, "max": 16 },
        "coreDepth": { "value": 8, "type": "number", "min": 4, "max": 12 },
        "slabExpansion": { "value": 2, "type": "number", "min": 0, "max": 4 },
        "rotationPerFloor": { "value": 0.08, "type": "number", "min": 0, "max": 0.2 },
        "panelsPerSide": { "value": 6, "type": "integer", "min": 2, "max": 12 }
      },
      "context": {},
      "actions": [
        { "thought": "1. Create Slab Base", "do": "createBox", "params": { "width": "ctx.coreWidth + ctx.slabExpansion", "height": 0.3, "depth": "ctx.coreDepth + ctx.slabExpansion" }, "transform": { "position": [0, -0.15, 0] }, "as": "slab_mesh" },
        { "thought": "2. Create Core", "do": "createBox", "params": { "width": "ctx.coreWidth", "height": "ctx.floorHeight", "depth": "ctx.coreDepth" }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "core_mesh" },
        { "thought": "3. Create Columns", "do": "createCylinder", "params": { "radiusTop": 0.4, "radiusBottom": 0.4, "height": "ctx.floorHeight" }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "col_base" },
        { "thought": "4. Distribute Columns", "do": "distributeOnGrid3d", "params": { "geometry": "col_base", "rows": 2, "cols": 2, "spacing": ["ctx.coreWidth + 1", 0, "ctx.coreDepth + 1"], "centered": true, "autoMerge": true }, "as": "cols_mesh" },
        { "thought": "5. Create Facade Panels", "do": "createBox", "params": { "width": "(ctx.coreWidth + ctx.slabExpansion) / ctx.panelsPerSide - 0.1", "height": "ctx.floorHeight", "depth": 0.2 }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "panel_horz" },
        { "do": "createBox", "params": { "width": 0.2, "height": "ctx.floorHeight", "depth": "(ctx.coreDepth + ctx.slabExpansion) / ctx.panelsPerSide - 0.1" }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "panel_vert" },
        { "thought": "6. Assemble Patterns", "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreWidth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["-((ctx.coreWidth + ctx.slabExpansion)/ctx.panelsPerSide)/2", 0, "(ctx.coreDepth + ctx.slabExpansion)/2 - 0.1"] }, "as": "front_even" },
        { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreWidth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["((ctx.coreWidth + ctx.slabExpansion)/ctx.panelsPerSide)/2", 0, "(ctx.coreDepth + ctx.slabExpansion)/2 - 0.1"] }, "as": "front_odd" },
        { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreWidth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["-((ctx.coreWidth + ctx.slabExpansion)/ctx.panelsPerSide)/2", 0, "-(ctx.coreDepth + ctx.slabExpansion)/2 + 0.1"] }, "as": "back_even" },
        { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreWidth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["((ctx.coreWidth + ctx.slabExpansion)/ctx.panelsPerSide)/2", 0, "-(ctx.coreDepth + ctx.slabExpansion)/2 + 0.1"] }, "as": "back_odd" },
        { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreDepth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["-(ctx.coreWidth + ctx.slabExpansion)/2 + 0.1", 0, "-((ctx.coreDepth + ctx.slabExpansion)/ctx.panelsPerSide)/2"] }, "as": "left_even" },
        { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreDepth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["-(ctx.coreWidth + ctx.slabExpansion)/2 + 0.1", 0, "((ctx.coreDepth + ctx.slabExpansion)/ctx.panelsPerSide)/2"] }, "as": "left_odd" },
        { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreDepth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["(ctx.coreWidth + ctx.slabExpansion)/2 - 0.1", 0, "-((ctx.coreDepth + ctx.slabExpansion)/ctx.panelsPerSide)/2"] }, "as": "right_even" },
        { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreDepth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["(ctx.coreWidth + ctx.slabExpansion)/2 - 0.1", 0, "((ctx.coreDepth + ctx.slabExpansion)/ctx.panelsPerSide)/2"] }, "as": "right_odd" },
        { 
          "thought": "7. Stack Floors", 
          "do": "loop", "var": "i", "from": 0, "to": "ctx.floors",
          "body": [
             { "do": "clone", "params": {"id":"slab_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "floor_slab" },
             { "do": "clone", "params": {"id":"core_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "core" },
             { "do": "clone", "params": {"id":"cols_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "column" },
             { "do": "clone", "params": {"id":"front_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
             { "do": "clone", "params": {"id":"front_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
             { "do": "clone", "params": {"id":"back_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
             { "do": "clone", "params": {"id":"back_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
             { "do": "clone", "params": {"id":"left_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
             { "do": "clone", "params": {"id":"left_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
             { "do": "clone", "params": {"id":"right_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
             { "do": "clone", "params": {"id":"right_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" }
          ] 
        }
      ]
    };

    // --- UI GENERATOR ---
    const container = document.getElementById('recipe-container');
    const varRegex = /ctx\.([a-zA-Z0-9_]+)/g;

    function extractVars(obj) {
      const vars = new Set();
      const str = JSON.stringify(obj);
      let match;
      while ((match = varRegex.exec(str)) !== null) {
        vars.add(match[1]);
      }
      return Array.from(vars);
    }

    function renderRecipe() {
      container.innerHTML = '';
      
      schema.actions.forEach((action, i) => {
        if (!action.thought) return; // Only render steps with thoughts

        // Create Card
        const card = document.createElement('div');
        card.className = 'step-card';
        
        // Header
        const header = document.createElement('div');
        header.className = 'step-header';
        header.innerHTML = `<div class="step-num">${i+1}</div><div class="step-title">${action.thought}</div>`;
        card.appendChild(header);

        // Find Vars
        const vars = extractVars(action);
        
        if (vars.length > 0) {
          const controlsDiv = document.createElement('div');
          controlsDiv.className = 'step-controls';
          
          vars.forEach(key => {
            const def = schema.globalParameters[key];
            if (!def) return;

            const control = document.createElement('div');
            control.className = 'control';
            
            const label = document.createElement('div');
            label.className = 'control-label';
            label.innerHTML = `<span class="var-name">${key}</span><span class="var-val" id="val-${key}-${i}">${def.value}</span>`; // Unique ID per instance
            
            const input = document.createElement('input');
            input.type = 'range';
            input.min = def.min;
            input.max = def.max;
            input.step = def.step || (def.type === 'integer' ? 1 : 0.01);
            input.value = def.value;
            
            // Sync logic: When this slider moves, update schema AND all other sliders for same var
            input.oninput = (e) => {
              const val = parseFloat(e.target.value);
              def.value = val;
              
              // Update all sliders synced to this variable
              document.querySelectorAll(`input[data-var="${key}"]`).forEach(el => el.value = val);
              
              // Update all text displays
              document.querySelectorAll(`.var-val`).forEach(el => {
                if (el.id.startsWith(`val-${key}`)) el.innerText = val;
              });
              
              run();
            };
            input.setAttribute('data-var', key);

            control.appendChild(label);
            control.appendChild(input);
            controlsDiv.appendChild(control);
          });
          
          card.appendChild(controlsDiv);
        }

        container.appendChild(card);
      });
    }

    // --- 3D RUNTIME ---
    const canvas = document.querySelector('#gl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(60, 50, 60);
    
    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.target.set(0, 20, 0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(50, 100, 50);
    scene.add(dirLight);
    scene.add(new THREE.GridHelper(100, 20, 0x333333, 0x111111));

    const executor = new ProceduralExecutor();
    let currentMesh = null;

    function run() {
      if (currentMesh) {
        scene.remove(currentMesh);
        currentMesh.traverse(c => {
          if (c.geometry) c.geometry.dispose();
          if (c.material) c.material.dispose();
        });
      }

      const params = {};
      for (const [k, v] of Object.entries(schema.globalParameters)) {
        params[k] = v.value;
      }

      try {
        currentMesh = executor.execute(schema, params);
        scene.add(currentMesh);
        let count = 0;
        currentMesh.traverse(c => { if (c.isMesh) count++; });
        document.getElementById('stats').innerText = `Geometry: ${count} meshes`;
      } catch (e) {
        console.error(e);
      }
    }

    // Init
    renderRecipe();
    run();

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.onresize = () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
