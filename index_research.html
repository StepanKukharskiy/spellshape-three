<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spellshape - Adaptive Pipeline (Fixed)</title>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <style>
    :root {
      --bg: #0f0f11;
      --panel: #18181b;
      --card: #222226;
      --border: #2e2e32;
      --accent: #6d28d9;
      --accent-light: #8b5cf6;
      --text: #f4f4f5;
      --text-dim: #a1a1aa;
    }

    * { box-sizing: border-box; }
    body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Inter', system-ui, sans-serif; color: var(--text); }
    .app { display: flex; height: 100vh; width: 100vw; }

    /* SIDEBAR */
    .sidebar {
      flex: 0 0 380px;
      width: 380px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      z-index: 10;
    }

    .header { padding: 20px 24px; border-bottom: 1px solid var(--border); background: var(--bg); }
    .header h1 { margin: 0 0 4px 0; font-size: 16px; font-weight: 600; }
    .header p { margin: 0; font-size: 12px; color: var(--text-dim); }

    .schema-select {
      margin-top: 12px; width: 100%; background: var(--card); border: 1px solid var(--border);
      color: var(--text); padding: 8px; border-radius: 6px; font-size: 12px; outline: none; cursor: pointer;
    }

    /* PIPELINE */
    .pipeline { flex: 1; overflow-y: auto; padding: 24px; position: relative; }
    .pipeline::before {
      content: ''; position: absolute; top: 24px; bottom: 24px; left: 39px;
      width: 2px; background: var(--border); z-index: 0;
    }

    .step-card {
      background: var(--card); border: 1px solid var(--border); border-radius: 8px;
      margin-bottom: 24px; position: relative; z-index: 1; transition: all 0.2s;
    }
    .step-card:hover { border-color: var(--text-dim); }

    .step-num {
      position: absolute; left: -30px; top: 16px; width: 24px; height: 24px;
      background: var(--panel); border: 2px solid var(--border); border-radius: 50%;
      font-size: 10px; font-weight: 700; color: var(--text-dim);
      display: flex; align-items: center; justify-content: center; z-index: 2;
    }
    .step-card:hover .step-num { border-color: var(--accent-light); color: var(--accent-light); }

    .step-header { padding: 16px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
    .step-title { font-size: 13px; font-weight: 600; color: var(--text); }
    .step-type { font-size: 10px; text-transform: uppercase; color: var(--text-dim); background: rgba(255,255,255,0.05); padding: 2px 6px; border-radius: 4px; }

    .step-body { padding: 16px; }
    .step-body:empty { display: none; }

    /* CONTROLS */
    .control { margin-bottom: 16px; }
    .control:last-child { margin-bottom: 0; }
    .control-header { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 8px; }
    .control-label { color: var(--text-dim); font-weight: 500; }
    .control-val { font-family: monospace; color: var(--accent-light); }

    input[type=range] { width: 100%; -webkit-appearance: none; background: transparent; cursor: pointer; display: block; }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #333; border-radius: 2px; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #d4d4d8; margin-top: -5px; }
    input[type=range]:hover::-webkit-slider-thumb { background: var(--accent-light); transform: scale(1.2); }

    /* ORPHAN PARAMS */
    .global-params {
      margin-bottom: 32px; padding: 16px; background: rgba(109, 40, 217, 0.1);
      border: 1px solid rgba(109, 40, 217, 0.2); border-radius: 8px; position: relative;
    }
    .global-params::after {
      content: 'GLOBAL CONTEXT'; position: absolute; top: -8px; left: 12px;
      font-size: 9px; font-weight: 700; color: var(--accent-light); background: var(--panel); padding: 0 6px;
    }

    /* JSON EDITOR */
    .json-toggle { position: absolute; bottom: 20px; left: 20px; font-size: 11px; color: #666; cursor: pointer; text-decoration: underline; z-index: 20; }
    .json-panel { position: absolute; top: 0; right: -400px; width: 400px; height: 100%; background: #111; border-left: 1px solid #333; transition: right 0.3s; z-index: 20; display: flex; flex-direction: column; }
    .json-panel.open { right: 0; }
    textarea { flex: 1; background: #000; border: none; color: #0f0; font-family: monospace; padding: 16px; resize: none; font-size: 11px; }

    /* VIEWPORT */
    .viewport { flex: 1; position: relative; background: radial-gradient(circle at center, #1f1f23 0%, #09090b 100%); }
    canvas { display: block; width: 100%; height: 100%; outline: none; }
    .stats { position: absolute; bottom: 24px; right: 24px; font-family: monospace; font-size: 10px; color: #52525b; pointer-events: none; }
  </style>
</head>
<body>

  <div class="app">
    <div class="sidebar">
      <div class="header">
        <h1>Spellshape</h1>
        <p>Procedural Generator</p>
        <select class="schema-select" onchange="window.loadSchema(this.value)">
          <option value="schema1">Logic Tower</option>
          <option value="schema2">Noise Column</option>
          <option value="schema3">Deformed Monolith</option>
          <option value="schema4">Voxel Monolith</option>
        </select>
      </div>

      <div class="pipeline" id="pipeline"></div>
      <div class="json-toggle" onclick="window.toggleJson()">View Source JSON</div>
    </div>

    <div class="viewport">
      <canvas id="gl"></canvas>
      <div class="stats" id="stats">Ready</div>
    </div>

    <div class="json-panel" id="json-panel">
      <div style="padding: 10px; border-bottom: 1px solid #333; display:flex; justify-content:space-between;">
        <span style="color:#888; font-size:12px; font-weight:bold;">SCHEMA SOURCE</span>
        <span style="color:#888; cursor:pointer;" onclick="window.toggleJson()">Close [x]</span>
      </div>
      <textarea id="json-input" spellcheck="false"></textarea>
      <button onclick="window.updateFromJSON()" style="padding:12px; background:#222; color:#fff; border:none; border-top:1px solid #333; cursor:pointer;">Update & Run</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { ProceduralExecutor } from './src/modules/interpreter/procedural-executor.js';

    // --- RESTORED FULL SCHEMAS ---
    const schemas = {
      schema1: {
        "version": "4.9",
        "intent": "Decoupled Logic Tower",
        "materials": {
          "wall": { "color": "#1a3a5c", "roughness": 0.7, "metalness": 0.1 },
          "window": { "color": "#b3d9ff", "roughness": 0.1, "metalness": 0.8, "transparent": true, "opacity": 0.6 },
          "core": { "color": "#c1440e", "roughness": 0.6, "metalness": 0 },
          "column": { "color": "#2a2a2a", "roughness": 0.8, "metalness": 0.3 },
          "floor_slab": { "color": "#b8b8b8", "roughness": 0.7, "metalness": 0.1 }
        },
        "globalParameters": {
          "floors": { "value": 15, "type": "integer", "min": 3, "max": 30, "group": "Massing" },
          "floorHeight": { "value": 3.5, "type": "number", "min": 2, "max": 5, "group": "Massing" },
          "slabWidth": { "value": 12, "type": "number", "min": 6, "max": 24, "group": "Slab" },
          "slabDepth": { "value": 12, "type": "number", "min": 6, "max": 24, "group": "Slab" },
          "slabThickness": { "value": 0.3, "type": "number", "min": 0.1, "max": 1.0, "group": "Slab" },
          "coreWidth": { "value": 8, "type": "number", "min": 4, "max": 16, "group": "Core" },
          "coreDepth": { "value": 8, "type": "number", "min": 4, "max": 16, "group": "Core" },
          "colRadius": { "value": 0.4, "type": "number", "min": 0.2, "max": 0.8, "group": "Columns" },
          "colInsetX": { "value": 1.0, "type": "number", "min": 0.5, "max": 4.0, "group": "Columns" },
          "colInsetZ": { "value": 1.0, "type": "number", "min": 0.5, "max": 4.0, "group": "Columns" },
          "panelsPerSide": { "value": 6, "type": "integer", "min": 2, "max": 12, "group": "Facade" },
          "rotationPerFloor": { "value": 0.08, "type": "number", "min": 0, "max": 0.2, "group": "Animation" }
        },
        "actions": [
          { "thought": "Create Slab Base", "do": "createBox", "params": { "width": "ctx.slabWidth", "height": "ctx.slabThickness", "depth": "ctx.slabDepth" }, "transform": { "position": [0, "-ctx.slabThickness/2", 0] }, "as": "slab_mesh", "controls": ["slabWidth", "slabDepth", "slabThickness"] },
          { "thought": "Create Core", "do": "createBox", "params": { "width": "ctx.coreWidth", "height": "ctx.floorHeight", "depth": "ctx.coreDepth" }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "core_mesh", "controls": ["coreWidth", "coreDepth"] },
          { "thought": "Define Columns", "do": "createCylinder", "params": { "radiusTop": "ctx.colRadius", "radiusBottom": "ctx.colRadius", "height": "ctx.floorHeight" }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "col_base", "controls": ["colRadius", "floorHeight"] },
          { "thought": "Distribute Columns", "do": "distributeOnGrid3d", "params": { "geometry": "col_base", "rows": 2, "cols": 2, "spacing": ["ctx.slabWidth - (ctx.colInsetX * 2)", 0, "ctx.slabDepth - (ctx.colInsetZ * 2)"] }, "as": "cols_mesh", "controls": ["colInsetX", "colInsetZ"] },
          { "thought": "Create Facade Geometry", "do": "createBox", "params": { "width": "ctx.slabWidth / ctx.panelsPerSide - 0.1", "height": "ctx.floorHeight", "depth": 0.2 }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "panel_horz", "controls": ["panelsPerSide"] },
          { "thought": "Create Facade Verticals", "do": "createBox", "params": { "width": 0.2, "height": "ctx.floorHeight", "depth": "ctx.slabDepth / ctx.panelsPerSide - 0.1" }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "panel_vert" },
          { "thought": "Assemble Facade", "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabWidth / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["-(ctx.slabWidth/ctx.panelsPerSide)/2", 0, "ctx.slabDepth/2 - 0.1"] }, "as": "front_even" },
          { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabWidth / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["(ctx.slabWidth/ctx.panelsPerSide)/2", 0, "ctx.slabDepth/2 - 0.1"] }, "as": "front_odd" },
          { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabWidth / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["-(ctx.slabWidth/ctx.panelsPerSide)/2", 0, "-ctx.slabDepth/2 + 0.1"] }, "as": "back_even" },
          { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabWidth / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["(ctx.slabWidth/ctx.panelsPerSide)/2", 0, "-ctx.slabDepth/2 + 0.1"] }, "as": "back_odd" },
          { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabDepth / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["-ctx.slabWidth/2 + 0.1", 0, "-(ctx.slabDepth/ctx.panelsPerSide)/2"] }, "as": "left_even" },
          { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabDepth / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["-ctx.slabWidth/2 + 0.1", 0, "(ctx.slabDepth/ctx.panelsPerSide)/2"] }, "as": "left_odd" },
          { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabDepth / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["ctx.slabWidth/2 - 0.1", 0, "-(ctx.slabDepth/ctx.panelsPerSide)/2"] }, "as": "right_even" },
          { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabDepth / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["ctx.slabWidth/2 - 0.1", 0, "(ctx.slabDepth/ctx.panelsPerSide)/2"] }, "as": "right_odd" },

          { 
            "thought": "Stack Floors", 
            "do": "loop", "var": "i", "from": 0, "to": "ctx.floors",
            "controls": ["floors", "rotationPerFloor"],
            "body": [
               { "do": "clone", "params": {"id":"slab_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "floor_slab" },
               { "do": "clone", "params": {"id":"core_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "core" },
               { "do": "clone", "params": {"id":"cols_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "column" },
               { "do": "clone", "params": {"id":"front_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
               { "do": "clone", "params": {"id":"front_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
               { "do": "clone", "params": {"id":"back_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
               { "do": "clone", "params": {"id":"back_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
               { "do": "clone", "params": {"id":"left_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
               { "do": "clone", "params": {"id":"left_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
               { "do": "clone", "params": {"id":"right_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
               { "do": "clone", "params": {"id":"right_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" }
            ] 
          }
        ]
      },
      schema2: {
        "version": "4.9",
        "intent": "Noise Eroded Column",
        "materials": {
          "concrete": { "color": "#8c8c8c", "roughness": 0.9, "metalness": 0.1 },
          "inner_core": { "color": "#333333", "roughness": 0.5, "metalness": 0.5 }
        },
        "globalParameters": {
          "height": { "value": 12, "type": "number", "min": 5, "max": 20, "group": "Dimensions" },
          "width": { "value": 3, "type": "number", "min": 1, "max": 6, "group": "Dimensions" },
          "layerCount": { "value": 100, "type": "integer", "min": 20, "max": 200, "group": "Resolution" },
          "erosionScale": { "value": 0.8, "type": "number", "min": 0.1, "max": 2.0, "group": "Erosion" },
          "erosionDepth": { "value": 1.2, "type": "number", "min": 0, "max": 2.0, "group": "Erosion" },
          "chaos": { "value": 1.5, "type": "number", "min": 0, "max": 5.0, "group": "Erosion" }
        },
        "actions": [
          {
            "thought": "Define Base Geometry",
            "do": "createBox",
            "params": { "width": "ctx.width", "height": "ctx.height / ctx.layerCount", "depth": "ctx.width" },
            "as": "slice_geo",
            "controls": ["width", "height", "layerCount"]
          },
          {
            "thought": "Define Inner Core",
            "do": "createBox",
            "params": { "width": "ctx.width * 0.4", "height": "ctx.height / ctx.layerCount", "depth": "ctx.width * 0.4" },
            "as": "core_geo"
          },
          {
            "thought": "Erode & Stack Loop",
            "do": "loop", "var": "i", "from": 0, "to": "ctx.layerCount",
            "controls": ["erosionScale", "erosionDepth", "chaos"],
            "body": [
              {
                "do": "clone", "params": { "id": "slice_geo" },
                "transform": {
                  "position": [0, "i * (ctx.height / ctx.layerCount)", 0],
                  "scale": [
                    "1.0 - Math.max(0, (Math.sin(i * 0.1 * ctx.erosionScale) + Math.cos(i * 0.3 * ctx.chaos)) * ctx.erosionDepth * 0.5)", 
                    1, 
                    "1.0 - Math.max(0, (Math.cos(i * 0.1 * ctx.erosionScale) + Math.sin(i * 0.33 * ctx.chaos)) * ctx.erosionDepth * 0.5)"
                  ],
                  "rotation": [0, "i * 0.02", 0]
                },
                "material": "concrete"
              },
              {
                "do": "clone", "params": { "id": "core_geo" },
                "transform": { "position": [0, "i * (ctx.height / ctx.layerCount)", 0], "rotation": [0, "i * 0.02", 0] },
                "material": "inner_core"
              }
            ]
          }
        ]
      },
      schema3: {
        "version": "4.9", "intent": "Deformed Surface Monolith",
        "materials": { "stone": { "color": "#e0e0e0", "roughness": 0.8, "metalness": 0.1 } },
        "globalParameters": {
          "width": { "value": 6, "min": 2, "max": 10 },
          "height": { "value": 12, "min": 5, "max": 20 },
          "depth": { "value": 6, "min": 2, "max": 10 },
          "resolution": { "value": 30, "type": "integer", "min": 10, "max": 100 },
          "waveFreq": { "value": 0.8, "min": 0.1, "max": 2.0 },
          "waveAmp": { "value": 1.5, "min": 0.0, "max": 3.0 },
          "taper": { "value": 0.3, "min": -0.5, "max": 1.0 }
        },
        "actions": [
          { "thought": "Create High-Res Mesh", "do": "createBox", "params": { "width": "ctx.width", "height": "ctx.height", "depth": "ctx.depth", "widthSegments": "ctx.resolution", "heightSegments": "ctx.resolution", "depthSegments": "ctx.resolution" }, "as": "base_mesh", "controls": ["width", "height", "resolution"] },
          { "thought": "Apply Deformations", "do": "modifyGeometry", "params": {
              "geometry": "base_mesh",
              "operations": [
                { "type": "displace", "expression": "v.x += Math.sin(v.y * ctx.waveFreq) * ctx.waveAmp; v.z += Math.cos(v.y * ctx.waveFreq) * ctx.waveAmp;" },
                { "type": "scale", "expression": "var s = 1.0 - (v.y / ctx.height) * ctx.taper; v.x *= s; v.z *= s;" }
              ]
            },
            "material": "stone",
            "as": "final_mesh", "controls": ["waveFreq", "waveAmp", "taper"]
          }
        ]
      },
      schema4: {
        "version": "4.9", "intent": "Box-Preserving Voxel Monolith",
        "materials": { "stone": { "color": "#e0e0e0", "roughness": 0.9, "metalness": 0.1 } },
        "globalParameters": {
          "width": { "value": 5, "min": 2, "max": 10 },
          "height": { "value": 12, "min": 5, "max": 20 },
          "depth": { "value": 5, "min": 2, "max": 10 },
          "resolution": { "value": 60, "type": "integer", "min": 20, "max": 120 },
          "voxelSize": { "value": 0.5, "min": 0.1, "max": 2.0 },
          "erosionThreshold": { "value": 0.4, "min": 0.0, "max": 0.9 },
          "layerDepth": { "value": 1.5, "min": 0.5, "max": 5.0 },
          "taper": { "value": 0.2, "min": -0.5, "max": 1.0 }
        },
        "actions": [
          { "thought": "Create Base Core", "do": "createBox", "params": { "width": "ctx.width", "height": "ctx.height", "depth": "ctx.depth", "widthSegments": "ctx.resolution", "heightSegments": "ctx.resolution", "depthSegments": "ctx.resolution" }, "as": "base_mesh", "controls": ["width", "height", "depth", "resolution"] },
          { "thought": "Voxel Expansion", "do": "modifyGeometry", "params": {
              "geometry": "base_mesh",
              "operations": [
                { "type": "scale", "expression": "var s = 1.0 - (v.y / ctx.height) * ctx.taper; v.x *= s; v.z *= s;" },
                { "type": "displace", "expression": "var step=ctx.voxelSize; var qx=Math.floor(v.x/step); var qy=Math.floor(v.y/step); var qz=Math.floor(v.z/step); var dot=qx*12.9898+qy*78.233+qz*37.719; var hash=Math.sin(dot)*43758.5453; var noise=hash-Math.floor(hash); if(noise>ctx.erosionThreshold){ var kx=(2.0*ctx.layerDepth)/ctx.width; var ky=(2.0*ctx.layerDepth)/ctx.height; var kz=(2.0*ctx.layerDepth)/ctx.depth; v.x+=v.x*kx; v.y+=v.y*ky; v.z+=v.z*kz; }" }
              ]
            },
            "material": "stone",
            "as": "final_mesh", "controls": ["voxelSize", "erosionThreshold", "layerDepth", "taper"]
          }
        ]
      }
    };

    let currentSchema = schemas.schema1;
    let currentMesh = null;
    const executor = new ProceduralExecutor();

    // --- RENDER PIPELINE UI ---
    function renderPipeline() {
      const container = document.getElementById('pipeline');
      container.innerHTML = '';

      // 1. Identify "Orphan" parameters
      const assignedParams = new Set();
      currentSchema.actions.forEach(a => {
        if(a.controls) a.controls.forEach(c => assignedParams.add(c));
      });
      const globalParams = Object.keys(currentSchema.globalParameters).filter(k => !assignedParams.has(k));

      // 2. Global Card
      if (globalParams.length > 0) {
        const globalCard = document.createElement('div');
        globalCard.className = 'global-params';
        globalParams.forEach(key => {
          globalCard.appendChild(createSlider(key, currentSchema.globalParameters[key]));
        });
        container.appendChild(globalCard);
      }

      // 3. Steps
      currentSchema.actions.forEach((action, index) => {
        const card = document.createElement('div');
        card.className = 'step-card';

        const dot = document.createElement('div');
        dot.className = 'step-num';
        dot.innerText = index + 1;
        card.appendChild(dot);

        const header = document.createElement('div');
        header.className = 'step-header';
        header.innerHTML = `
          <span class="step-title">${action.thought || 'Action'}</span>
          <span class="step-type">${action.do}</span>
        `;
        card.appendChild(header);

        const body = document.createElement('div');
        body.className = 'step-body';

        if (action.controls && action.controls.length > 0) {
          action.controls.forEach(key => {
            if (currentSchema.globalParameters[key]) {
              body.appendChild(createSlider(key, currentSchema.globalParameters[key]));
            }
          });
          card.appendChild(body);
        }
        container.appendChild(card);
      });
    }

    function createSlider(key, def) {
      const wrapper = document.createElement('div');
      wrapper.className = 'control';

      const header = document.createElement('div');
      header.className = 'control-header';
      header.innerHTML = `
        <span class="control-label">${key}</span>
        <span class="control-val" id="val-${key}">${def.value}</span>
      `;

      const input = document.createElement('input');
      input.type = 'range';
      input.min = def.min;
      input.max = def.max;
      input.step = def.type === 'integer' ? 1 : 0.01;
      input.value = def.value;

      input.oninput = (e) => {
        const val = def.type === 'integer' ? parseInt(e.target.value) : parseFloat(e.target.value);
        def.value = val;
        document.querySelectorAll(`#val-${key}`).forEach(el => el.innerText = val);
        document.querySelectorAll(`input`).forEach(el => {
          if (el !== input && el.dataset.key === key) el.value = val;
        });
        run();
      };
      input.dataset.key = key;
      wrapper.appendChild(header);
      wrapper.appendChild(input);
      return wrapper;
    }

    // --- GLOBAL FUNCTIONS ---
    window.loadSchema = (key) => {
      currentSchema = schemas[key];
      document.getElementById('json-input').value = JSON.stringify(currentSchema, null, 2);
      renderPipeline();
      run();
    };
    window.toggleJson = () => { document.getElementById('json-panel').classList.toggle('open'); };
    window.updateFromJSON = () => {
      try {
        const json = document.getElementById('json-input').value;
        currentSchema = JSON.parse(json);
        renderPipeline();
        run();
      } catch(e) { alert("Invalid JSON"); }
    };

    // --- 3D ENGINE ---
    const canvas = document.querySelector('#gl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
    const controls = new OrbitControls(camera, canvas);

    function setupScene() {
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.position.set(40, 40, 40);
      camera.updateProjectionMatrix();
      controls.enableDamping = true;
      controls.target.set(0, 10, 0);
      scene.background = new THREE.Color(0x0f0f11);
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(50, 100, 50);
      scene.add(dirLight);
      scene.add(new THREE.GridHelper(100, 20, 0x2e2e32, 0x18181b));
    }

    function run() {
      if (currentMesh) {
        scene.remove(currentMesh);
        currentMesh.traverse(c => {
           if (c.geometry) c.geometry.dispose();
           if (c.material && !Array.isArray(c.material)) c.material.dispose();
        });
      }

      const params = {};
      for (const [k, v] of Object.entries(currentSchema.globalParameters)) params[k] = v.value;

      try {
        currentMesh = executor.execute(currentSchema, params);
        scene.add(currentMesh);
        let count = 0;
        currentMesh.traverse(c => { if (c.isMesh) count++; });
        document.getElementById('stats').innerText = `${currentSchema.intent} | Meshes: ${count}`;
      } catch (e) { console.error(e); }
    }

    setupScene();
    window.loadSchema('schema1');

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.onresize = () => {
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    };
  </script>
</body>
</html>