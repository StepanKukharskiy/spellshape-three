<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spellshape - Complete Workbench</title>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <style>
    :root {
      --bg: #09090b;
      --panel: #18181b;
      --card: #27272a;
      --border: #3f3f46;
      --accent: #8b5cf6;
      --accent-hover: #a78bfa;
      --text: #e4e4e7;
      --text-dim: #a1a1aa;
      --danger: #ef4444;
      --success: #22c55e;
    }

    * { box-sizing: border-box; user-select: none; }
    body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Inter', system-ui, sans-serif; color: var(--text); font-size: 12px; }
    .app { display: flex; height: 100vh; width: 100vw; }

    /* TOOLBOX */
    .toolbox { width: 180px; background: var(--panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; z-index: 10; }
    .toolbox-header { padding: 12px; border-bottom: 1px solid var(--border); font-weight: 700; color: var(--text-dim); font-size: 10px; }
    .tool-list { padding: 10px; overflow-y: auto; flex: 1; }
    .tool-category { margin-bottom: 16px; }
    .tool-category-title { font-size: 9px; color: #666; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.05em; }
    .tool-item { background: var(--card); border: 1px solid var(--border); padding: 8px; margin-bottom: 6px; border-radius: 4px; cursor: grab; font-size: 11px; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
    .tool-item:hover { border-color: var(--accent); color: #fff; }
    .tool-icon { width: 6px; height: 6px; border-radius: 50%; background: var(--accent); }

    /* TIMELINE */
    .timeline-sidebar { width: 360px; background: var(--bg); border-right: 1px solid var(--border); display: flex; flex-direction: column; }
    .timeline-header { padding: 14px; background: var(--panel); border-bottom: 1px solid var(--border); }
    .brand { font-size: 13px; font-weight: 700; color: #fff; margin-bottom: 8px; }
    .schema-select { width: 100%; padding: 6px; background: #111; color: #ccc; border: 1px solid #333; border-radius: 4px; font-size: 11px; cursor: pointer; }
    .timeline-content { flex: 1; overflow-y: auto; padding: 16px; position: relative; }
    .timeline-content::before { content: ''; position: absolute; top: 16px; bottom: 16px; left: 29px; width: 1px; background: var(--border); z-index: 0; }

    .step-card { background: var(--card); border: 1px solid var(--border); border-radius: 6px; margin-bottom: 12px; position: relative; z-index: 1; transition: all 0.2s; cursor: pointer; }
    .step-card:hover { border-color: var(--text-dim); }
    .step-card.selected { border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent); }
    .step-num { position: absolute; left: -23px; top: 10px; width: 18px; height: 18px; background: var(--panel); border: 1px solid var(--text-dim); border-radius: 50%; font-size: 9px; font-weight: 700; display: flex; align-items: center; justify-content: center; z-index: 2; }
    .step-header { padding: 10px 12px; display: flex; justify-content: space-between; align-items: center; }
    .step-title { font-weight: 600; font-size: 11px; }
    .step-type { font-family: monospace; font-size: 9px; color: var(--accent); background: rgba(139, 92, 246, 0.1); padding: 1px 4px; border-radius: 3px; }
    .drop-zone { height: 3px; margin: 6px 0; border-radius: 2px; transition: all 0.2s; }
    .drop-zone.active { height: 18px; background: rgba(139, 92, 246, 0.1); border: 1px dashed var(--accent); }

    /* VIEWPORT */
    .viewport { flex: 1; position: relative; background: radial-gradient(circle at center, #18181b 0%, #09090b 100%); }
    canvas { display: block; width: 100%; height: 100%; }

    /* INSPECTOR */
    .inspector { width: 340px; background: var(--panel); border-left: 1px solid var(--border); display: flex; flex-direction: column; }
    .inspector-header { padding: 12px; border-bottom: 1px solid var(--border); font-weight: 700; font-size: 11px; display: flex; justify-content: space-between; }
    .inspector-content { padding: 14px; flex: 1; overflow-y: auto; }

    .prop-group { margin-bottom: 14px; }
    .prop-label { font-size: 10px; font-weight: 600; color: var(--text-dim); margin-bottom: 4px; display: block; }
    .prop-input { width: 100%; background: #111; border: 1px solid var(--border); color: #fff; padding: 6px; border-radius: 4px; font-family: monospace; font-size: 10px; }
    .prop-input:focus { border-color: var(--accent); outline: none; }
    select.prop-input { color: var(--accent); }

    .btn-danger { width: 100%; padding: 6px; background: rgba(239, 68, 68, 0.1); color: var(--danger); border: 1px solid var(--danger); border-radius: 4px; cursor: pointer; font-weight: 600; margin-top: 16px; font-size: 10px; }
    .btn-danger:hover { background: var(--danger); color: #fff; }

    .info-box { background: rgba(139, 92, 246, 0.05); border: 1px solid rgba(139, 92, 246, 0.2); padding: 8px; border-radius: 4px; font-size: 10px; color: var(--text-dim); margin-bottom: 12px; }

    /* JSON */
    .json-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 50; display: none; flex-direction: column; }
    .json-overlay.open { display: flex; }
    textarea.full-code { flex: 1; background: transparent; color: #0f0; border: none; padding: 16px; font-family: monospace; resize: none; font-size: 11px; }
  </style>
</head>
<body>

  <div class="app">
    <!-- TOOLBOX -->
    <div class="toolbox">
      <div class="toolbox-header">HELPERS LIBRARY</div>
      <div class="tool-list" id="tool-list"></div>
    </div>

    <!-- TIMELINE -->
    <div class="timeline-sidebar">
      <div class="timeline-header">
        <div class="brand">Spellshape Workbench</div>
        <select class="schema-select" onchange="window.loadSchema(this.value)">
          <option value="schema1">Logic Tower</option>
          <option value="schema2">Noise Column</option>
        </select>
      </div>
      <div class="timeline-content" id="timeline" ondragover="dragOver(event)" ondrop="drop(event)"></div>
      <div style="padding: 10px; border-top: 1px solid #333;">
        <button onclick="window.toggleJson()" style="width: 100%; padding: 6px; background: #222; color: #888; border: 1px solid #333; border-radius: 4px; cursor: pointer; font-size: 10px;">View JSON</button>
      </div>
    </div>

    <!-- VIEWPORT -->
    <div class="viewport">
      <canvas id="gl"></canvas>
    </div>

    <!-- INSPECTOR -->
    <div class="inspector">
      <div class="inspector-header">STEP PARAMETERS</div>
      <div class="inspector-content" id="inspector-content">
        <div style="color: #666; font-style: italic; text-align: center; margin-top: 30px;">
          Select a step to edit
        </div>
      </div>
    </div>

    <!-- JSON OVERLAY -->
    <div class="json-overlay" id="json-overlay">
      <div style="padding: 10px; border-bottom: 1px solid #333; display: flex; justify-content: space-between;">
        <span style="color: #fff; font-weight: bold; font-size: 11px;">SCHEMA SOURCE</span>
        <button onclick="window.toggleJson()" style="background: #333; color: #fff; border: none; padding: 3px 8px; cursor: pointer; font-size: 10px;">Close</button>
      </div>
      <textarea id="json-input" class="full-code" spellcheck="false"></textarea>
      <button onclick="window.updateFromJSON()" style="padding: 10px; background: #6d28d9; color: #fff; border: none; font-weight: bold; cursor: pointer; font-size: 10px;">UPDATE</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { ProceduralExecutor } from './src/modules/interpreter/procedural-executor.js';

    // --- HELPER DEFINITIONS WITH PARAMS ---
    const helpers = {
      // Basic Geometry
      'createBox': { category: 'Basic', params: { width: 1, height: 1, depth: 1, widthSegments: 1, heightSegments: 1, depthSegments: 1 } },
      'createSphere': { category: 'Basic', params: { radius: 1, widthSegments: 32, heightSegments: 16 } },
      'createCylinder': { category: 'Basic', params: { radiusTop: 1, radiusBottom: 1, height: 1, radialSegments: 32, heightSegments: 1 } },
      'createCone': { category: 'Basic', params: { radius: 1, height: 1, radialSegments: 32, heightSegments: 1 } },
      'createTorus': { category: 'Basic', params: { radius: 1, tube: 0.4, radialSegments: 16, tubularSegments: 100 } },
      'createCircle': { category: 'Basic', params: { radius: 1, segments: 32 } },
      'createPlane': { category: 'Basic', params: { width: 1, height: 1, widthSegments: 1, heightSegments: 1 } },

      // Advanced
      'createLoft': { category: 'Advanced', params: { profiles: [], heights: null, segments: 32, closed: false } },
      'createLathe': { category: 'Advanced', params: { points: [], segments: 12 } },
      'createConvexHull': { category: 'Advanced', params: { points: [] } },
      'createParametricSurface': { category: 'Advanced', params: { func: null, slices: 32, stacks: 32 } },

      // Curves
      'createSplinePath': { category: 'Curves', params: { points: [], tension: 0.5 } },
      'createArcPath': { category: 'Curves', params: { center: [0, 0, 0], radius: 1, startAngle: 0, endAngle: Math.PI, segments: 32 } },
      'createHelixPath': { category: 'Curves', params: { radius: 1, height: 3, turns: 3, segments: 128 } },

      // Deformations
      'twistGeometry': { category: 'Deform', params: { geometry: null, angle: 0.785, axis: [0, 1, 0], height: null } },
      'taperGeometry': { category: 'Deform', params: { geometry: null, topScale: [0.5, 0.5], axis: [0, 1, 0], height: null } },
      'bendGeometry': { category: 'Deform', params: { geometry: null, angle: 0.785, direction: [1, 0, 0] } },
      'deformByNoise': { category: 'Deform', params: { geometry: null, amount: 0.2, frequency: 1.0, axis: [0, 1, 0] } },

      // Distribution
      'repeatLinear3d': { category: 'Distribution', params: { geometry: null, count: 3, spacing: 1, axis: 'x', centered: false, autoMerge: true } },
      'repeatRadial3d': { category: 'Distribution', params: { geometry: null, count: 8, radius: 5, startAngle: 0, endAngle: 6.28, axis: 'y', faceCenter: true, autoMerge: true } },
      'distributeOnGrid3d': { category: 'Distribution', params: { geometry: null, rows: 3, cols: 3, spacing: [2, 0, 2], centered: true, autoMerge: true } },
      'distributeRandom3d': { category: 'Distribution', params: { geometry: null, bounds: [[0, 0, 0], [1, 1, 1]], count: 50, seed: 42, autoMerge: true } },

      // Procedural
      'cellularAutomata': { category: 'Procedural', params: { gridSize: 10, iterations: 10, rules: { survive: [2, 3], born: [3] } } },
      'lSystemGeometry': { category: 'Procedural', params: { axiom: 'F', rules: {}, iterations: 3, angle: 25, length: 1, thickness: 0.1 } },

      // Emergent
      'modifyGeometry': { category: 'Emergent', params: { geometry: null, operations: [], expression: '', context: {} } },
      'meshFromMarchingCubes': { category: 'Emergent', params: { resolution: 32, isovalue: 0.5, bounds: 10, expression: '', context: {} } },

      // Utilities
      'mergeGeometries': { category: 'Utility', params: { geometries: [] } },
      'loop': { category: 'Logic', params: { var: 'i', from: 0, to: 10, body: [] } },
    };

    // --- SCHEMAS ---
    const schemas = {
      schema1: {
        "version": "4.9", "intent": "Logic Tower",
        "globalParameters": {
          "floors": { "value": 15, "type": "integer", "min": 3, "max": 30 },
          "floorHeight": { "value": 3.5, "type": "number", "min": 2, "max": 5 },
          "scale": { "value": 1.0, "type": "number", "min": 0.5, "max": 2.0 }
        },
        "actions": [
          { "thought": "Create Slab", "do": "createBox", "params": { "width": 12, "height": 0.3, "depth": 12 }, "as": "slab" },
          { "thought": "Create Core", "do": "createBox", "params": { "width": 6, "height": "ctx.floorHeight", "depth": 6 }, "as": "core" },
          { "thought": "Stack Loop", "do": "loop", "var": "i", "from": 0, "to": "ctx.floors", "body": [
            { "do": "clone", "params": { "id": "slab" }, "transform": { "position": [0, "i * ctx.floorHeight", 0] } },
            { "do": "clone", "params": { "id": "core" }, "transform": { "position": [0, "i * ctx.floorHeight", 0] } }
          ]}
        ]
      },
      schema2: {
        "version": "4.9", "intent": "Noise Column",
        "globalParameters": { "layers": { "value": 50, "type": "integer", "min": 10, "max": 100 } },
        "actions": [
          { "thought": "Base Slice", "do": "createBox", "params": { "width": 4, "height": 0.2, "depth": 4 }, "as": "slice" },
          { "thought": "Noise Loop", "do": "loop", "var": "i", "from": 0, "to": "ctx.layers", "body": [
            { "do": "clone", "params": { "id": "slice" }, "transform": { "position": [0, "i*0.2", 0] } }
          ]}
        ]
      }
    };

    let currentSchema = schemas.schema1;
    let selectedStepIndex = -1;
    let draggedItem = null;
    let currentMesh = null;
    const executor = new ProceduralExecutor();

    // --- BUILD TOOLBOX ---
    function buildToolbox() {
      const list = document.getElementById('tool-list');
      list.innerHTML = '';
      const categories = {};

      for (const [name, info] of Object.entries(helpers)) {
        if (!categories[info.category]) categories[info.category] = [];
        categories[info.category].push(name);
      }

      for (const [cat, items] of Object.entries(categories)) {
        const catDiv = document.createElement('div');
        catDiv.className = 'tool-category';
        catDiv.innerHTML = `<div class="tool-category-title">${cat}</div>`;

        for (const item of items) {
          const tool = document.createElement('div');
          tool.className = 'tool-item';
          tool.draggable = true;
          tool.ondragstart = (e) => { draggedItem = { type: 'tool', tool: item }; e.dataTransfer.effectAllowed = 'copy'; };
          tool.innerHTML = `<div class="tool-icon"></div> ${item}`;
          catDiv.appendChild(tool);
        }
        list.appendChild(catDiv);
      }
    }

    // --- RENDER TIMELINE ---
    function renderTimeline() {
      const container = document.getElementById('timeline');
      container.innerHTML = '';

      // Global Params (Summary)
      const globalDiv = document.createElement('div');
      globalDiv.innerHTML = '<div style="font-size:9px; font-weight:700; color:#555; margin-bottom:8px;">GLOBAL PARAMS</div>';
      Object.keys(currentSchema.globalParameters).forEach(key => {
        const param = currentSchema.globalParameters[key];
        globalDiv.innerHTML += `<div style="font-size:9px; color:#666; margin-bottom:2px;">${key}: <span style="color:var(--accent);">${param.value}</span></div>`;
      });
      globalDiv.style.paddingBottom = '12px';
      globalDiv.style.borderBottom = '1px solid #333';
      globalDiv.style.marginBottom = '12px';
      container.appendChild(globalDiv);

      // Steps
      currentSchema.actions.forEach((action, index) => {
        const dropZone = document.createElement('div');
        dropZone.className = 'drop-zone';
        dropZone.ondragenter = (e) => e.target.classList.add('active');
        dropZone.ondragleave = (e) => e.target.classList.remove('active');
        dropZone.ondrop = (e) => handleDrop(e, index);
        container.appendChild(dropZone);

        const card = document.createElement('div');
        card.className = `step-card ${selectedStepIndex === index ? 'selected' : ''}`;
        card.draggable = true;
        card.ondragstart = (e) => { draggedItem = { type: 'step', index }; };
        card.onclick = () => selectStep(index);
        card.innerHTML = `
          <div class="step-num">${index + 1}</div>
          <div class="step-header">
            <div class="step-title">${action.thought}</div>
            <div class="step-type">${action.do}</div>
          </div>
        `;
        container.appendChild(card);
      });

      // Final drop
      const lastDrop = document.createElement('div');
      lastDrop.className = 'drop-zone';
      lastDrop.ondragenter = (e) => e.target.classList.add('active');
      lastDrop.ondragleave = (e) => e.target.classList.remove('active');
      lastDrop.ondrop = (e) => handleDrop(e, currentSchema.actions.length);
      container.appendChild(lastDrop);
    }

    // --- DRAG & DROP ---
    window.dragOver = (e) => e.preventDefault();
    window.drop = (e) => e.preventDefault();
    window.handleDrop = (e, targetIndex) => {
      e.preventDefault();
      document.querySelectorAll('.drop-zone').forEach(z => z.classList.remove('active'));
      if (!draggedItem) return;

      const actions = currentSchema.actions;
      if (draggedItem.type === 'step') {
        const [item] = actions.splice(draggedItem.index, 1);
        const newIdx = draggedItem.index < targetIndex ? targetIndex - 1 : targetIndex;
        actions.splice(newIdx, 0, item);
      } else {
        const newAction = createDefaultAction(draggedItem.tool);
        actions.splice(targetIndex, 0, newAction);
      }
      draggedItem = null;
      selectedStepIndex = -1;
      renderTimeline();
      renderInspector();
      run();
    };

    function createDefaultAction(tool) {
      const helperInfo = helpers[tool];
      return {
        thought: `${tool}`,
        do: tool,
        params: { ...helperInfo.params },
        as: `obj_${Date.now().toString().slice(-4)}`
      };
    }

    // --- INSPECTOR ---
    window.selectStep = (index) => {
      selectedStepIndex = index;
      renderTimeline();
      renderInspector();
    };

    function renderInspector() {
      const container = document.getElementById('inspector-content');
      container.innerHTML = '';

      if (selectedStepIndex < 0 || selectedStepIndex >= currentSchema.actions.length) return;

      const action = currentSchema.actions[selectedStepIndex];
      const helperInfo = helpers[action.do];

      container.appendChild(createInput('Thought', action.thought, (v) => { action.thought = v; renderTimeline(); }));
      container.appendChild(createInput('Output Name (as)', action.as || '', (v) => { action.as = v; }));

      if (helperInfo && helperInfo.params) {
        const paramsHeader = document.createElement('div');
        paramsHeader.style = 'margin-top: 12px; font-weight: 700; font-size: 10px; color: #fff; border-bottom: 1px solid #333; padding-bottom: 4px; margin-bottom: 8px;';
        paramsHeader.innerText = `PARAMETERS (${action.do})`;
        container.appendChild(paramsHeader);

        const availableGeometries = currentSchema.actions.filter(a => a.as).map(a => a.as);
        const availableGlobalParams = Object.keys(currentSchema.globalParameters);

        for (const [paramKey, defaultVal] of Object.entries(helperInfo.params)) {
          const currentVal = action.params?.[paramKey] !== undefined ? action.params[paramKey] : defaultVal;

          // Special UI for geometry references
          if (paramKey === 'geometry' || paramKey === 'geometries') {
            const select = createSelect(paramKey, currentVal, availableGeometries, (v) => {
              action.params[paramKey] = v;
              run();
            });
            container.appendChild(select);
          }
          // For loop params
          else if (paramKey === 'to' || paramKey === 'from' || paramKey === 'count') {
            container.appendChild(createExpressionInput(paramKey, currentVal, availableGlobalParams, (v) => {
              action.params[paramKey] = isNaN(v) ? v : parseFloat(v);
              run();
            }));
          }
          else if (typeof defaultVal === 'number') {
            container.appendChild(createSlider(paramKey, currentVal, defaultVal, (v) => {
              action.params[paramKey] = v;
              run();
            }));
          }
          else if (typeof defaultVal === 'string') {
            container.appendChild(createExpressionInput(paramKey, currentVal, availableGlobalParams, (v) => {
              action.params[paramKey] = v;
              run();
            }));
          }
        }
      }

      const delBtn = document.createElement('button');
      delBtn.className = 'btn-danger';
      delBtn.innerText = 'Delete Step';
      delBtn.onclick = () => {
        currentSchema.actions.splice(selectedStepIndex, 1);
        selectedStepIndex = -1;
        renderTimeline();
        renderInspector();
        run();
      };
      container.appendChild(delBtn);
    }

    function createInput(label, val, onChange) {
      const group = document.createElement('div');
      group.className = 'prop-group';
      const input = document.createElement('input');
      input.className = 'prop-input';
      input.value = val;
      input.placeholder = label;
      input.onchange = (e) => onChange(e.target.value);
      group.innerHTML = `<label class="prop-label">${label}</label>`;
      group.appendChild(input);
      return group;
    }

    function createSlider(label, val, defaultVal, onChange) {
      const group = document.createElement('div');
      group.className = 'prop-group';
      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = -100;
      slider.max = 100;
      slider.step = 0.1;
      slider.value = val;
      slider.oninput = (e) => { onChange(parseFloat(e.target.value)); valSpan.innerText = parseFloat(e.target.value).toFixed(2); };
      const valSpan = document.createElement('span');
      valSpan.className = 'prop-val';
      valSpan.style = 'color: var(--accent); font-family: monospace; font-size: 9px;';
      valSpan.innerText = parseFloat(val).toFixed(2);
      group.innerHTML = `<label class="prop-label">${label}</label>`;
      group.appendChild(slider);
      group.appendChild(document.createElement('br'));
      group.appendChild(valSpan);
      return group;
    }

    function createExpressionInput(label, val, globalParams, onChange) {
      const group = document.createElement('div');
      group.className = 'prop-group';
      const input = document.createElement('input');
      input.className = 'prop-input';
      input.value = val;
      input.placeholder = `e.g. ctx.${globalParams[0] || 'param'} or 5`;
      input.onchange = (e) => onChange(e.target.value);
      group.innerHTML = `<label class="prop-label">${label}</label>`;
      group.appendChild(input);
      if (globalParams.length > 0) {
        const hint = document.createElement('div');
        hint.style = 'font-size: 9px; color: #666; margin-top: 2px;';
        hint.innerText = `Available: ${globalParams.map(p => `ctx.${p}`).join(', ')}`;
        group.appendChild(hint);
      }
      return group;
    }

    function createSelect(label, val, options, onChange) {
      const group = document.createElement('div');
      group.className = 'prop-group';
      const select = document.createElement('select');
      select.className = 'prop-input';
      select.innerHTML = '<option value="">-- Select Object --</option>';
      options.forEach(opt => {
        const op = document.createElement('option');
        op.value = opt;
        op.innerText = opt;
        op.selected = val === opt;
        select.appendChild(op);
      });
      select.onchange = (e) => onChange(e.target.value);
      group.innerHTML = `<label class="prop-label">${label}</label>`;
      group.appendChild(select);
      return group;
    }

    // --- GLOBAL ---
    window.loadSchema = (k) => { currentSchema = schemas[k]; selectedStepIndex = -1; renderTimeline(); renderInspector(); run(); };
    window.toggleJson = () => { document.getElementById('json-overlay').classList.toggle('open'); document.getElementById('json-input').value = JSON.stringify(currentSchema, null, 2); };
    window.updateFromJSON = () => {
      try { currentSchema = JSON.parse(document.getElementById('json-input').value); window.toggleJson(); renderTimeline(); run(); }
      catch(e) { alert('Invalid JSON'); }
    };

    // --- 3D ---
    const canvas = document.querySelector('#gl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
    const controls = new OrbitControls(camera, canvas);
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    camera.position.set(30, 30, 30);
    scene.background = new THREE.Color(0x09090b);
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(50, 100, 50);
    scene.add(dirLight);
    scene.add(new THREE.GridHelper(100, 20, 0x27272a, 0x18181b));

    function run() {
      if (currentMesh) scene.remove(currentMesh);
      const params = {};
      for (const [k, v] of Object.entries(currentSchema.globalParameters)) params[k] = v.value;
      try {
        currentMesh = executor.execute(currentSchema, params);
        scene.add(currentMesh);
      } catch(e) { console.error(e); }
    }

    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    animate();

    buildToolbox();
    renderTimeline();
    run();

    window.onresize = () => {
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    };
  </script>
</body>
</html>
