<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spellshape - Final UI</title>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <style>
    :root {
      --bg: #121214;
      --panel: #1c1c21;
      --card: #25252b;
      --border: #333;
      --accent: #646cff;
      --text: #ececec;
      --text-dim: #888;
    }

    body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Inter', system-ui, sans-serif; color: var(--text); }
    .app { display: flex; height: 100vh; width: 100vw; }
    
    /* SIDEBAR */
    .sidebar {
      flex: 0 0 400px;
      width: 400px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      z-index: 10;
    }

    .header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
      background: var(--bg);
    }
    .header h1 { margin: 0; font-size: 16px; font-weight: 700; letter-spacing: -0.5px; }

    /* TABS */
    .tabs { display: flex; padding: 0 20px; border-bottom: 1px solid var(--border); }
    .tab {
      padding: 12px 0; margin-right: 20px;
      font-size: 12px; font-weight: 600; color: var(--text-dim);
      cursor: pointer; border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }
    .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
    .tab:hover { color: #fff; }

    /* CONTENT AREA */
    .content { flex: 1; overflow-y: auto; padding: 20px; display: none; }
    .content.active { display: block; }

    /* SHARED SLIDER STYLES */
    .control { margin-bottom: 16px; }
    .control-header { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 6px; }
    .control-val { font-family: monospace; color: var(--accent); }
    .control-label { color: #ccc; font-weight: 500; }

    input[type=range] {
      width: 100%; -webkit-appearance: none; background: transparent; cursor: pointer;
    }
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%; height: 4px; background: #333; border-radius: 2px;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
      background: #fff; margin-top: -5px; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      transition: background 0.2s, transform 0.2s;
    }
    input[type=range]:hover::-webkit-slider-thumb { background: var(--accent); transform: scale(1.1); }

    /* TAB 1: GROUPS */
    .group-title {
      font-size: 10px; font-weight: 700; text-transform: uppercase; color: var(--text-dim);
      margin: 24px 0 12px 0; letter-spacing: 1px; border-bottom: 1px solid #333; padding-bottom: 4px;
    }
    .group-title:first-child { margin-top: 0; }

    /* TAB 2: RECIPE CARDS */
    .step-card {
      background: var(--card); border: 1px solid var(--border); border-radius: 6px;
      padding: 14px; margin-bottom: 12px; position: relative;
    }
    .step-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
    .step-num { 
      width: 18px; height: 18px; background: #333; border-radius: 50%; 
      font-size: 10px; font-weight: bold; color: #888; 
      display: flex; align-items: center; justify-content: center;
    }
    .step-title { font-size: 13px; font-weight: 600; color: #fff; }
    
    .step-controls { 
      margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.05); 
    }

    /* TAB 3: JSON */
    textarea {
      width: 100%; height: 100%; background: #111; border: none;
      color: #ccc; font-family: monospace; font-size: 11px; padding: 10px; resize: none;
    }

    /* VIEWPORT */
    .viewport { flex: 1; position: relative; background: radial-gradient(circle at center, #222 0%, #111 100%); }
    canvas { display: block; width: 100%; height: 100%; outline: none; }
    
    .stats {
      position: absolute; bottom: 20px; right: 20px;
      font-family: monospace; font-size: 10px; color: #666;
      background: rgba(0,0,0,0.5); padding: 8px 12px; border-radius: 4px;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <div class="app">
    <div class="sidebar">
      <div class="header">
        <h1>Spellshape</h1>
      </div>
      
      <div class="tabs">
        <div class="tab active" onclick="setTab('controls')">Controls</div>
        <div class="tab" onclick="setTab('recipe')">Recipe</div>
        <div class="tab" onclick="setTab('json')">JSON</div>
      </div>

      <!-- TAB 1: CONTROLS -->
      <div id="tab-controls" class="content active">
        <!-- Generated JS -->
      </div>

      <!-- TAB 2: RECIPE -->
      <div id="tab-recipe" class="content">
        <!-- Generated JS -->
      </div>

      <!-- TAB 3: JSON -->
      <div id="tab-json" class="content" style="padding:0;">
        <textarea id="json-input" spellcheck="false"></textarea>
        <div style="padding: 10px; background: var(--panel); border-top: 1px solid var(--border);">
          <button onclick="updateFromJSON()" style="width:100%; padding:8px; background:var(--accent); border:none; border-radius:4px; color:white; cursor:pointer; font-weight:600;">Update</button>
        </div>
      </div>
    </div>

    <div class="viewport">
      <canvas id="gl"></canvas>
      <div class="stats" id="stats">Ready</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { ProceduralExecutor } from './src/modules/interpreter/procedural-executor.js';

    // --- SCHEMA (v4.8 - Curated Controls) ---
    const schema1 = {
  "version": "4.9",
  "type": "emergent_procedure",
  "intent": "Decoupled Logic Tower",
  "materials": {
    "wall": { "color": "#1a3a5c", "roughness": 0.7, "metalness": 0.1 },
    "window": { "color": "#b3d9ff", "roughness": 0.1, "metalness": 0.8, "transparent": true, "opacity": 0.6 },
    "core": { "color": "#c1440e", "roughness": 0.6, "metalness": 0 },
    "column": { "color": "#2a2a2a", "roughness": 0.8, "metalness": 0.3 },
    "floor_slab": { "color": "#b8b8b8", "roughness": 0.7, "metalness": 0.1 }
  },
  
  // 1. INDEPENDENT PARAMETERS
  "globalParameters": {
    "floors": { "value": 15, "type": "integer", "min": 3, "max": 30, "group": "Massing" },
    "floorHeight": { "value": 3.5, "type": "number", "min": 2, "max": 5, "group": "Massing" },
    
    // SLAB IS NOW INDEPENDENT
    "slabWidth": { "value": 12, "type": "number", "min": 6, "max": 24, "group": "Slab" },
    "slabDepth": { "value": 12, "type": "number", "min": 6, "max": 24, "group": "Slab" },
    "slabThickness": { "value": 0.3, "type": "number", "min": 0.1, "max": 1.0, "group": "Slab" },

    // CORE IS INDEPENDENT
    "coreWidth": { "value": 8, "type": "number", "min": 4, "max": 16, "group": "Core" },
    "coreDepth": { "value": 8, "type": "number", "min": 4, "max": 16, "group": "Core" },
    
    // COLUMNS USE INSET FROM SLAB EDGE
    "colRadius": { "value": 0.4, "type": "number", "min": 0.2, "max": 0.8, "group": "Columns" },
    "colInsetX": { "value": 1.0, "type": "number", "min": 0.5, "max": 4.0, "group": "Columns" },
    "colInsetZ": { "value": 1.0, "type": "number", "min": 0.5, "max": 4.0, "group": "Columns" },
    
    "panelsPerSide": { "value": 6, "type": "integer", "min": 2, "max": 12, "group": "Facade" },
    "rotationPerFloor": { "value": 0.08, "type": "number", "min": 0, "max": 0.2, "group": "Animation" }
  },
  
  "context": {}, 

  "actions": [
    // ----------------------------------------------------------------
    // 1. SLAB (Uses slabWidth/Depth directly)
    // ----------------------------------------------------------------
    { 
      "thought": "1. Create Slab Base", 
      "do": "createBox", 
      "params": { 
        "width": "ctx.slabWidth", 
        "height": "ctx.slabThickness", 
        "depth": "ctx.slabDepth" 
      }, 
      "transform": { "position": [0, "-ctx.slabThickness/2", 0] }, 
      "as": "slab_mesh",
      "controls": ["slabWidth", "slabDepth", "slabThickness"] 
    },

    // ----------------------------------------------------------------
    // 2. CORE
    // ----------------------------------------------------------------
    { 
      "thought": "2. Create Core", 
      "do": "createBox", 
      "params": { 
        "width": "ctx.coreWidth", 
        "height": "ctx.floorHeight", 
        "depth": "ctx.coreDepth" 
      }, 
      "transform": { "position": [0, "ctx.floorHeight/2", 0] }, 
      "as": "core_mesh",
      "controls": ["coreWidth", "coreDepth"]
    },

    // ----------------------------------------------------------------
    // 3. COLUMNS (Position based on Slab Width minus Inset)
    // ----------------------------------------------------------------
    { 
      "thought": "3. Define Columns", 
      "do": "createCylinder", 
      "params": { 
        "radiusTop": "ctx.colRadius", 
        "radiusBottom": "ctx.colRadius", 
        "height": "ctx.floorHeight" 
      }, 
      "transform": { "position": [0, "ctx.floorHeight/2", 0] }, 
      "as": "col_base",
      "controls": ["colRadius", "floorHeight"]
    },
    { 
      "thought": "4. Distribute Columns", 
      "do": "distributeOnGrid3d", 
      "params": { 
        "geometry": "col_base", 
        "rows": 2, "cols": 2, 
        "spacing": [
          "ctx.slabWidth - (ctx.colInsetX * 2)", 
          0, 
          "ctx.slabDepth - (ctx.colInsetZ * 2)"
        ], 
        "centered": true, "autoMerge": true 
      }, 
      "as": "cols_mesh",
      "controls": ["colInsetX", "colInsetZ"]
    },

    // ----------------------------------------------------------------
    // 4. FACADE PANELS (Follows Slab Size)
    // ----------------------------------------------------------------
    { 
      "thought": "5. Create Facade Geometry", 
      "do": "createBox", 
      "params": { 
        "width": "ctx.slabWidth / ctx.panelsPerSide - 0.1", 
        "height": "ctx.floorHeight", 
        "depth": 0.2 
      }, 
      "transform": { "position": [0, "ctx.floorHeight/2", 0] }, 
      "as": "panel_horz",
      "controls": ["panelsPerSide"]
    },
    { 
      "do": "createBox", 
      "params": { 
        "width": 0.2, 
        "height": "ctx.floorHeight", 
        "depth": "ctx.slabDepth / ctx.panelsPerSide - 0.1" 
      }, 
      "transform": { "position": [0, "ctx.floorHeight/2", 0] }, 
      "as": "panel_vert" 
    },

    // ----------------------------------------------------------------
    // 5. FACADE ASSEMBLY
    // ----------------------------------------------------------------
    { 
      "thought": "6. Assemble Facade", 
      "do": "repeatLinear3d", 
      "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabWidth / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, 
      "transform": { "position": ["-(ctx.slabWidth/ctx.panelsPerSide)/2", 0, "ctx.slabDepth/2 - 0.1"] }, 
      "as": "front_even" 
    },
    { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabWidth / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["(ctx.slabWidth/ctx.panelsPerSide)/2", 0, "ctx.slabDepth/2 - 0.1"] }, "as": "front_odd" },
    
    { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabWidth / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["-(ctx.slabWidth/ctx.panelsPerSide)/2", 0, "-ctx.slabDepth/2 + 0.1"] }, "as": "back_even" },
    { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabWidth / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["(ctx.slabWidth/ctx.panelsPerSide)/2", 0, "-ctx.slabDepth/2 + 0.1"] }, "as": "back_odd" },

    { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabDepth / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["-ctx.slabWidth/2 + 0.1", 0, "-(ctx.slabDepth/ctx.panelsPerSide)/2"] }, "as": "left_even" },
    { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabDepth / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["-ctx.slabWidth/2 + 0.1", 0, "(ctx.slabDepth/ctx.panelsPerSide)/2"] }, "as": "left_odd" },

    { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabDepth / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["ctx.slabWidth/2 - 0.1", 0, "-(ctx.slabDepth/ctx.panelsPerSide)/2"] }, "as": "right_even" },
    { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "(ctx.slabDepth / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["ctx.slabWidth/2 - 0.1", 0, "(ctx.slabDepth/ctx.panelsPerSide)/2"] }, "as": "right_odd" },

    // ----------------------------------------------------------------
    // 6. STACKING
    // ----------------------------------------------------------------
    { 
      "thought": "7. Stack Floors", 
      "do": "loop", "var": "i", "from": 0, "to": "ctx.floors",
      "controls": ["floors", "rotationPerFloor"],
      "body": [
         { "do": "clone", "params": {"id":"slab_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "floor_slab" },
         { "do": "clone", "params": {"id":"core_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "core" },
         { "do": "clone", "params": {"id":"cols_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "column" },
         { "do": "clone", "params": {"id":"front_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
         { "do": "clone", "params": {"id":"front_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
         { "do": "clone", "params": {"id":"back_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
         { "do": "clone", "params": {"id":"back_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
         { "do": "clone", "params": {"id":"left_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
         { "do": "clone", "params": {"id":"left_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
         { "do": "clone", "params": {"id":"right_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
         { "do": "clone", "params": {"id":"right_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" }
      ] 
    }
  ]
};

    const schema2 = {
  "version": "4.9",
  "type": "emergent_procedure",
  "intent": "Noise Eroded Column",
  "materials": {
    "concrete": { "color": "#8c8c8c", "roughness": 0.9, "metalness": 0.1 },
    "inner_core": { "color": "#333333", "roughness": 0.5, "metalness": 0.5 }
  },
  "globalParameters": {
    "height": { "value": 12, "type": "number", "min": 5, "max": 20, "group": "Dimensions" },
    "width": { "value": 3, "type": "number", "min": 1, "max": 6, "group": "Dimensions" },
    
    // Resolution: Higher = Smoother, Slower
    "layerCount": { "value": 100, "type": "integer", "min": 20, "max": 200, "group": "Resolution" },
    
    // Noise Parameters
    "erosionScale": { "value": 0.8, "type": "number", "min": 0.1, "max": 2.0, "group": "Erosion" },
    "erosionDepth": { "value": 1.2, "type": "number", "min": 0, "max": 2.0, "group": "Erosion" },
    "chaos": { "value": 1.5, "type": "number", "min": 0, "max": 5.0, "group": "Erosion" }
  },
  "context": {},
  "actions": [
    // 1. Define the "Slice" (A single layer of the column)
    {
      "thought": "1. Create Base Slice",
      "do": "createBox",
      "params": {
        "width": "ctx.width",
        "height": "ctx.height / ctx.layerCount", // Thickness depends on resolution
        "depth": "ctx.width"
      },
      "as": "slice_geo",
      "controls": ["width", "height", "layerCount"]
    },
    
    // 2. Define a darker inner core (so erosion reveals something)
    {
      "thought": "2. Create Inner Core Slice",
      "do": "createBox",
      "params": {
        "width": "ctx.width * 0.4",
        "height": "ctx.height / ctx.layerCount",
        "depth": "ctx.width * 0.4"
      },
      "as": "core_geo"
    },

    // 3. The Emergent Loop
    // We calculate 'y' (normalized height 0-1) and use it to drive Sine waves
    {
      "thought": "3. Erode & Stack Layers",
      "do": "loop",
      "var": "i",
      "from": 0,
      "to": "ctx.layerCount",
      "controls": ["erosionScale", "erosionDepth", "chaos"],
      "body": [
        // --- LOGIC EXPLAINED ---
        // n1: Large, slow wave (General shape)
        // n2: Fast, chaotic wave (Detail/Roughness)
        // erosion: Combine them. If > 0, subtract from scale.
        
        // Outer Shell (Eroded)
        {
          "do": "clone",
          "params": { "id": "slice_geo" },
          "transform": {
            "position": [0, "i * (ctx.height / ctx.layerCount)", 0],
            
            // Erosion Logic X:
            // Scale = 1.0 - max(0, (sin(slow) + cos(fast)) * depth)
            "scale": [
              "1.0 - Math.max(0, (Math.sin(i * 0.1 * ctx.erosionScale) + Math.cos(i * 0.3 * ctx.chaos)) * ctx.erosionDepth * 0.5)", 
              1, 
              "1.0 - Math.max(0, (Math.cos(i * 0.1 * ctx.erosionScale) + Math.sin(i * 0.33 * ctx.chaos)) * ctx.erosionDepth * 0.5)"
            ],
            
            // Slight rotation for organic feel
            "rotation": [0, "i * 0.02", 0]
          },
          "material": "concrete"
        },
        
        // Inner Core (Solid, visible through cracks)
        {
          "do": "clone",
          "params": { "id": "core_geo" },
          "transform": {
            "position": [0, "i * (ctx.height / ctx.layerCount)", 0],
            "rotation": [0, "i * 0.02", 0]
          },
          "material": "inner_core"
        }
      ]
    }
  ]
};

    const schema3 = {
  "version": "4.9",
  "type": "emergent_procedure",
  "intent": "Deformed Surface Monolith",
  "materials": {
    "stone": { "color": "#e0e0e0", "roughness": 0.8, "metalness": 0.1 }
  },
  "globalParameters": {
    // DIMENSIONS
    "width": { "value": 6, "type": "number", "min": 2, "max": 10, "group": "Dimensions" },
    "height": { "value": 12, "type": "number", "min": 5, "max": 20, "group": "Dimensions" },
    "depth": { "value": 6, "type": "number", "min": 2, "max": 10, "group": "Dimensions" },
    
    // QUALITY
    "resolution": { "value": 30, "type": "integer", "min": 10, "max": 100, "group": "Quality" },
    
    // DEFORMATION
    "waveFreq": { "value": 0.8, "type": "number", "min": 0.1, "max": 2.0, "group": "Deformation" },
    "waveAmp": { "value": 1.5, "type": "number", "min": 0.0, "max": 3.0, "group": "Deformation" },
    "taper": { "value": 0.3, "type": "number", "min": -0.5, "max": 1.0, "group": "Deformation" }
  },
  "context": {},
  "actions": [
    // 1. Create Geometry
    {
      "thought": "1. Create High-Res Box",
      "do": "createBox",
      "params": {
        "width": "ctx.width",
        "height": "ctx.height",
        "depth": "ctx.depth",
        "widthSegments": "ctx.resolution",
        "heightSegments": "ctx.resolution",
        "depthSegments": "ctx.resolution"
      },
      "as": "base_mesh",
      "controls": ["width", "height", "resolution"]
    },
    
    // 2. Deform It (Using ctx variables)
    {
      "thought": "2. Apply Ripple & Taper",
      "do": "modifyGeometry",
      "params": {
        "geometry": "base_mesh",
        "operations": [
          {
            "type": "displace",
            // Sine Wave Ripple
            "expression": "v.x += Math.sin(v.y * ctx.waveFreq) * ctx.waveAmp; v.z += Math.cos(v.y * ctx.waveFreq) * ctx.waveAmp;"
          },
          {
            "type": "scale",
            // Vertical Taper
            "expression": "var s = 1.0 - (v.y / ctx.height) * ctx.taper; v.x *= s; v.z *= s;"
          }
        ]
      },
      "material": "stone",
      "controls": ["waveFreq", "waveAmp", "taper"]
    }
  ]
};

    const schema4 = {
  "version": "4.9",
  "type": "emergent_procedure",
  "intent": "Box-Preserving Voxel Monolith",
  "materials": {
    "stone": { "color": "#e0e0e0", "roughness": 0.9, "metalness": 0.1 }
  },
  "globalParameters": {
    // DIMENSIONS
    "width": { "value": 5, "type": "number", "min": 2, "max": 10, "group": "Dimensions" },
    "height": { "value": 12, "type": "number", "min": 5, "max": 20, "group": "Dimensions" },
    "depth": { "value": 5, "type": "number", "min": 2, "max": 10, "group": "Dimensions" },
    
    // QUALITY
    "resolution": { "value": 60, "type": "integer", "min": 20, "max": 120, "group": "Quality" },
    
    // VOXEL LAYER
    "voxelSize": { "value": 0.5, "type": "number", "min": 0.1, "max": 2.0, "group": "Voxel Layer" },
    "erosionThreshold": { "value": 0.4, "type": "number", "min": 0.0, "max": 0.9, "group": "Voxel Layer" },
    "layerDepth": { "value": 1.5, "type": "number", "min": 0.5, "max": 5.0, "group": "Voxel Layer" },
    
    // BASE SHAPE
    "taper": { "value": 0.2, "type": "number", "min": -0.5, "max": 1.0, "group": "Base Shape" }
  },
  "context": {},
  "actions": [
    // 1. Create Base Core
    {
      "thought": "1. Create Base Core",
      "do": "createBox",
      "params": {
        "width": "ctx.width",
        "height": "ctx.height",
        "depth": "ctx.depth",
        "widthSegments": "ctx.resolution",
        "heightSegments": "ctx.resolution",
        "depthSegments": "ctx.resolution"
      },
      "as": "base_mesh",
      "controls": ["width", "height", "depth", "resolution"]
    },
    
    // 2. Box-Preserving Expansion
    {
      "thought": "2. Extrude Voxels via Scaling",
      "do": "modifyGeometry",
      "params": {
        "geometry": "base_mesh",
        "operations": [
          // 1. Base Taper
          {
            "type": "scale",
            "expression": "var s = 1.0 - (v.y / ctx.height) * ctx.taper; v.x *= s; v.z *= s;"
          },
          // 2. Voxel Expansion (Non-spherical)
          {
            "type": "displace",
            "expression": `
              // A. Voxel Quantization
              var step = ctx.voxelSize;
              var qx = Math.floor(v.x / step);
              var qy = Math.floor(v.y / step);
              var qz = Math.floor(v.z / step);

              // B. Generate Hash
              var dot = qx * 12.9898 + qy * 78.233 + qz * 37.719;
              var hash = Math.sin(dot) * 43758.5453;
              var noise = hash - Math.floor(hash);

              // C. EXPAND PRESERVING BOX SHAPE
              // Instead of pushing by a vector, we scale the position.
              // We calculate 'k' per axis so the offset (thickness) is constant.
              
              if (noise > ctx.erosionThreshold) {
                  // k = DesiredOffset / CurrentHalfSize
                  // We use 2.0 * layerDepth because width is full width.
                  var kx = (2.0 * ctx.layerDepth) / ctx.width;
                  var ky = (2.0 * ctx.layerDepth) / ctx.height;
                  var kz = (2.0 * ctx.layerDepth) / ctx.depth;

                  // Apply expansion
                  v.x += v.x * kx;
                  v.y += v.y * ky;
                  v.z += v.z * kz;
              }
            `
          }
        ]
      },
      "material": "stone",
      "controls": ["voxelSize", "erosionThreshold", "layerDepth"]
    }
  ]
};

    {
  "thought": "Apply box-perpendicular voxel erosion",
  "do": "modifyGeometry",
  "params": {
    "geometry": "base_mesh",
    "operations": [
      // 1. Voxel erosion FIRST, on the original cube
      {
        "type": "displace",
        "expression": `
          // Quantize for voxel pattern
          var step = ctx.voxelSize;
          var qx = Math.floor(v.x / step);
          var qy = Math.floor(v.y / step);
          var qz = Math.floor(v.z / step);

          // Pseudo-noise hash
          var dot = qx * 12.9898 + qy * 78.233 + qz * 37.719;
          var hash = Math.sin(dot) * 43758.5453;
          var noise = hash - Math.floor(hash);

          if (noise > ctx.erosionThreshold) {
              // Choose dominant axis (box face direction)
              var ax = Math.abs(v.x);
              var ay = Math.abs(v.y);
              var az = Math.abs(v.z);

              var dx = 0.0, dy = 0.0, dz = 0.0;

              if (ax >= ay && ax >= az) {
                  dx = (v.x >= 0.0) ? 1.0 : -1.0;  // ±X face
              } else if (ay >= ax && ay >= az) {
                  dy = (v.y >= 0.0) ? 1.0 : -1.0;  // ±Y face
              } else {
                  dz = (v.z >= 0.0) ? 1.0 : -1.0;  // ±Z face
              }

              // Move along that face normal
              v.x += dx * ctx.layerDepth;
              v.y += dy * ctx.layerDepth;
              v.z += dz * ctx.layerDepth;
          }
        `
      },

      // 2. Then apply taper / other deformations on top
      {
        "type": "scale",
        "expression": "var s = 1.0 - (v.y / ctx.height) * ctx.taper; v.x *= s; v.z *= s;"
      }
    ]
  },
  "material": "stone",
  "controls": ["voxelSize", "erosionThreshold", "layerDepth", "taper"]
}










    // --- UI LOGIC ---
    const tabs = { controls: document.getElementById('tab-controls'), recipe: document.getElementById('tab-recipe'), json: document.getElementById('tab-json') };
    const jsonInput = document.getElementById('json-input');

    window.setTab = (name) => {
      document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
      document.querySelectorAll('.content').forEach(el => el.classList.remove('active'));
      
      document.querySelector(`.tab[onclick="setTab('${name}')"]`).classList.add('active');
      tabs[name].classList.add('active');

      if (name === 'json') {
        jsonInput.value = JSON.stringify(schema, null, 2);
      }
    };

    // --- HELPER: Create Slider ---
    function createSlider(key, def, uniqueId) {
      const wrapper = document.createElement('div');
      wrapper.className = 'control';
      
      const header = document.createElement('div');
      header.className = 'control-header';
      header.innerHTML = `<span class="control-label">${key}</span><span class="control-val" id="val-${uniqueId}">${def.value}</span>`;
      
      const input = document.createElement('input');
      input.type = 'range';
      input.min = def.min;
      input.max = def.max;
      input.step = def.step || (def.type === 'integer' ? 0.1 : 0.01);
      input.value = def.value;
      input.setAttribute('data-key', key);

      input.oninput = (e) => {
        const val = def.type === 'integer' ? parseInt(e.target.value) : parseFloat(e.target.value);
        def.value = val;
        
        // Update ALL sliders and text displays for this key
        document.querySelectorAll(`input[data-key="${key}"]`).forEach(el => el.value = val);
        document.querySelectorAll(`[id^="val-"]`).forEach(el => {
          if (el.id.startsWith(`val-ctrl-${key}`) || el.id.startsWith(`val-recipe-${key}`)) {
            el.innerText = val;
          }
        });
        
        run();
      };

      wrapper.appendChild(header);
      wrapper.appendChild(input);
      return wrapper;
    }

    // --- RENDER TABS ---
    function renderUI() {
      // 1. CONTROLS TAB
      tabs.controls.innerHTML = '';
      const groups = {};
      for (const [key, def] of Object.entries(schema.globalParameters)) {
        const g = def.group || 'General';
        if (!groups[g]) groups[g] = [];
        groups[g].push({ key, def });
      }

      for (const [gName, items] of Object.entries(groups)) {
        const title = document.createElement('div');
        title.className = 'group-title';
        title.innerText = gName;
        tabs.controls.appendChild(title);
        items.forEach(({ key, def }) => tabs.controls.appendChild(createSlider(key, def, `ctrl-${key}`)));
      }

      // 2. RECIPE TAB
      tabs.recipe.innerHTML = '';
      schema.actions.forEach((action, i) => {
        if (!action.thought) return;

        const card = document.createElement('div');
        card.className = 'step-card';
        card.innerHTML = `<div class="step-header"><div class="step-num">${i+1}</div><div class="step-title">${action.thought}</div></div>`;

        if (action.controls && action.controls.length > 0) {
          const controlsArea = document.createElement('div');
          controlsArea.className = 'step-controls';
          action.controls.forEach(key => {
            if (schema.globalParameters[key]) {
              controlsArea.appendChild(createSlider(key, schema.globalParameters[key], `recipe-${key}`));
            }
          });
          card.appendChild(controlsArea);
        }
        tabs.recipe.appendChild(card);
      });
    }

    window.updateFromJSON = () => {
      try {
        schema = JSON.parse(jsonInput.value);
        renderUI();
        run();
        setTab('controls');
      } catch(e) { alert('Invalid JSON'); }
    }

    // --- 3D ENGINE ---
    const canvas = document.querySelector('#gl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
    const controls = new OrbitControls(camera, canvas);
    let currentMesh = null;
    const executor = new ProceduralExecutor();

    function setupScene() {
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.position.set(60, 50, 60);
      camera.updateProjectionMatrix();
      controls.enableDamping = true;
      controls.target.set(0, 20, 0);
      scene.background = new THREE.Color(0x111114);
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(50, 100, 50);
      scene.add(dirLight);
      scene.add(new THREE.GridHelper(100, 20, 0x333333, 0x111111));
    }
    
    function run() {
      if (currentMesh) {
        scene.remove(currentMesh);
        currentMesh.traverse(c => {
          if (c.geometry) c.geometry.dispose();
          if (c.material && !Array.isArray(c.material)) c.material.dispose();
        });
      }

      const params = {};
      for (const [k, v] of Object.entries(schema.globalParameters)) params[k] = v.value;

      try {
        currentMesh = executor.execute(schema, params);
        scene.add(currentMesh);
        let count = 0;
        currentMesh.traverse(c => { if (c.isMesh) count++; });
        document.getElementById('stats').innerText = `Meshes: ${count}`;
      } catch (e) {
        console.error(e);
      }
    }

    // INIT
    setupScene();
    renderUI();
    run();

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.onresize = () => {
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }
  </script>
</body>
</html>
