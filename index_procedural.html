<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spellshape - Emergent Narrative UI</title>
  
  <!-- Import Map -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <style>
    :root {
      --bg: #121214;
      --panel: #1c1c21;
      --card: #25252b;
      --border: #333;
      --accent: #646cff;
      --accent-hover: #747bff;
      --text: #ececec;
      --text-dim: #888;
      --var-color: #ff9e64; /* Orange for variables */
    }

    body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', Inter, sans-serif; color: var(--text); }
    .app { display: flex; height: 100vh; width: 100vw; }
    
    /* --- SIDEBAR (The Narrative) --- */
    .sidebar {
      flex: 0 0 420px;
      width: 420px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      box-shadow: 5px 0 20px rgba(0,0,0,0.3);
      z-index: 10;
    }

    .header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
      background: var(--bg);
    }
    .header h1 { margin: 0; font-size: 18px; font-weight: 700; letter-spacing: -0.5px; }
    .header span { font-size: 11px; color: var(--accent); text-transform: uppercase; font-weight: 800; margin-left: 8px; }

    .narrative-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      scrollbar-width: thin;
      scrollbar-color: #444 transparent;
    }

    /* --- ACTION CARDS --- */
    .step-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
      position: relative;
      transition: border-color 0.2s;
    }
    .step-card:hover { border-color: #555; }
    
    /* Connecting line between cards */
    .step-card::after {
      content: ''; position: absolute; left: 20px; bottom: -18px; 
      height: 18px; width: 2px; background: var(--border);
    }
    .step-card:last-child::after { display: none; }

    .step-header { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
    .step-number { 
      background: #333; color: #aaa; font-size: 10px; font-weight: bold; 
      width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; 
      border-radius: 50%;
    }
    .step-title { font-size: 13px; font-weight: 600; line-height: 1.4; color: #fff; }
    
    .step-logic {
      font-family: monospace; font-size: 11px; color: var(--text-dim);
      background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px;
      margin-bottom: 12px; white-space: pre-wrap; word-break: break-all;
    }

    /* --- PARAMETER CONTROLS INSIDE CARDS --- */
    .param-control {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.05);
    }
    
    .param-header { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 6px; }
    .param-name { color: var(--var-color); font-weight: 600; }
    .param-val { color: #ccc; font-family: monospace; }

    input[type=range] {
      width: 100%; -webkit-appearance: none; background: transparent;
    }
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%; height: 4px; background: #444; border-radius: 2px;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
      background: var(--accent); margin-top: -5px; cursor: pointer; box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }

    /* --- 3D VIEWPORT --- */
    .viewport { flex: 1; position: relative; background: radial-gradient(circle at center, #2a2a30 0%, #111 100%); }
    canvas { display: block; width: 100%; height: 100%; }
    
    .overlay-stats {
      position: absolute; bottom: 20px; right: 20px; 
      background: rgba(0,0,0,0.6); padding: 10px; border-radius: 6px;
      font-family: monospace; font-size: 11px; color: #888; pointer-events: none;
    }

  </style>
</head>
<body>

  <div class="app">
    <!-- Left Panel: The Narrative -->
    <div class="sidebar">
      <div class="header">
        <h1>Spellshape <span>Emergent UI</span></h1>
      </div>
      <div class="narrative-container" id="narrative">
        <!-- Cards injected via JS -->
      </div>
    </div>

    <!-- Right Panel: 3D -->
    <div class="viewport">
      <canvas id="gl"></canvas>
      <div class="overlay-stats" id="stats">Geometry: 0 | Render: 0ms</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    // Make sure this path points to your V2 executor file
    import { ProceduralExecutor } from './src/modules/interpreter/procedural-executor.js';

    // --- THE SCHEMA (v4.5) ---
    const schema = {
  "version": "4.5",
  "type": "emergent_procedure",
  "intent": "Complete Checkerboard Tower",
  "materials": {
    "wall": { "color": "#1a3a5c", "roughness": 0.7, "metalness": 0.1 },
    "window": { "color": "#b3d9ff", "roughness": 0.1, "metalness": 0.8, "transparent": true, "opacity": 0.6 },
    "core": { "color": "#c1440e", "roughness": 0.6, "metalness": 0 },
    "column": { "color": "#2a2a2a", "roughness": 0.8, "metalness": 0.3 },
    "floor_slab": { "color": "#b8b8b8", "roughness": 0.7, "metalness": 0.1 }
  },
  "globalParameters": {
    "floors": { "value": 15, "type": "integer", "min": 3, "max": 30 },
    "floorHeight": { "value": 3.5, "type": "number", "min": 2, "max": 5 },
    "coreWidth": { "value": 8, "type": "number", "min": 4, "max": 16 },
    "coreDepth": { "value": 8, "type": "number", "min": 4, "max": 12 },
    "slabExpansion": { "value": 2, "type": "number", "min": 0, "max": 4 },
    "rotationPerFloor": { "value": 0.08, "type": "number", "min": 0, "max": 0.2 },
    "panelsPerSide": { "value": 6, "type": "integer", "min": 2, "max": 12 }
  },
  "context": {  },
  "actions": [
    // --- 1. CREATE PARTS (Hidden, no material) ---
    { "thought": "1. Create Slab Base", "do": "createBox", "params": { "width": "ctx.coreWidth + ctx.slabExpansion", "height": 0.3, "depth": "ctx.coreDepth + ctx.slabExpansion" }, "transform": { "position": [0, -0.15, 0] }, "as": "slab_mesh" },
    { "thought": "2. Create Core", "do": "createBox", "params": { "width": "ctx.coreWidth", "height": "ctx.floorHeight", "depth": "ctx.coreDepth" }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "core_mesh" },
    { "thought": "3. Create Columns", "do": "createCylinder", "params": { "radiusTop": 0.4, "radiusBottom": 0.4, "height": "ctx.floorHeight" }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "col_base" },
    { "thought": "4. Distribute Columns", "do": "distributeOnGrid3d", "params": { "geometry": "col_base", "rows": 2, "cols": 2, "spacing": ["ctx.coreWidth + 1", 0, "ctx.coreDepth + 1"], "centered": true, "autoMerge": true }, "as": "cols_mesh" },
    
    // --- 5. FACADE PANELS ---
    { "thought": "5. Create Facade Panels", "do": "createBox", "params": { "width": "(ctx.coreWidth + ctx.slabExpansion) / ctx.panelsPerSide - 0.1", "height": "ctx.floorHeight", "depth": 0.2 }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "panel_horz" },
    { "do": "createBox", "params": { "width": 0.2, "height": "ctx.floorHeight", "depth": "(ctx.coreDepth + ctx.slabExpansion) / ctx.panelsPerSide - 0.1" }, "transform": { "position": [0, "ctx.floorHeight/2", 0] }, "as": "panel_vert" },

    // --- 6. ASSEMBLE PATTERNS (Even/Odd groups) ---
    { "thought": "6. Assemble Front Patterns", "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreWidth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["-((ctx.coreWidth + ctx.slabExpansion)/ctx.panelsPerSide)/2", 0, "(ctx.coreDepth + ctx.slabExpansion)/2 - 0.1"] }, "as": "front_even" },
    { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreWidth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["((ctx.coreWidth + ctx.slabExpansion)/ctx.panelsPerSide)/2", 0, "(ctx.coreDepth + ctx.slabExpansion)/2 - 0.1"] }, "as": "front_odd" },
    
    // Back Patterns
    { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreWidth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["-((ctx.coreWidth + ctx.slabExpansion)/ctx.panelsPerSide)/2", 0, "-(ctx.coreDepth + ctx.slabExpansion)/2 + 0.1"] }, "as": "back_even" },
    { "do": "repeatLinear3d", "params": { "geometry": "panel_horz", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreWidth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "x", "centered": true }, "transform": { "position": ["((ctx.coreWidth + ctx.slabExpansion)/ctx.panelsPerSide)/2", 0, "-(ctx.coreDepth + ctx.slabExpansion)/2 + 0.1"] }, "as": "back_odd" },

    // Side Patterns
    { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreDepth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["-(ctx.coreWidth + ctx.slabExpansion)/2 + 0.1", 0, "-((ctx.coreDepth + ctx.slabExpansion)/ctx.panelsPerSide)/2"] }, "as": "left_even" },
    { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreDepth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["-(ctx.coreWidth + ctx.slabExpansion)/2 + 0.1", 0, "((ctx.coreDepth + ctx.slabExpansion)/ctx.panelsPerSide)/2"] }, "as": "left_odd" },
    { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreDepth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["(ctx.coreWidth + ctx.slabExpansion)/2 - 0.1", 0, "-((ctx.coreDepth + ctx.slabExpansion)/ctx.panelsPerSide)/2"] }, "as": "right_even" },
    { "do": "repeatLinear3d", "params": { "geometry": "panel_vert", "count": "ctx.panelsPerSide / 2", "spacing": "((ctx.coreDepth + ctx.slabExpansion) / ctx.panelsPerSide) * 2", "axis": "z", "centered": true }, "transform": { "position": ["(ctx.coreWidth + ctx.slabExpansion)/2 - 0.1", 0, "((ctx.coreDepth + ctx.slabExpansion)/ctx.panelsPerSide)/2"] }, "as": "right_odd" },

    // --- 7. RENDER LOOP (Must include "material" to be visible!) ---
    { 
      "thought": "7. Stack Floors with Twist", 
      "do": "loop", 
      "var": "i", 
      "from": 0, 
      "to": "ctx.floors",
      "body": [
         // STRUCTURE
         { "do": "clone", "params": {"id":"slab_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "floor_slab" },
         { "do": "clone", "params": {"id":"core_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "core" },
         { "do": "clone", "params": {"id":"cols_mesh"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "column" },
         
         // FRONT FACADE (Logic: i%2)
         { "do": "clone", "params": {"id":"front_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
         { "do": "clone", "params": {"id":"front_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
         
         // BACK FACADE
         { "do": "clone", "params": {"id":"back_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
         { "do": "clone", "params": {"id":"back_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },

         // SIDE FACADES
         { "do": "clone", "params": {"id":"left_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
         { "do": "clone", "params": {"id":"left_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" },
         { "do": "clone", "params": {"id":"right_even"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'window' : 'wall'" },
         { "do": "clone", "params": {"id":"right_odd"}, "transform": {"rotation": [0, "i * ctx.rotationPerFloor", 0], "position": [0, "i * ctx.floorHeight", 0]}, "material": "(i % 2 === 0) ? 'wall' : 'window'" }
      ] 
    }
  ]
};

    // Note: I shortened the schema actions above for brevity in the HTML example, 
    // but the logic below works for the full schema you have.

    // ========================================================================
    // 1. UI GENERATION LOGIC
    // ========================================================================

    const container = document.getElementById('narrative');
    
    // Regex to find variables like "ctx.floors" or "ctx.width" in strings
    const varRegex = /ctx\.([a-zA-Z0-9_]+)/g;

    function extractDependencies(obj) {
      const vars = new Set();
      const str = JSON.stringify(obj);
      let match;
      while ((match = varRegex.exec(str)) !== null) {
        vars.add(match[1]);
      }
      return Array.from(vars);
    }

    function renderUI() {
      container.innerHTML = '';
      
      // We keep track of which parameters we have already rendered to avoid duplicates? 
      // Actually, user requested "proper parameters for every thought step". 
      // So duplicates are GOOD if they are relevant to the step context.

      schema.actions.forEach((action, index) => {
        // Skip actions without thoughts (internal steps) if desired, 
        // but here we show them if they are significant.
        const title = action.thought || `Action ${index + 1}: ${action.do}`;
        
        const card = document.createElement('div');
        card.className = 'step-card';
        
        // Header
        const header = document.createElement('div');
        header.className = 'step-header';
        header.innerHTML = `<div class="step-number">${index + 1}</div><div class="step-title">${title}</div>`;
        card.appendChild(header);

        // Logic Preview (Optional: Show the simplified params)
        // const logic = document.createElement('div');
        // logic.className = 'step-logic';
        // logic.innerText = JSON.stringify(action.params || {}, null, 2).replace(/["{}]/g, '').trim();
        // card.appendChild(logic);

        // Find Variables used in this step
        const dependencies = extractDependencies(action);
        
        if (dependencies.length > 0) {
          dependencies.forEach(paramKey => {
            const paramDef = schema.globalParameters[paramKey];
            if (paramDef) {
              const control = createControl(paramKey, paramDef);
              card.appendChild(control);
            }
          });
        } else {
          // If no variables, maybe just static text
          // card.style.opacity = "0.7"; 
        }

        container.appendChild(card);
      });
    }

    function createControl(key, def) {
      const wrapper = document.createElement('div');
      wrapper.className = 'param-control';

      const header = document.createElement('div');
      header.className = 'param-header';
      header.innerHTML = `<span class="param-name">${key}</span><span class="param-val" id="disp-${key}">${def.value}</span>`;

      const input = document.createElement('input');
      input.type = 'range';
      input.min = def.min;
      input.max = def.max;
      input.step = def.step || (def.type === 'integer' ? 1 : 0.01);
      input.value = def.value;

      input.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        def.value = val; // Update source of truth
        
        // Update all displays of this variable (since it might appear in multiple cards)
        document.querySelectorAll(`#disp-${key}`).forEach(el => el.innerText = val);
        
        // Update all other sliders of this variable
        document.querySelectorAll(`input[data-key="${key}"]`).forEach(el => el.value = val);
        
        run();
      });
      
      // Tag input to sync them
      input.setAttribute('data-key', key);

      wrapper.appendChild(header);
      wrapper.appendChild(input);
      return wrapper;
    }

    // ========================================================================
    // 2. THREE.JS RUNTIME
    // ========================================================================
    
    const canvas = document.querySelector('#gl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(60, 50, 60);
    
    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.target.set(0, 20, 0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(50, 100, 50);
    scene.add(dirLight);
    scene.add(new THREE.GridHelper(100, 20, 0x333333, 0x111111));

    const executor = new ProceduralExecutor();
    let currentMesh = null;

    function run() {
      const start = performance.now();
      
      if (currentMesh) {
        scene.remove(currentMesh);
        currentMesh.traverse(c => {
          if (c.geometry) c.geometry.dispose();
          if (c.material) c.material.dispose();
        });
      }

      // Extract current values
      const params = {};
      for (const [k, v] of Object.entries(schema.globalParameters)) {
        params[k] = v.value;
      }

      try {
        console.log(schema)
        currentMesh = executor.execute(schema, params);
        scene.add(currentMesh);
        
        const time = (performance.now() - start).toFixed(2);
        let count = 0;
        currentMesh.traverse(c => { if (c.isMesh) count++; });
        document.getElementById('stats').innerText = `Geometry: ${count} meshes | Render: ${time}ms`;
        
      } catch (e) {
        console.error(e);
      }
    }

    // ========================================================================
    // INIT
    // ========================================================================
    
    renderUI(); // Build the cards
    run();      // Initial render

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.onresize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

  </script>
</body>
</html>
