[
  {
    "id": "noise",
    "name": "noise",
    "description": "Creates natural-looking randomness that varies smoothly across space. Imagine clouds or mountains\u2014this generates texture with that organic, flowing quality. Built on Perlin's work (1985), which revolutionized procedural generation by making randomness coherent (neighboring values are related, not completely random). Think of it as a wavy landscape where the terrain changes gradually rather than jaggily.",
    "category": "Deformation",
    "paramsSchema": {},
    "code": "simplex3,\n    seed: (s) => {\n        for(let i=0; i<256; i++) _p[i] = Math.floor((Math.sin(s + i) * 43758.5453) % 1 * 256);\n        for(let i=0; i<512; i++) {\n            _perm[i] = _p[i & 255];\n            _permMod12[i] = _perm[i] % 12;\n        }\n    }",
    "outputType": "Data"
  },
  {
    "id": "createBox",
    "name": "createBox",
    "description": "Creates a simple cubic shape you can stretch into a rectangular box. The 'segments' parameter adds internal grid lines that let you deform the box later\u2014more segments = smoother deformations. Think of it like the skeleton structure of a box that you can twist, bend, or sculpt.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "width": {
        "type": "number",
        "default": 1
      },
      "height": {
        "type": "number",
        "default": 1
      },
      "depth": {
        "type": "number",
        "default": 1
      },
      "widthSegments": {
        "type": "number",
        "default": 1
      },
      "heightSegments": {
        "type": "number",
        "default": 1
      },
      "depthSegments": {
        "type": "number",
        "default": 1
      }
    },
    "code": "const { width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 } = params;\n    return new THREE.BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);",
    "outputType": "Geometry"
  },
  {
    "id": "createSphere",
    "name": "createSphere",
    "description": "Generates a perfect sphere built like Earth: latitude and longitude lines create the grid. You can slice off parts to make domes or hemispheres. More segments = smoother, more round-looking sphere. It's the go-to primitive for anything ball-shaped or spherical.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "widthSegments": {
        "type": "number",
        "default": 32
      },
      "heightSegments": {
        "type": "number",
        "default": 16
      },
      "phiStart": {
        "type": "number",
        "default": 0
      },
      "phiLength": {
        "type": "string",
        "default": "Math.PI * 2"
      },
      "thetaStart": {
        "type": "number",
        "default": 0
      },
      "thetaLength": {
        "type": "string",
        "default": "Math.PI"
      },
      "PI": {
        "type": "string",
        "default": "",
        "description": "Reference to PI variable"
      }
    },
    "code": "const { radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI } = params;\n    return new THREE.SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);",
    "outputType": "Geometry"
  },
  {
    "id": "createCylinder",
    "name": "createCylinder",
    "description": "Creates a tube or cone shape. The top and bottom can have different sizes\u2014make them equal for a cylinder, or set bottom to 0 for a cone. Height segments let you deform it later. Open-ended option creates a hollow pipe. Great for pillars, pipes, and tapered structures.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radiusTop": {
        "type": "number",
        "default": 1
      },
      "radiusBottom": {
        "type": "number",
        "default": 1
      },
      "height": {
        "type": "number",
        "default": 1
      },
      "radialSegments": {
        "type": "number",
        "default": 32
      },
      "heightSegments": {
        "type": "number",
        "default": 1
      },
      "openEnded": {
        "type": "boolean",
        "default": false
      },
      "thetaStart": {
        "type": "number",
        "default": 0
      },
      "thetaLength": {
        "type": "string",
        "default": "Math.PI * 2"
      },
      "false": {
        "type": "string",
        "default": "",
        "description": "Reference to false variable"
      }
    },
    "code": "const { radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 } = params;\n    return new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);",
    "outputType": "Geometry"
  },
  {
    "id": "createCone",
    "name": "createCone",
    "description": "A shortcut for creating a cone: just a cylinder that tapers to a point. Set the height for how tall, radius for base width. Essential for pyramidal structures, roof forms, and focal point geometries in architecture.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "height": {
        "type": "number",
        "default": 1
      },
      "radialSegments": {
        "type": "number",
        "default": 32
      },
      "heightSegments": {
        "type": "number",
        "default": 1
      },
      "openEnded": {
        "type": "boolean",
        "default": false
      },
      "false": {
        "type": "string",
        "default": "",
        "description": "Reference to false variable"
      }
    },
    "code": "const { radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false } = params;\n    return new THREE.ConeGeometry(radius, height, radialSegments, heightSegments, openEnded);",
    "outputType": "Geometry"
  },
  {
    "id": "createTorus",
    "name": "createTorus",
    "description": "Creates a donut shape by wrapping a tube around a circle. The major radius is the donut's overall size, the tube radius is the thickness of the ring. You can even create partial donuts. Useful for studying toroidal surfaces and complex topological forms.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "tube": {
        "type": "number",
        "default": 0.4
      },
      "radialSegments": {
        "type": "number",
        "default": 16
      },
      "tubularSegments": {
        "type": "number",
        "default": 100
      },
      "arc": {
        "type": "string",
        "default": "Math.PI * 2"
      }
    },
    "code": "const { radius = 1, tube = 0.4, radialSegments = 16, tubularSegments = 100, arc = Math.PI * 2 } = params;\n    return new THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc);",
    "outputType": "Geometry"
  },
  {
    "id": "createTorusKnot",
    "name": "createTorusKnot",
    "description": "Creates a 3D knot that weaves around itself like rope. The p and q parameters control the knot type (p=2, q=3 creates a trefoil/cloverleaf). Mathematically beautiful and used for studying complex curves and topological transformation.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "tube": {
        "type": "number",
        "default": 0.4
      },
      "tubularSegments": {
        "type": "number",
        "default": 64
      },
      "radialSegments": {
        "type": "number",
        "default": 8
      },
      "p": {
        "type": "number",
        "default": 2
      },
      "q": {
        "type": "number",
        "default": 3
      }
    },
    "code": "const { radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 } = params;\n    return new THREE.TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q);",
    "outputType": "Geometry"
  },
  {
    "id": "createPlane",
    "name": "createPlane",
    "description": "A flat rectangular surface. Think of it as a single sheet of paper you can later deform, cut, or subdivide. The segments create a grid of subdivisions\u2014more segments = finer control for warping the plane.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "width": {
        "type": "number",
        "default": 1
      },
      "height": {
        "type": "number",
        "default": 1
      },
      "widthSegments": {
        "type": "number",
        "default": 1
      },
      "heightSegments": {
        "type": "number",
        "default": 1
      }
    },
    "code": "const { width = 1, height = 1, widthSegments = 1, heightSegments = 1 } = params;\n    return new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);",
    "outputType": "Geometry"
  },
  {
    "id": "createCircle",
    "name": "createCircle",
    "description": "A flat circular disk. Can be whole or partial (wedges). Used as profiles for extrusion operations or as simple 2D shapes. More segments = smoother circle appearance.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "segments": {
        "type": "number",
        "default": 32
      },
      "thetaStart": {
        "type": "number",
        "default": 0
      },
      "thetaLength": {
        "type": "string",
        "default": "Math.PI * 2"
      }
    },
    "code": "const { radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 } = params;\n    return new THREE.CircleGeometry(radius, segments, thetaStart, thetaLength);",
    "outputType": "Geometry"
  },
  {
    "id": "createRing",
    "name": "createRing",
    "description": "An annular (ring-shaped) 2D surface. Like a washer or halo\u2014you set inner and outer radius. Can be partial wedges. Used for creating circular patterns and cross-sections in complex geometries.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "innerRadius": {
        "type": "number",
        "default": 0.5
      },
      "outerRadius": {
        "type": "number",
        "default": 1
      },
      "thetaSegments": {
        "type": "number",
        "default": 32
      },
      "phiSegments": {
        "type": "number",
        "default": 1
      },
      "thetaStart": {
        "type": "number",
        "default": 0
      },
      "thetaLength": {
        "type": "string",
        "default": "Math.PI * 2"
      }
    },
    "code": "const { innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 } = params;\n    return new THREE.RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength);",
    "outputType": "Geometry"
  },
  {
    "id": "createIcosahedron",
    "name": "createIcosahedron",
    "description": "Builds a perfect 20-sided die shape. When subdivided, it approximates a sphere evenly. Used as foundation for geodesic domes and uniform point distributions across a sphere. Beautiful pure geometry.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "detail": {
        "type": "number",
        "default": 0
      }
    },
    "code": "const { radius = 1, detail = 0 } = params;\n    return new THREE.IcosahedronGeometry(radius, detail);",
    "outputType": "Geometry"
  },
  {
    "id": "createOctahedron",
    "name": "createOctahedron",
    "description": "An 8-faced diamond shape. More compact than icosahedron, used for directional studies and symmetric parametric forms. Great for space frame structures.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "detail": {
        "type": "number",
        "default": 0
      }
    },
    "code": "const { radius = 1, detail = 0 } = params;\n    return new THREE.OctahedronGeometry(radius, detail);",
    "outputType": "Geometry"
  },
  {
    "id": "createTetrahedron",
    "name": "createTetrahedron",
    "description": "The simplest polyhedron: just 4 triangular faces. Appears in crystal structures, atomic bonding, and tetrahedral space-filling patterns. Fundamental in structural geometry.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "detail": {
        "type": "number",
        "default": 0
      }
    },
    "code": "const { radius = 1, detail = 0 } = params;\n    return new THREE.TetrahedronGeometry(radius, detail);",
    "outputType": "Geometry"
  },
  {
    "id": "createDodecahedron",
    "name": "createDodecahedron",
    "description": "A 12-faced shape with pentagonal faces. Represents high-order symmetry. Used in advanced geometric studies, ornamental design, and exploring Platonic solid relationships.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "detail": {
        "type": "number",
        "default": 0
      }
    },
    "code": "const { radius = 1, detail = 0 } = params;\n    return new THREE.DodecahedronGeometry(radius, detail);",
    "outputType": "Geometry"
  },
  {
    "id": "createPolyhedron",
    "name": "createPolyhedron",
    "description": "The customizable polyhedron builder. Provide vertex positions and face connectivity, get any custom topology. Foundation for algorithm-driven mesh generation and designer-defined geometries.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "detail": {
        "type": "number",
        "default": 0
      },
      "indices": {
        "type": "string",
        "default": "",
        "description": "Reference to indices variable"
      },
      "vertices": {
        "type": "string",
        "default": "",
        "description": "Reference to vertices variable"
      }
    },
    "code": "const { vertices, indices, radius = 1, detail = 0 } = params;\n    return new THREE.PolyhedronGeometry(vertices, indices, radius, detail);",
    "outputType": "Geometry"
  },
  {
    "id": "createExtrude",
    "name": "createExtrude",
    "description": "Takes a 2D shape and stretches it into 3D like pushing a cookie through a mold. You can add beveled edges (rounded/chamfered corners) which came from traditional manufacturing\u2014bevels are easier to manufacture and more durable than sharp edges. The extrusion depth controls how far it stretches. Fundamental operation in parametric design.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "depth": {
        "type": "number",
        "default": 1
      },
      "bevelEnabled": {
        "type": "boolean",
        "default": false
      },
      "bevelThickness": {
        "type": "number",
        "default": 0.2
      },
      "bevelSize": {
        "type": "number",
        "default": 0.1
      },
      "bevelSegments": {
        "type": "number",
        "default": 3
      },
      "steps": {
        "type": "number",
        "default": 1
      },
      "curveSegments": {
        "type": "number",
        "default": 12
      },
      "profile": {
        "type": "string",
        "default": "",
        "description": "2D Shape/Profile variable"
      },
      "false": {
        "type": "string",
        "default": "",
        "description": "Reference to false variable"
      }
    },
    "code": "const { profile, depth = 1, bevelEnabled = false, bevelThickness = 0.2, bevelSize = 0.1, bevelSegments = 3, steps = 1, curveSegments = 12 } = params;\n\n    if (!profile) {\n        console.warn('createExtrude: No profile provided');\n        return new THREE.BoxGeometry(1, 1, 1);\n    }\n\n    let shape;\n    if (profile instanceof THREE.Shape) {\n        shape = profile;\n    } else if (Array.isArray(profile)) {\n        shape = new THREE.Shape(profile.map(([x, y]) => new THREE.Vector2(x, y)));\n    } else {\n        console.warn('createExtrude: Invalid profile format');\n        return new THREE.BoxGeometry(1, 1, 1);\n    }\n\n    const extrudeSettings = { depth, bevelEnabled, bevelThickness, bevelSize, bevelSegments, steps, curveSegments };\n    return new THREE.ExtrudeGeometry(shape, extrudeSettings);",
    "outputType": "Geometry"
  },
  {
    "id": "createLoft",
    "name": "createLoft",
    "description": "Creates a smooth surface by blending between multiple cross-section shapes. Like stacking different-sized rings vertically and stretching a rubber sheet over them\u2014you get a smooth transition. Essential for boat hulls, airplane fuselages, or any form that gradually morphs between profiles.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "profiles": {
        "type": "string",
        "default": "",
        "description": "List of profile variables"
      }
    },
    "code": "let { profiles = [], heights = null, segments = 32, closed = false } = params;\n\n  // ========================================================================\n  // STEP 0: AUTO-UNWRAP DATA\n  // ========================================================================\n  if (profiles && profiles.userData && profiles.userData.profiles) {\n      console.log('createLoft: Unwrapping profiles from userData');\n      profiles = profiles.userData.profiles;\n      closed = true; \n  }\n\n  if (!Array.isArray(profiles)) profiles = [profiles];\n\n  // ========================================================================\n  // STEP 1: Sample curves\n  // ========================================================================\n  profiles = profiles.map((profile, idx) => {\n    let unwrappedCurve = profile;\n    if (profile?.userData?.curve) unwrappedCurve = profile.userData.curve;\n    if (unwrappedCurve && typeof unwrappedCurve.getPoint === 'function') {\n      const points = [];\n      for (let i = 0; i < segments; i++) {\n        const t = i / (segments - 1);\n        const point = unwrappedCurve.getPoint(t);\n        if (point) points.push([point.x, point.y, point.z]);\n      }\n      return points;\n    }\n    if (Array.isArray(profile)) return profile;\n    return [];\n  });\n\n  profiles = profiles.filter(p => p.length > 0);\n\n  if (profiles.length < 2) {\n    console.error('\u274c createLoft: Need at least 2 profiles');\n    return new THREE.BufferGeometry();\n  }\n\n  // ========================================================================\n  // STEP 3: Resample (Arc-Length)\n  // ========================================================================\n  const resampleProfile = (points, targetCount) => {\n      if (points.length < 2) return points;\n      const dists = [0];\n      let totalLen = 0;\n      for (let i = 0; i < points.length - 1; i++) {\n          const [x1, y1, z1] = points[i];\n          const [x2, y2, z2] = points[i+1];\n          const d = Math.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2);\n          totalLen += d;\n          dists.push(totalLen);\n      }\n\n      const result = [];\n      result.push(points[0]);\n      for (let i = 1; i < targetCount - 1; i++) {\n          const targetDist = (i / (targetCount - 1)) * totalLen;\n          let idx = 0;\n          while (dists[idx+1] < targetDist && idx < dists.length - 2) idx++;\n          \n          const segmentLen = dists[idx+1] - dists[idx];\n          const t = segmentLen === 0 ? 0 : (targetDist - dists[idx]) / segmentLen;\n          \n          const p1 = points[idx];\n          const p2 = points[idx+1];\n          \n          result.push([\n              p1[0] + (p2[0] - p1[0]) * t,\n              p1[1] + (p2[1] - p1[1]) * t,\n              p1[2] + (p2[2] - p1[2]) * t\n          ]);\n      }\n      result.push(points[points.length - 1]);\n      return result;\n  };\n\n  // Use finalPointCount instead of pointsPerProfile\n  const finalPointCount = Math.max(segments, ...profiles.map(p => p.length));\n  profiles = profiles.map(profile => resampleProfile(profile, finalPointCount));\n\n  // ========================================================================\n  // STEP 4: Create Interpolation Curves\n  // ========================================================================\n  const interpCurves = [];\n  for (let j = 0; j < finalPointCount; j++) { // \u2705 FIX: Used correct variable\n    const columnPoints = profiles.map((profile) => {\n      const [x, y, z] = profile[j];\n      return new THREE.Vector3(x, y, z);\n    });\n\n    if (columnPoints.length >= 2) {\n      const curve = new THREE.CatmullRomCurve3(columnPoints, false);\n      interpCurves.push(curve);\n    }\n  }\n\n  // ========================================================================\n  // STEP 5: Build Mesh\n  // ========================================================================\n  const vertices = []; // \u2705 FIX: Defined arrays\n  const indices = [];\n  const samplesPerCurve = Math.max(16, profiles.length * 2); \n  \n  for (let j = 0; j < interpCurves.length; j++) {\n    for (let k = 0; k < samplesPerCurve; k++) {\n      const t = k / (samplesPerCurve - 1);\n      const point = interpCurves[j].getPoint(t);\n      vertices.push(point.x, point.y, point.z);\n    }\n  }\n\n  // Create faces\n  for (let j = 0; j < interpCurves.length - 1; j++) {\n    for (let k = 0; k < samplesPerCurve - 1; k++) {\n      const a = j * samplesPerCurve + k;\n      const b = j * samplesPerCurve + k + 1;\n      const c = (j + 1) * samplesPerCurve + k + 1;\n      const d = (j + 1) * samplesPerCurve + k;\n      indices.push(a, b, d);\n      indices.push(b, c, d);\n    }\n  }\n\n  // Close loop\n  if (closed && interpCurves.length > 1) {\n    const lastIdx = interpCurves.length - 1;\n    for (let k = 0; k < samplesPerCurve - 1; k++) {\n      const a = lastIdx * samplesPerCurve + k;\n      const b = lastIdx * samplesPerCurve + k + 1;\n      const c = k + 1;\n      const d = k;\n      indices.push(a, b, d);\n      indices.push(b, c, d);\n    }\n  }\n\n  // ========================================================================\n  // STEP 6: Create Geometry\n  // ========================================================================\n  const geometry = new THREE.BufferGeometry();\n  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n  geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n  geometry.computeVertexNormals();\n\n  console.log('\u2705 createLoft success:', {\n    profileCount: profiles.length,\n    vertexCount: vertices.length / 3\n  });\n\n  return geometry;",
    "outputType": "Geometry"
  },
  {
    "id": "createLathe",
    "name": "createLathe",
    "description": "Imagine taking a 2D outline and spinning it around an axis like a pottery wheel. This creates any shape with rotational symmetry: bottles, vases, candle holders, architectural domes. The profile is the outline you draw (e.g., the edge of a wine glass), and lathe rotates it to make the 3D form.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "points": {
        "type": "string",
        "default": "",
        "description": "List of points or variable name"
      }
    },
    "code": "let { points = [], segments = 12, phiStart = 0, phiLength = Math.PI * 2 } = params;\n\n    // \u2705 RESOLVER: Handles array, curve, or wrapped object\n    const resolvedPoints2D = resolvePoints2D(points, segments);\n\n    if (resolvedPoints2D.length === 0) {\n        console.warn('createLathe: No valid points resolved');\n        return new THREE.BufferGeometry();\n    }\n\n    // Convert to THREE.Vector2 if needed\n    const lathePoints = resolvedPoints2D.map(p => \n        p instanceof THREE.Vector2 ? p : new THREE.Vector2(p.x || p[0], p.y || p[1])\n    );\n\n    try {\n        return new THREE.LatheGeometry(lathePoints, segments, phiStart, phiLength);\n    } catch (e) {\n        console.error('LatheGeometry creation failed:', e);\n        return new THREE.BufferGeometry();",
    "outputType": "Geometry"
  },
  {
    "id": "createConvexHull",
    "name": "createConvexHull",
    "description": "Finds the smallest 'rubber band' shape that wraps around a cloud of points. If you imagine stretching a rubber sheet around scattered stones, the hull is what you see on the surface. Useful for bounding geometry, simplifying complex point clouds, and collision detection.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "points": {
        "type": "string",
        "default": "",
        "description": "List of points or variable name"
      }
    },
    "code": "const { points } = params; if (!points || points.length < 4) return new THREE.BufferGeometry(); const vectors = points.map(p => Array.isArray(p) ? new THREE.Vector3(...p) : p); return new ConvexGeometry(vectors);",
    "outputType": "Geometry"
  },
  {
    "id": "createParametricSurface",
    "name": "createParametricSurface",
    "description": "Creates surfaces from mathematical formulas. You provide a function that takes two input values (u, v) and outputs a 3D point. By sampling a grid of (u, v) values, you get a surface. This is how you'd build: wave surfaces, Klein bottles, minimal surfaces like soap films, or any surface you can mathematize.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "slices": {
        "type": "number",
        "default": 32
      },
      "stacks": {
        "type": "number",
        "default": 32
      },
      "func": {
        "type": "string",
        "default": "",
        "description": "Reference to func variable"
      }
    },
    "code": "const { func, slices = 32, stacks = 32 } = params;\n    return new ParametricGeometry(func, slices, stacks);",
    "outputType": "Geometry"
  },
  {
  "id": "createText3D",
  "name": "createText3D",
  "description": "Creates 3D text geometry. The 'height' parameter controls extrusion depth. Uses a pre-loaded default font if none is provided.",
  "category": "Basic Geometry",
  "paramsSchema": {
    "text": { "type": "string", "description": "Text to render", "default": "Hello" },
    "font": { "type": "object", "description": "THREE.Font object (optional)", "default": null },
    "size": { "type": "number", "description": "Letter height / font size", "default": 1 },
    "height": { "type": "number", "description": "Extrusion depth of the text", "default": 0.2 },
    "curveSegments": { "type": "number", "description": "Curve smoothness", "default": 12 },
    "bevelEnabled": { "type": "boolean", "description": "Enable rounded edges", "default": true },
    "bevelThickness": { "type": "number", "description": "How deep the bevel goes", "default": 0.02 },
    "bevelSize": { "type": "number", "description": "How far from the outline the bevel extends", "default": 0.01 },
    "bevelSegments": { "type": "number", "description": "Bevel smoothness", "default": 3 }
  },
  "code": "const DEFAULT_FONT_URL = 'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json';\nconst { text, font, size, height, curveSegments, bevelEnabled, bevelThickness, bevelSize, bevelSegments } = params;\n\nif (!text) return new THREE.BoxGeometry(0,0,0);\n\nlet fontToUse = font;\nif (!fontToUse) {\n    if (loadedFonts && loadedFonts.has(DEFAULT_FONT_URL)) {\n        fontToUse = loadedFonts.get(DEFAULT_FONT_URL);\n    } else {\n        console.error('❌ Default font not available. Cannot create text.');\n        return new THREE.BoxGeometry(1, 1, 0.2);\n    }\n}\n\nif (!fontToUse.isFont) {\n    console.error('⚠️ createText3D: Provided font object is invalid.');\n    return new THREE.BoxGeometry(1, 1, 0.2);\n}\n\nconst textGeom = new TextGeometry(text, {\n    font: fontToUse,\n    size: size ?? 1,\n    height: height ?? 0.2,\n    curveSegments: curveSegments ?? 12,\n    bevelEnabled: bevelEnabled ?? false,\n    bevelThickness: bevelThickness ?? 0.02,\n    bevelSize: bevelSize ?? 0.01,\n    bevelSegments: bevelSegments ?? 3\n});\n\ntextGeom.center();\n console.log(textGeom);\nreturn textGeom;",
  "outputType": "Geometry"
}
,
  {
    "id": "createLinePath",
    "name": "createLinePath",
    "description": "A straight line between two points in 3D space. Creates a mathematical curve object you can use for other operations like piping or distributing objects along the path.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "points": {
        "type": "string",
        "default": "",
        "description": "List of points or variable name"
      }
    },
    "code": "const { points } = params;\n\n    if (!points || points.length < 2) {\n        console.warn('createLinePath: Need at least 2 points');\n        return new THREE.BufferGeometry();\n    }\n\n    const vectors = points.map(p => Array.isArray(p) ? new THREE.Vector3(...p) : p);\n    const curve = new THREE.LineCurve3(vectors[0], vectors[1]);\n\n    // \u2705 WRAPPED: Return visual with math object attached\n    return wrapCurveAsLine(curve, 32);",
    "outputType": "Data"
  },
  {
    "id": "createSplinePath",
    "name": "createSplinePath",
    "description": "A smooth curve that passes through a series of control points, like a flexible rod bent through dots. Catmull-Rom splines are famous for creating naturally flowing curves without kinks. The tension parameter controls how tightly the curve pulls through the points.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "tension": {
        "type": "number",
        "default": 0.5
      },
      "points": {
        "type": "string",
        "default": "",
        "description": "List of points or variable name"
      }
    },
    "code": "const { points, tension = 0.5 } = params;\n\n    if (!points || points.length < 2) {\n        console.warn('createSplinePath: Need at least 2 points');\n        return new THREE.BufferGeometry();\n    }\n\n    const vectors = points.map(p => Array.isArray(p) ? new THREE.Vector3(...p) : p);\n    const curve = new THREE.CatmullRomCurve3(vectors, false, 'catmullrom', tension);\n\n    // \u2705 WRAPPED: Return visual with math object attached\n    return wrapCurveAsLine(curve, 64);",
    "outputType": "Data"
  },
  {
    "id": "createArcPath",
    "name": "createArcPath",
    "description": "A curved segment of a circle. You specify center, radius, and angle range. Used for circular motion paths and orbital patterns in parametric design.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "center": {
        "type": "array",
        "default": []
      },
      "radius": {
        "type": "number",
        "default": 1
      },
      "startAngle": {
        "type": "number",
        "default": 0
      },
      "endAngle": {
        "type": "string",
        "default": "Math.PI"
      },
      "segments": {
        "type": "number",
        "default": 32
      },
      "PI": {
        "type": "string",
        "default": "",
        "description": "Reference to PI variable"
      }
    },
    "code": "const { center = [0, 0, 0], radius = 1, startAngle = 0, endAngle = Math.PI, segments = 32 } = params;\n    const points = [];\n\n    for (let i = 0; i <= segments; i++) {\n        const theta = startAngle + (endAngle - startAngle) * i / segments;\n        const x = center[0] + radius * Math.cos(theta);\n        const y = center[1] + radius * Math.sin(theta);\n        points.push(new THREE.Vector3(x, y, center[2]));\n    }\n\n    const curve = new THREE.CatmullRomCurve3(points, false);\n\n    // \u2705 WRAPPED: Return visual with math object attached\n    return wrapCurveAsLine(curve, segments);",
    "outputType": "Data"
  },
  {
    "id": "createHelixPath",
    "name": "createHelixPath",
    "description": "A spiral curve coiling around a center line\u2014like a DNA strand or spiral staircase. Defined by how many times it turns (turns parameter) and how tall it extends. Perfect for modeling helical structures and spiraling forms.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 1
      },
      "height": {
        "type": "number",
        "default": 3
      },
      "turns": {
        "type": "number",
        "default": 3
      },
      "segments": {
        "type": "number",
        "default": 128
      }
    },
    "code": "const { radius = 1, height = 3, turns = 3, segments = 128 } = params;\n    const points = [];\n\n    for (let i = 0; i <= segments; i++) {\n        const t = i / segments;\n        const theta = 2 * Math.PI * turns * t;\n        const x = radius * Math.cos(theta);\n        const y = height * t;\n        const z = radius * Math.sin(theta);\n        points.push(new THREE.Vector3(x, y, z));\n    }\n\n    const curve = new THREE.CatmullRomCurve3(points, false);\n\n    // \u2705 WRAPPED: Return visual with math object attached\n    return wrapCurveAsLine(curve, segments);",
    "outputType": "Data"
  },
  {
    "id": "createBezierPath",
    "name": "createBezierPath",
    "description": "A smooth curve defined by 4 control points. Famous curve type that gives designers intuitive control\u2014adjust the handles to shape the curve. Foundation of vector graphics, animation paths, and smooth transitions.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "start": {
        "type": "array",
        "default": [
          0,
          0,
          0
        ],
        "description": "Start point [x, y, z]"
      },
      "control1": {
        "type": "array",
        "default": [
          1,
          1,
          0
        ],
        "description": "First control point [x, y, z]"
      },
      "control2": {
        "type": "array",
        "default": [
          2,
          1,
          0
        ],
        "description": "Second control point [x, y, z]"
      },
      "end": {
        "type": "array",
        "default": [
          3,
          0,
          0
        ],
        "description": "End point [x, y, z]"
      }
    },
    "code": "const { start, control1, control2, end } = params;\n\n    const curve = new THREE.CubicBezierCurve3(\n        new THREE.Vector3(...start),\n        new THREE.Vector3(...control1),\n        new THREE.Vector3(...control2),\n        new THREE.Vector3(...end)\n    );\n\n    // \u2705 WRAPPED: Return visual with math object attached\n    return wrapCurveAsLine(curve, 64);",
    "outputType": "Data"
  },
  {
    "id": "createPipe",
    "name": "createPipe",
    "description": "Wraps a tube (constant radius) around a 3D curve path. Like wrapping rope around a line or creating flexible tubing. Used for cables, pipes, veins, and any structure that follows a path.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "radius": {
        "type": "number",
        "default": 0.2
      },
      "tubularSegments": {
        "type": "number",
        "default": 64
      },
      "radialSegments": {
        "type": "number",
        "default": 8
      },
      "closed": {
        "type": "boolean",
        "default": false
      },
      "path": {
        "type": "string",
        "default": "",
        "description": "Curve/path variable to follow"
      },
      "false": {
        "type": "string",
        "default": "",
        "description": "Reference to false variable"
      }
    },
    "code": "const { path, radius = 0.2, tubularSegments = 64, radialSegments = 8, closed = false } = params;\n\n    // \u2705 RESOLVER: Handle wrapped curves\n    const curve = resolveCurve(path);\n    if (!curve) {\n        console.warn('createPipe: No valid curve');\n        return new THREE.BufferGeometry();\n    }\n\n    return new THREE.TubeGeometry(curve, tubularSegments, radius, radialSegments, closed);",
    "outputType": "Geometry"
  },
  {
    "id": "twistGeometry",
    "name": "twistGeometry",
    "description": "Rotates the geometry like you're wringing out a towel. The twist increases as you go up (or along an axis). The angle parameter controls how much the rotation spirals\u2014more angle = tighter twisting. Used for architectural elements like twisted columns, spiral ramps, or organic ribbed forms.",
    "category": "Deformation",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Geometry variable to process"
      },
      "angle": {
        "type": "string",
        "default": "Math.PI / 4"
      },
      "axis": {
        "type": "array",
        "default": []
      },
      "height": {
        "type": "string",
        "default": "null"
      },
      "null": {
        "type": "string",
        "default": "",
        "description": "Reference to null variable"
      }
    },
    "code": "const { geometry, angle = Math.PI / 4, axis = [0, 1, 0], height = null } = params;\n\n    const geom = geometry.clone();\n    const positions = geom.attributes.position;\n    const count = positions.count;\n\n    geom.computeBoundingBox();\n    const bbox = geom.boundingBox;\n\n    const axisNorm = new THREE.Vector3(...axis).normalize();\n    const isYAxis = Math.abs(axisNorm.y) > 0.99;\n\n    const minH = isYAxis ? bbox.min.y : bbox.min.z;\n    const maxH = isYAxis ? bbox.max.y : bbox.max.z;\n    const range = height || (maxH - minH);\n\n    for (let i = 0; i < count; i++) {\n        const x = positions.getX(i);\n        const y = positions.getY(i);\n        const z = positions.getZ(i);\n        const h = isYAxis ? y : z;\n        const t = (h - minH) / (range || 1);\n        const theta = angle * t;\n\n        if (isYAxis) {\n            const newX = x * Math.cos(theta) - z * Math.sin(theta);\n            const newZ = x * Math.sin(theta) + z * Math.cos(theta);\n            positions.setXYZ(i, newX, y, newZ);\n        } else {\n            const newX = x * Math.cos(theta) - y * Math.sin(theta);\n            const newY = x * Math.sin(theta) + y * Math.cos(theta);\n            positions.setXYZ(i, newX, newY, z);\n        }\n    }\n\n    positions.needsUpdate = true;\n    geom.computeVertexNormals();\n    return geom;",
    "outputType": "Geometry"
  },
  {
    "id": "taperGeometry",
    "name": "taperGeometry",
    "description": "Gradually shrinks the geometry from one end to the other, like a cone. Imagine a pencil that stays thick at the base but narrows to a point. You control how much it shrinks at the top. Great for tapered columns, funnels, or any form that pinches toward one end.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Geometry variable to process"
      },
      "topScale": {
        "type": "array",
        "default": [
          0.1,
          0.1
        ]
      },
      "axis": {
        "type": "array",
        "default": [
          0,
          1,
          0
        ]
      },
      "height": {
        "type": "string",
        "default": "null"
      },
      "null": {
        "type": "string",
        "default": "",
        "description": "Reference to null variable"
      }
    },
    "code": "const { geometry, topScale = [0.5, 0.5], axis = [0, 1, 0], height = null } = params;\n\n    if (!geometry) return new THREE.BufferGeometry();\n\n    // --- 1. INPUT SANITIZATION (Fix String vs Array bugs) ---\n    const parseArray = (val) => {\n        if (Array.isArray(val)) return val;\n        if (typeof val === 'string') {\n            try { return JSON.parse(val); } \n            catch (e) { return val.split(',').map(Number); }\n        }\n        return [1, 1]; // Fallback\n    };\n\n    const scaleArr = parseArray(topScale);\n    const axisArr = parseArray(axis);\n    \n    // Ensure we have 2 values for scale\n    const sX = scaleArr[0] !== undefined ? scaleArr[0] : 1.0;\n    const sZ = scaleArr[1] !== undefined ? scaleArr[1] : sX;\n\n    const geom = geometry.clone();\n    const positions = geom.attributes.position;\n    const count = positions.count;\n\n    geom.computeBoundingBox();\n    const bbox = geom.boundingBox;\n\n    const axisVec = new THREE.Vector3(...axisArr).normalize();\n    const isYAxis = Math.abs(axisVec.y) > 0.99;\n\n    const minH = isYAxis ? bbox.min.y : bbox.min.z;\n    const maxH = isYAxis ? bbox.max.y : bbox.max.z;\n    \n    // Handle override height\n    let range = maxH - minH;\n    if (height !== null && height !== 'null') {\n        range = parseFloat(height);\n    }\n    if (isNaN(range) || range === 0) range = 1.0;\n\n    for (let i = 0; i < count; i++) {\n        const x = positions.getX(i);\n        const y = positions.getY(i);\n        const z = positions.getZ(i);\n        \n        const h = isYAxis ? y : z;\n        const t = (h - minH) / range;\n\n        // Apply Linear Taper\n        const currentScaleX = 1.0 + (sX - 1.0) * t;\n        const currentScaleZ = 1.0 + (sZ - 1.0) * t;\n\n        if (isYAxis) {\n            // Taper X and Z along Y axis\n            positions.setXYZ(i, x * currentScaleX, y, z * currentScaleZ);\n        } else {\n            // Taper X and Y along Z axis\n            positions.setXYZ(i, x * currentScaleX, y * currentScaleZ, z);\n        }\n    }\n\n    positions.needsUpdate = true;\n    geom.computeVertexNormals();\n    return geom;",
    "outputType": "Geometry"
  },
  {
    "id": "bendGeometry",
    "name": "bendGeometry",
    "description": "Curves the geometry like bending a plank of wood. Maps the geometry onto a curved surface, creating realistic bending effects. Used for flexible structural members and curved architectural elements.",
    "category": "Deformation",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Geometry variable to process"
      },
      "angle": {
        "type": "string",
        "default": "Math.PI / 4"
      },
      "direction": {
        "type": "array",
        "default": [
          0,
          1,
          0
        ]
      }
    },
    "code": "const { geometry, angle = Math.PI / 4, direction = [1, 0, 0] } = params;\n\n    const geom = geometry.clone();\n    const positions = geom.attributes.position;\n\n    geom.computeBoundingBox();\n    const bbox = geom.boundingBox;\n    const range = bbox.max.x - bbox.min.x;\n\n    for (let i = 0; i < positions.count; i++) {\n        const x = positions.getX(i);\n        const y = positions.getY(i);\n        const z = positions.getZ(i);\n        const t = (x - bbox.min.x) / range;\n        const theta = angle * t;\n        const radius = range / angle;\n        const newX = Math.sin(theta) * radius;\n        const newZ = z + radius - Math.cos(theta) * radius;\n\n        positions.setXYZ(i, newX, y, newZ);\n    }\n\n    positions.needsUpdate = true;\n    geom.computeVertexNormals();\n    return geom;",
    "outputType": "Geometry"
  },
  {
    "id": "deformByNoise",
    "name": "deformByNoise",
    "description": "Roughens a surface by randomly bumping each point based on noise. Creates natural-looking irregularities like erosion, crumpled fabric, or biological textures. The noise ensures the bumps follow a pattern that looks organic (not random TV static), so neighboring areas bump similarly.",
    "category": "Deformation",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Geometry variable to process"
      },
      "amount": {
        "type": "number",
        "default": 0.2
      },
      "frequency": {
        "type": "number",
        "default": 1.0
      },
      "axis": {
        "type": "array",
        "default": [
          0,
          1,
          0
        ]
      }
    },
    "code": "const { geometry, amount = 0.2, frequency = 1.0, axis = [0, 1, 0] } = params;\n\n    const geom = geometry.clone();\n    const positions = geom.attributes.position;\n    const axisVec = new THREE.Vector3(...axis).normalize();\n\n    for (let i = 0; i < positions.count; i++) {\n        const x = positions.getX(i);\n        const y = positions.getY(i);\n        const z = positions.getZ(i);\n        const noiseVal = noise.simplex3(x * frequency, y * frequency, z * frequency);\n        const offset = axisVec.clone().multiplyScalar(noiseVal * amount);\n\n        positions.setXYZ(i, x + offset.x, y + offset.y, z + offset.z);\n    }\n\n    positions.needsUpdate = true;\n    geom.computeVertexNormals();\n    return geom;",
    "outputType": "Geometry"
  },
  {
    "id": "deformByVectorField",
    "name": "deformByVectorField",
    "description": "Deforms geometry by following an invisible force field. Each point moves in the direction the field points, scaled by how strong it is. Like how wind carries leaves or gravity pulls objects. Used for field-driven morphogenesis and force-based form-finding.",
    "category": "Deformation",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Geometry variable to process"
      },
      "field": {
        "type": "string",
        "default": "",
        "description": "Vector field variable name"
      },
      "amount": {
        "type": "number",
        "default": 1.0
      }
    },
    "code": "const { geometry, field, amount = 1.0 } = params;\n\n    // \u2705 RESOLVER: Handle wrapped fields\n    const fieldFn = resolveField(field);\n\n    const geom = geometry.clone();\n    const positions = geom.attributes.position;\n\n    for (let i = 0; i < positions.count; i++) {\n        const x = positions.getX(i);\n        const y = positions.getY(i);\n        const z = positions.getZ(i);\n        const vec = fieldFn(x, y, z);\n\n        positions.setXYZ(i, x + vec.x * amount, y + vec.y * amount, z + vec.z * amount);\n    }\n\n    positions.needsUpdate = true;\n    geom.computeVertexNormals();\n    return geom;",
    "outputType": "Geometry"
  },
  {
    "id": "mergeGeometries",
    "name": "mergeGeometries",
    "description": "Combines multiple separate shapes into one unified mesh. Useful after array operations to create a final aggregated form. Merging improves rendering performance compared to many separate objects.",
    "category": "Boolean Operations",
    "paramsSchema": {
      "geometries": {
        "type": "string",
        "default": "",
        "description": "List of geometry variables to merge"
      }
    },
    "code": "const { geometries = [] } = params;\n    const validGeoms = geometries.filter(g => g && g.isBufferGeometry);\n\n    if (validGeoms.length === 0) return new THREE.BufferGeometry();\n    return BufferGeometryUtils.mergeGeometries(validGeoms, false);",
    "outputType": "Geometry"
  },
  {
    "id": "unionGeometry",
    "name": "unionGeometry",
    "description": "Boolean operation: combines shapes like gluing them together. Where they overlap, they become one solid. (Note: full implementation requires CSG library)",
    "category": "Boolean Operations",
    "paramsSchema": {},
    "code": "const { geometries } = params; if (!Array.isArray(geometries)) return new THREE.BufferGeometry(); const validGeoms = geometries.filter(g => g && g.isBufferGeometry); if (validGeoms.length === 0) return new THREE.BufferGeometry(); return BufferGeometryUtils.mergeGeometries(validGeoms);",
    "outputType": "Geometry"
  },
  {
    "id": "subtractGeometry",
    "name": "subtractGeometry",
    "description": "Boolean operation: carves away one shape from another. If shape B overlaps shape A, the overlapping part is removed from A. Used for creating holes, chambers, and complex carved forms. (Note: full implementation requires CSG library)",
    "category": "Boolean Operations",
    "paramsSchema": {
      "geometryA": {
        "type": "string",
        "default": "new"
      }
    },
    "code": "console.warn('subtractGeometry: CSG operations require three-csg-ts library');\n    return params.geometryA || new THREE.BufferGeometry();",
    "outputType": "Geometry"
  },
  {
    "id": "intersectGeometry",
    "name": "intersectGeometry",
    "description": "Boolean operation: keeps only where two shapes overlap. Like finding the intersection of two volumes\u2014everything else is discarded. Used for complex spatial logic and constraint-based form design. (Note: full implementation requires CSG library)",
    "category": "Boolean Operations",
    "paramsSchema": {
      "geometryA": {
        "type": "string",
        "default": "new"
      }
    },
    "code": "console.warn('intersectGeometry: CSG operations require three-csg-ts library');\n    return params.geometryA || new THREE.BufferGeometry();",
    "outputType": "Geometry"
  },
  {
    "id": "repeatLinear3d",
    "name": "repeatLinear3d",
    "description": "Makes copies of a shape in a straight line\u2014like fence posts along a road. You choose the direction (X, Y, or Z), how many copies, and the spacing between them. Can be centered around a point for symmetry. Perfect for creating regular structures like columns in a colonnade or modular building facades.",
    "category": "Curves & Paths",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Geometry variable to process"
      },
      "count": {
        "type": "number",
        "default": 3
      },
      "spacing": {
        "type": "number",
        "default": 1
      },
      "axis": {
        "type": "string",
        "default": "x"
      },
      "centered": {
        "type": "boolean",
        "default": false
      },
      "autoMerge": {
        "type": "boolean",
        "default": true
      },
      "false": {
        "type": "string",
        "default": "",
        "description": "Reference to false variable"
      },
      "true": {
        "type": "string",
        "default": "",
        "description": "Reference to true variable"
      }
    },
    "code": "const { geometry, count = 3, spacing = 1, axis = 'x', centered = false, autoMerge = true } = params;\n\n    if (!geometry) return autoMerge ? new THREE.BufferGeometry() : [];\n\n    const results = [];\n    const axisVec = axis === 'y' ? new THREE.Vector3(0, 1, 0) :\n                    (axis === 'z' ? new THREE.Vector3(0, 0, 1) : new THREE.Vector3(1, 0, 0));\n    const offset = centered ? -spacing * (count - 1) / 2 : 0;\n\n    for (let i = 0; i < count; i++) {\n        const clone = geometry.clone();\n        clone.translate(\n            axisVec.x * (offset + i * spacing),\n            axisVec.y * (offset + i * spacing),\n            axisVec.z * (offset + i * spacing)\n        );\n        results.push(clone);\n    }\n\n    return autoMerge ? BufferGeometryUtils.mergeGeometries(results) : results;",
    "outputType": "Geometry"
  },
  {
    "id": "repeatRadial3d",
    "name": "repeatRadial3d",
    "description": "Arranges copies of a shape in a circle around a central axis, like petals on a flower or spokes on a wheel. You control the radius (how far from center), the angle covered, and how many copies. The 'faceCenter' option orients each copy to face outward naturally. Great for radial symmetry and circular patterns.",
    "category": "Distribution",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": ""
      },
      "count": {
        "type": "number",
        "default": 8
      },
      "radius": {
        "type": "number",
        "default": 5
      },
      "startAngle": {
        "type": "number",
        "default": 0
      },
      "endAngle": {
        "type": "string",
        "default": "Math.PI * 2"
      },
      "axis": {
        "type": "string",
        "default": "y"
      },
      "faceCenter": {
        "type": "boolean",
        "default": true
      },
      "autoMerge": {
        "type": "boolean",
        "default": true
      }
    },
    "code": "const { geometry, count = 8, radius = 5, startAngle = 0, endAngle = Math.PI * 2, axis = 'y', faceCenter = true, autoMerge = true } = params;\n\n    if (!geometry) return autoMerge ? new THREE.BufferGeometry() : [];\n\n    // 1. Sanitize Axis Input (removes quotes and forces lowercase)\n    const ax = String(axis).toLowerCase().replace(/['\"]+/g, '').trim();\n\n    const results = [];\n    // Logic: If full circle (360), divide by count. If arc, divide by count-1.\n    const isFullCircle = Math.abs(endAngle - startAngle) >= Math.PI * 2 - 0.001;\n    const divisor = (count > 1 && !isFullCircle) ? (count - 1) : count;\n\n    for (let i = 0; i < count; i++) {\n        const t = count === 1 ? 0 : i / divisor;\n        const angle = startAngle + (endAngle - startAngle) * t;\n        \n        const clone = geometry.clone();\n        const c = Math.cos(angle);\n        const s = Math.sin(angle);\n\n        // 2. Rotate FIRST (Orientation), 3. Translate SECOND (Position)\n        if (ax === 'x') {\n            // YZ Plane\n            if (faceCenter) clone.rotateX(angle);\n            clone.translate(0, radius * c, radius * s);\n        } else if (ax === 'z') {\n            // XY Plane\n            if (faceCenter) clone.rotateZ(angle);\n            clone.translate(radius * c, radius * s, 0);\n        } else {\n            // Y Axis (Default) - XZ Plane\n            // Note: -angle usually works better for Y-up coordinate systems to face center correctly\n            if (faceCenter) clone.rotateY(-angle);\n            clone.translate(radius * c, 0, radius * s);\n        }\n\n        results.push(clone);\n    }\n\n    return autoMerge ? BufferGeometryUtils.mergeGeometries(results) : results;",
    "outputType": "Geometry"
  },
  {
    "id": "repeatAlongCurve3d",
    "name": "repeatAlongCurve3d",
    "description": "Distributes copies of a shape at intervals along a 3D path or curve. Each copy can optionally align tangent to the curve (facing the direction the curve travels). Like placing trees along a winding road or fence posts following terrain.",
    "category": "Curves & Paths",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Geometry variable to process"
      },
      "curve": {
        "type": "string",
        "default": "",
        "description": "Curve variable to follow"
      },
      "count": {
        "type": "number",
        "default": 10
      },
      "align": {
        "type": "boolean",
        "default": true
      },
      "autoMerge": {
        "type": "boolean",
        "default": true
      },
      "true": {
        "type": "string",
        "default": "",
        "description": "Reference to true variable"
      }
    },
    "code": "const { geometry, curve, count = 10, align = true, autoMerge = true } = params;\n\n    if (!geometry) return autoMerge ? new THREE.BufferGeometry() : [];\n\n    // \u2705 RESOLVER: Unwraps wrapped curves automatically\n    const resolvedCurve = resolveCurve(curve);\n    if (!resolvedCurve) {\n        console.warn('repeatAlongCurve3d: No valid curve');\n        return autoMerge ? new THREE.BufferGeometry() : [];\n    }\n\n    const results = [];\n    for (let i = 0; i < count; i++) {\n        const t = count === 1 ? 0.5 : i / (count - 1);\n        const pos = resolvedCurve.getPoint(t);\n        const clone = geometry.clone();\n        clone.translate(pos.x, pos.y, pos.z);\n\n        if (align) {\n            const tangent = resolvedCurve.getTangent(t).normalize();\n            const up = new THREE.Vector3(0, 1, 0);\n            const normal = new THREE.Vector3().crossVectors(tangent, up).normalize();\n            const orthogonalUp = new THREE.Vector3().crossVectors(normal, tangent).normalize();\n            const rotMatrix = new THREE.Matrix4().makeBasis(tangent, orthogonalUp, normal);\n            clone.applyMatrix4(rotMatrix);\n        }\n\n        results.push(clone);\n    }\n\n    return autoMerge ? BufferGeometryUtils.mergeGeometries(results) : results;",
    "outputType": "Geometry"
  },
  {
  "id": "distributeOnGrid3d",
  "name": "distributeOnGrid3d",
  "description": "Generates a grid of points OR clones an input geometry onto a grid.",
  "category": "Distribution",
  "paramsSchema": {
    "geometry": { "type": "string", "default": "", "description": "Optional geometry to clone" },
    "x": { "type": "number", "default": 3, "description": "Count X" },
    "y": { "type": "number", "default": 1, "description": "Count Y" },
    "z": { "type": "number", "default": 3, "description": "Count Z" },
    "spacing": { "type": "number", "default": 1, "description": "Grid spacing" },
    "centered": { "type": "boolean", "default": true }
  },
  "code": "const { geometry, x=1, y=1, z=1, spacing = 1, centered = true, autoMerge = true } = params; const nx = params.x || params.cols || 1; const ny = params.y || 1; const nz = params.z || params.rows || 1; const sx = Array.isArray(spacing) ? spacing[0] : spacing; const sy = Array.isArray(spacing) ? spacing[1] : 0; const sz = Array.isArray(spacing) ? spacing[2] : spacing; const offsetX = centered ? -sx * (nx - 1) / 2 : 0; const offsetY = centered ? -sy * (ny - 1) / 2 : 0; const offsetZ = centered ? -sz * (nz - 1) / 2 : 0; if (!geometry) { const count = nx * ny * nz; const positions = new Float32Array(count * 3); const normals = new Float32Array(count * 3); let i = 0; for (let ix = 0; ix < nx; ix++) { for (let iy = 0; iy < ny; iy++) { for (let iz = 0; iz < nz; iz++) { positions[i*3] = offsetX + ix * sx; positions[i*3+1] = offsetY + iy * sy; positions[i*3+2] = offsetZ + iz * sz; normals[i*3] = 0; normals[i*3+1] = 1; normals[i*3+2] = 0; i++; } } } const pointsGeom = new THREE.BufferGeometry(); pointsGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3)); pointsGeom.setAttribute('normal', new THREE.BufferAttribute(normals, 3)); return pointsGeom; } const results = []; for (let ix = 0; ix < nx; ix++) { for (let iy = 0; iy < ny; iy++) { for (let iz = 0; iz < nz; iz++) { const clone = geometry.clone(); clone.translate(offsetX + ix * sx, offsetY + iy * sy, offsetZ + iz * sz); results.push(clone); } } } return autoMerge ? BufferGeometryUtils.mergeGeometries(results) : results;",
  "outputType": "Geometry"
}
,
  {
    "id": "distributeRandom3d",
    "name": "distributeRandom3d",
    "description": "Scatters copies randomly throughout a bounded region. You define the bounds (box size) and how many copies to place. Uses a seeded random generator so patterns are reproducible. Great for populating forests, rocky terrain, or particle distributions.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": ""
      },
      "bounds": {
        "type": "array",
        "default": [
          [
            0,
            0,
            0
          ],
          [
            1,
            1,
            1
          ]
        ]
      },
      "count": {
        "type": "number",
        "default": 50
      },
      "seed": {
        "type": "number",
        "default": 42
      },
      "autoMerge": {
        "type": "boolean",
        "default": true
      }
    },
    "code": "const { geometry, bounds, count = 50, seed = 42, autoMerge = true } = params;\n\n    if (!geometry) return autoMerge ? new THREE.BufferGeometry() : [];\n\n    // --- ROBUST BOUNDS PARSING ---\n    let min = [0, 0, 0];\n    let max = [1, 1, 1];\n\n    if (Array.isArray(bounds)) {\n        if (bounds.length === 2 && Array.isArray(bounds[0])) {\n            // Standard format: [[0,0,0], [10,10,10]]\n            min = bounds[0];\n            max = bounds[1];\n        } else if (bounds.length === 6 && typeof bounds[0] === 'number') {\n            // Flat format: [0,0,0, 10,10,10]\n            min = [bounds[0], bounds[1], bounds[2]];\n            max = [bounds[3], bounds[4], bounds[5]];\n        } else if (bounds.length === 3 && typeof bounds[0] === 'number') {\n            // Size-only format: [10, 10, 10] (assumes min is 0,0,0)\n            max = bounds;\n        }\n    }\n\n    // Safety fallback if parsing failed\n    min = min || [0,0,0];\n    max = max || [1,1,1];\n    // -----------------------------\n\n    const random = (() => {\n        let a = seed;\n        return () => {\n            let t = a += 0x6D2B79F5;\n            t = Math.imul(t ^ t >>> 15, t | 1);\n            t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n            return ((t ^ t >>> 14) >>> 0) / 4294967296;\n        };\n    })();\n\n    const results = [];\n\n    for (let i = 0; i < count; i++) {\n        // Safe access with defaults (|| 0) prevents NaN if 2D arrays are passed\n        const x = (min[0]||0) + ((max[0]||0) - (min[0]||0)) * random();\n        const y = (min[1]||0) + ((max[1]||0) - (min[1]||0)) * random();\n        const z = (min[2]||0) + ((max[2]||0) - (min[2]||0)) * random();\n        \n        const clone = geometry.clone();\n        clone.translate(x, y, z);\n        results.push(clone);\n    }\n\n    return autoMerge ? BufferGeometryUtils.mergeGeometries(results) : results;",
    "outputType": "Geometry"
  },
  {
    "id": "createVectorField",
    "name": "createVectorField",
    "description": "Creates an invisible force field in space. Can be attracting (pulls toward center), repelling (pushes away), or swirling (vortex). Used as foundation for deforming geometry or driving particle systems.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "type": {
        "type": "string",
        "default": "'attractor'"
      },
      "center": {
        "type": "array",
        "default": []
      },
      "strength": {
        "type": "number",
        "default": 1.0
      }
    },
    "code": "const { type = 'attractor', center = [0, 0, 0], strength = 1.0 } = params;\n    const centerVec = new THREE.Vector3(...center);\n\n    let fieldFn;\n    if (type === 'attractor') {\n        fieldFn = (x, y, z) => {\n            const pos = new THREE.Vector3(x, y, z);\n            const dir = centerVec.clone().sub(pos);\n            const dist = dir.length();\n            return dir.normalize().multiplyScalar(strength / (1 + dist));\n        };\n    } else if (type === 'repeller') {\n        fieldFn = (x, y, z) => {\n            const pos = new THREE.Vector3(x, y, z);\n            const dir = pos.clone().sub(centerVec);\n            const dist = dir.length();\n            return dir.normalize().multiplyScalar(strength / (1 + dist));\n        };\n    } else if (type === 'vortex') {\n        fieldFn = (x, y, z) => {\n            const pos = new THREE.Vector3(x, y, z);\n            const dir = pos.clone().sub(centerVec);\n            const tangent = new THREE.Vector3(-dir.z, 0, dir.x).normalize();\n            return tangent.multiplyScalar(strength);\n        };\n    } else {\n        fieldFn = () => new THREE.Vector3(0, 0, 0);\n    }\n\n    // \u2705 WRAPPED OUTPUT with field attached\n    return wrapFieldAsObject(fieldFn, `${type} field at [${center}]`);",
    "outputType": "Data"
  },
  {
    "id": "flowField",
    "name": "flowField",
    "description": "Defines complex flow patterns\u2014imagine wind, water currents, or magnetic fields. Modes: 'curl-noise' creates swirling patterns (smoke-like), 'laminar' is smooth directional flow, 'turbulent' adds chaos, 'chaotic' follows butterfly-effect dynamics, 'wave' expands and contracts like ripples. Curl-noise is special: mathematically designed to avoid physical impossibilities (true incompressible fluids). Used in VFX, particle systems, and form-finding inspired by nature.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "type": {
        "type": "string",
        "default": "curl-noise",
        "description": "Type: 'laminar', 'curl-noise', 'attractor', 'expression', 'turbulent', 'chaotic', 'wave'"
      },
      "strength": {
        "type": "number",
        "default": 1.0
      },
      "scale": {
        "type": "number",
        "default": 0.1
      },
      "frequency": {
        "type": "number",
        "default": 1.0
      },
      "time": {
        "type": "number",
        "default": 0.0
      },
      "damping": {
        "type": "number",
        "default": 0.0
      },
      "mode": {
        "type": "string",
        "default": "",
        "description": "Override auto-detection: 'expression', 'noise', 'attractor', 'preset-laminar', 'preset-turbulent', 'preset-chaotic', 'preset-wave'"
      },
      "vx": {
        "type": "string",
        "default": "0",
        "description": "X velocity expression (for mode='expression')"
      },
      "vy": {
        "type": "string",
        "default": "0",
        "description": "Y velocity expression (for mode='expression')"
      },
      "vz": {
        "type": "string",
        "default": "0",
        "description": "Z velocity expression (for mode='expression')"
      }
    },
    "code": "const {\n    type = 'laminar',           \n    mode, // Left undefined by default to allow auto-detection\n    \n    // For expression mode (defaults set to '0' to avoid NaN/undefined issues)\n    vx = '0', \n    vy = '0', \n    vz = '0',\n    \n    // For noise mode\n    noiseType = 'curl-noise',  // 'curl-noise', 'turbulence', 'fractal'\n    frequency = 1.0,\n    octaves = 3, \n    \n    // For attractor mode\n    attractors = [],           // [{pos: [x,y,z], strength: 1.0}, ...]\n    repellers = [],            // [{pos: [x,y,z], strength: 1.0}, ...]\n    \n    // Global parameters\n    strength = 1.0,\n    scale = 0.1,\n    time = 0,\n    damping = 0.0              // 0-1: damps velocity magnitude over distance\n  } = params;\n\n  // 1. Determine Effective Mode\n  // Priority: Explicit 'mode' param > Deduce from 'type' > Fallback\n  let effectiveMode = mode;\n  if (!effectiveMode) {\n    if (['laminar', 'turbulent', 'chaotic', 'wave'].includes(type)) {\n        effectiveMode = 'preset-' + type;\n    } else if (['noise', 'curl-noise'].includes(type)) {\n        effectiveMode = 'noise';\n    } else if (['attractor', 'repeller', 'vortex'].includes(type)) {\n        effectiveMode = 'attractor';\n    } else {\n        effectiveMode = 'expression';\n    }\n  }\n\n  console.log(`\u2705 flowField: type='${type}', mode='${mode}' -> effective='${effectiveMode}'`);\n\n  let fieldFn;\n\n  // =========================================================================\n  // MODE: EXPRESSION (Custom Formulas)\n  // =========================================================================\n  if (effectiveMode === 'expression') {\n    try {\n      const ctx = {\n        Math, sin: Math.sin, cos: Math.cos, sqrt: Math.sqrt,\n        abs: Math.abs, tan: Math.tan, exp: Math.exp, log: Math.log,\n        max: Math.max, min: Math.min, pow: Math.pow, PI: Math.PI,\n        time\n      };\n      \n      // Helper to ensure we have a valid return statement\n      const parse = (val) => {\n          if (typeof val === 'number') return `return ${val}`;\n          if (!val.includes('return')) return `return ${val}`;\n          return val;\n      };\n\n      const fnX = new Function('x, y, z, ctx', parse(vx));\n      const fnY = new Function('x, y, z, ctx', parse(vy));\n      const fnZ = new Function('x, y, z, ctx', parse(vz));\n      \n      fieldFn = (x, y, z) => {\n        let velX = 0, velY = 0, velZ = 0;\n        try { velX = fnX(x, y, z, ctx); } catch(e) {}\n        try { velY = fnY(x, y, z, ctx); } catch(e) {}\n        try { velZ = fnZ(x, y, z, ctx); } catch(e) {}\n        \n        const vel = new THREE.Vector3(velX, velY, velZ).multiplyScalar(strength * scale);\n        \n        // Apply global damping\n        if (damping > 0) {\n          const dist = Math.sqrt(x*x + y*y + z*z);\n          const damp = Math.exp(-damping * dist);\n          vel.multiplyScalar(damp);\n        }\n        \n        return vel;\n      };\n    } catch (e) {\n      console.error('Expression parsing failed:', e);\n      fieldFn = () => new THREE.Vector3(0, 0, 0);\n    }\n  }\n\n  // =========================================================================\n  // MODE: NOISE (Perlin/Simplex)\n  // =========================================================================\n  else if (effectiveMode === 'noise') {\n    if (noiseType === 'curl-noise') {\n      // 3D CURL NOISE (Divergence Free - Twisting Pipes in all directions)\n      fieldFn = (x, y, z) => {\n        const f = frequency;\n        const eps = 0.1; \n\n        // Sample 3 \"potential\" fields by offsetting the noise space\n        // This ensures we generate a valid vector potential A\n        const n1 = (dx, dy, dz) => noise.simplex3(x * f + dx, y * f + dy, z * f + dz);\n        const n2 = (dx, dy, dz) => noise.simplex3(x * f + dx + 123.4, y * f + dy + 123.4, z * f + dz + 123.4);\n        const n3 = (dx, dy, dz) => noise.simplex3(x * f + dx + 234.5, y * f + dy + 234.5, z * f + dz + 234.5);\n\n        // Calculate Curl (\u2207 \u00d7 A)\n        // vx = \u2202Az/\u2202y - \u2202Ay/\u2202z\n        const dy_n3 = (n3(0, eps, 0) - n3(0, -eps, 0)) / (2 * eps);\n        const dz_n2 = (n2(0, 0, eps) - n2(0, 0, -eps)) / (2 * eps);\n        const vx = dy_n3 - dz_n2;\n\n        // vy = \u2202Ax/\u2202z - \u2202Az/\u2202x\n        const dz_n1 = (n1(0, 0, eps) - n1(0, -eps, 0)) / (2 * eps);\n        const dx_n3 = (n3(eps, 0, 0) - n3(-eps, 0, 0)) / (2 * eps);\n        const vy = dz_n1 - dx_n3;\n\n        // vz = \u2202Ay/\u2202x - \u2202Ax/\u2202y\n        const dx_n2 = (n2(eps, 0, 0) - n2(-eps, 0, 0)) / (2 * eps);\n        const dy_n1 = (n1(0, eps, 0) - n1(0, -eps, 0)) / (2 * eps);\n        const vz = dx_n2 - dy_n1;\n        \n        return new THREE.Vector3(vx, vy, vz).multiplyScalar(strength * scale);\n      };\n    }\n    \n    else if (noiseType === 'turbulence') {\n      fieldFn = (x, y, z) => {\n        let vx = 0, vy = 0, vz = 0;\n        let amp = 1;\n        let freq = frequency;\n        \n        for (let i = 0; i < octaves; i++) {\n          vx += noise.simplex3(x * freq, y * freq, z * freq) * amp;\n          vy += noise.simplex3(x * freq + 1000, y * freq + 1000, z * freq) * amp;\n          vz += noise.simplex3(x * freq + 2000, y * freq, z * freq + 2000) * amp;\n          \n          freq *= 2;\n          amp *= 0.5;\n        }\n        \n        return new THREE.Vector3(vx, vy, vz).multiplyScalar(strength * scale);\n      };\n    }\n    \n    else { // Simple directional noise\n      fieldFn = (x, y, z) => {\n        let result = 0;\n        let amp = 1;\n        let freq = frequency;\n        \n        for (let i = 0; i < octaves; i++) {\n          result += noise.simplex3(x * freq, y * freq, z * freq) * amp;\n          freq *= 2;\n          amp *= 0.5;\n        }\n        \n        // Direction radiates from center, modulated by noise\n        const dir = new THREE.Vector3(x, y, z).normalize();\n        return dir.multiplyScalar(result * strength * scale);\n      };\n    }\n  }\n\n  // =========================================================================\n  // MODE: ATTRACTOR (Gravity/Magnetism)\n  // =========================================================================\n  else if (effectiveMode === 'attractor') {\n    fieldFn = (x, y, z) => {\n      const pos = new THREE.Vector3(x, y, z);\n      let totalForce = new THREE.Vector3(0, 0, 0);\n      \n      // Default single attractor if none provided\n      const effectiveAttractors = attractors.length > 0 ? attractors : [{pos: [0,0,0], strength: 1.0}];\n\n      // Attractors\n      for (const attr of effectiveAttractors) {\n        const center = new THREE.Vector3(...(attr.pos || [0,0,0]));\n        const str = attr.strength !== undefined ? attr.strength : 1.0;\n        const dir = center.clone().sub(pos);\n        const dist = dir.length();\n        if (dist > 0.01) {\n          totalForce.add(dir.normalize().multiplyScalar(str / (1 + dist * damping)));\n        }\n      }\n      \n      // Repellers\n      for (const rep of repellers) {\n        const center = new THREE.Vector3(...(rep.pos || [0,0,0]));\n        const str = rep.strength !== undefined ? rep.strength : 1.0;\n        const dir = pos.clone().sub(center); // Direction AWAY from center\n        const dist = dir.length();\n        if (dist > 0.01) {\n          totalForce.add(dir.normalize().multiplyScalar(str / (1 + dist * damping)));\n        }\n      }\n      \n      return totalForce.multiplyScalar(strength * scale);\n    };\n  }\n\n  // =========================================================================\n  // MODE: PRESETS\n  // =========================================================================\n  else if (effectiveMode === 'preset-laminar') {\n    // Simple linear flow along X\n    fieldFn = () => new THREE.Vector3(strength * scale, 0, 0);\n  }\n  \n  else if (effectiveMode === 'preset-turbulent') {\n    // Multi-octave noise preset\n    fieldFn = (x, y, z) => {\n      let vel = new THREE.Vector3(0, 0, 0);\n      let amp = 1;\n      let freq = frequency;\n      \n      for (let i = 0; i < octaves; i++) {\n        const nx = noise.simplex3(x * freq, y * freq, z * freq) * amp;\n        const ny = noise.simplex3(x * freq + 500, y * freq + 500, z * freq) * amp;\n        const nz = noise.simplex3(x * freq + 1000, y * freq + 1000, z * freq) * amp;\n        \n        vel.add(new THREE.Vector3(nx, ny, nz));\n        freq *= 2;\n        amp *= 0.5;\n      }\n      \n      return vel.multiplyScalar(strength * scale);\n    };\n  }\n  \n  else if (effectiveMode === 'preset-chaotic') {\n    // Lorenz attractor\n    const sigma = 10, rho = 28, beta = 8/3;\n    fieldFn = (x, y, z) => {\n      const vx = sigma * (y - x);\n      const vy = x * (rho - z) - y;\n      const vz = x * y - beta * z;\n      \n      // Normalize strictly for chaotic fields to prevent explosion\n      return new THREE.Vector3(vx, vy, vz).normalize().multiplyScalar(strength * scale);\n    };\n  }\n  \n  else if (effectiveMode === 'preset-wave') {\n    // Expanding/contracting waves\n    const center = new THREE.Vector3(0, 0, 0);\n    fieldFn = (x, y, z) => {\n      const pos = new THREE.Vector3(x, y, z);\n      const dist = pos.sub(center).length();\n      const wave = Math.sin(dist * frequency - time);\n      const dir = pos.clone().normalize();\n      \n      return dir.multiplyScalar(wave * strength * scale);\n    };\n  }\n\n  else {\n      // Final safety fallback\n      fieldFn = () => new THREE.Vector3(0, 0, 0);\n  }\n\n  // \u2705 WRAP for downstream use\n  return wrapFieldAsObject(fieldFn, `${type} flow field`, {\n    type,\n    mode: effectiveMode,\n    strength,\n    scale,\n    frequency,\n    octaves,\n    damping\n  });",
    "outputType": "Data"
  },
  {
    "id": "createStreamlines",
    "name": "createStreamlines",
    "description": "Visualization of flow vector field via Euler integration. Traces field lines from random seed points for fixed step count. Returns LineSegments geometry with raw segment data for downstream processing (piping, thickening). Used for field analysis and design intent visualization.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "field": {
        "type": "string",
        "default": "",
        "description": "Vector field variable name"
      },
      "box": {
        "type": "array",
        "default": [
          -5,
          -5,
          -5,
          5,
          5,
          5
        ]
      },
      "count": {
        "type": "number",
        "default": 50
      },
      "steps": {
        "type": "number",
        "default": 50
      },
      "stepSize": {
        "type": "number",
        "default": 0.1
      }
    },
    "code": "const { \n        field, \n        box = [-5, -5, -5, 5, 5, 5], \n        count = 50, \n        steps = 50, \n        stepSize = 0.1 \n    } = params;\n\n    const fieldFn = resolveField(field);\n    if (typeof fieldFn !== 'function') {\n        console.warn('createStreamlines: No valid field found');\n        return new THREE.BufferGeometry();\n    }\n\n    const [minX, minY, minZ, maxX, maxY, maxZ] = box;\n    \n    // We will collect all segments into a single array for LineSegments (Better Performance)\n    const positions = [];\n    \n    // Also store raw segments for Marching Cubes (start, end, thickness)\n    const rawSegments = []; \n    const defaultThickness = 0.05;\n\n    for (let i = 0; i < count; i++) {\n        let pos = new THREE.Vector3(\n            minX + Math.random() * (maxX - minX),\n            minY + Math.random() * (maxY - minY),\n            minZ + Math.random() * (maxZ - minZ)\n        );\n\n        for (let j = 0; j < steps; j++) {\n            const dir = fieldFn(pos.x, pos.y, pos.z);\n            if (!dir || dir.length() < 0.001) break;\n            \n            const nextPos = pos.clone().add(dir.clone().multiplyScalar(stepSize));\n            \n            // Visual: Add to positions array (pairs of points)\n            positions.push(pos.x, pos.y, pos.z);\n            positions.push(nextPos.x, nextPos.y, nextPos.z);\n            \n            // Data: Save segment for downstream processing\n            rawSegments.push([pos.clone(), nextPos.clone(), defaultThickness]);\n            \n            pos = nextPos;\n        }\n    }\n\n    if (positions.length === 0) return new THREE.BufferGeometry();\n\n    // Create a single BufferGeometry for all lines\n    const geometry = new THREE.BufferGeometry();\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n    \n    // \u2705 WRAP IN LINE OBJECT: This ensures it renders as lines, not invisible triangles\n    // We return a THREE.LineSegments object which the executor will add to the scene.\n    // The executor will apply the user's material (color), which works on lines too.\n    const lineObject = new THREE.LineSegments(geometry, new THREE.LineBasicMaterial({ color: 0xffffff }));\n\n    // \u2705 Attach data for Marching Cubes\n    lineObject.userData = {\n        type: 'streamlines',\n        segments: rawSegments\n    };\n\n    return lineObject;",
    "outputType": "Geometry"
  },
  {
    "id": "createFlowPipes",
    "name": "createFlowPipes",
    "description": "Tube geometry following streamlines from vector field. Combines curve integration with TubeGeometry for volumetric field visualization. Used for visualizing vorticity, flow direction, and designing with field lines.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "field": {
        "type": "string",
        "default": "",
        "description": "Name of the vector field variable to visualize"
      },
      "box": {
        "type": "array",
        "default": [
          -5,
          -5,
          -5,
          5,
          5,
          5
        ]
      },
      "count": {
        "type": "number",
        "default": 20
      },
      "steps": {
        "type": "number",
        "default": 40
      },
      "stepSize": {
        "type": "number",
        "default": 0.1
      },
      "radius": {
        "type": "number",
        "default": 0.1
      }
    },
    "code": "const { \n        field,\n        box = [-5, -5, -5, 5, 5, 5],\n        count = 20,\n        steps = 40,\n        stepSize = 0.1,\n        radius = 0.1\n    } = params;\n\n    const fieldFn = resolveField(field);\n\n    if (typeof fieldFn !== 'function') {\n        console.warn('createFlowPipes: No valid field');\n        return new THREE.BufferGeometry();\n    }\n\n    const [minX, minY, minZ, maxX, maxY, maxZ] = box;\n    const pipes = [];\n\n    for (let i = 0; i < count; i++) {\n        let pos = new THREE.Vector3(\n            minX + Math.random() * (maxX - minX),\n            minY + Math.random() * (maxY - minY),\n            minZ + Math.random() * (maxZ - minZ)\n        );\n\n        const points = [pos.clone()];\n\n        for (let j = 0; j < steps; j++) {\n            const dir = fieldFn(pos.x, pos.y, pos.z);\n            if (!dir || dir.length() < 0.001) break;\n\n            pos.add(dir.clone().multiplyScalar(stepSize));\n            points.push(pos.clone());\n        }\n\n        if (points.length > 2) {\n            const curve = new THREE.CatmullRomCurve3(points, false);\n            const tubeGeom = new THREE.TubeGeometry(curve, 8, radius, 4, false);\n            pipes.push(tubeGeom);\n        }\n    }\n\n    return pipes.length > 0 ? BufferGeometryUtils.mergeGeometries(pipes) : new THREE.BufferGeometry();",
    "outputType": "Geometry"
  },
  {
    "id": "cellularAutomata",
    "name": "cellularAutomata",
    "description": "A grid where each cell follows simple rules based on neighbors, creating surprising complexity. Invented by von Neumann, popularized by Conway's Game of Life. Example: 'if 3 neighbors are alive, turn on; if 0-1 or 4+ neighbors, turn off.' Run for many steps and patterns emerge\u2014gliders, oscillators, chaos. Used for: generative texture, population simulation, procedural cave generation, and understanding emergence (simple local rules \u2192 complex global behavior).",
    "category": "Procedural",
    "paramsSchema": {
      "gridSize": {
        "type": "number",
        "default": 10,
        "description": "3D grid dimensions (gridSize \u00d7 gridSize \u00d7 gridSize voxels)"
      },
      "iterations": {
        "type": "number",
        "default": 10,
        "description": "Number of generation/simulation steps to run"
      },
      "rules": {
        "type": "string",
        "default": "{\"survive\": [2, 3], \"born\": [3]}",
        "description": "Cellular automata rules as JSON: survive (neighbor counts to keep cell alive), born (neighbor counts to create new cell)"
      }
    },
    "code": "const { gridSize = 10, iterations = 10, rules: rawRules } = params;\n\n    // 1. DEFINE DEFAULTS\n    const defaultRules = { survive: [2, 3], born: [3] };\n\n    // 2. PARSE RULES (Handle String vs Object)\n    let rules = defaultRules;\n    if (rawRules) {\n        if (typeof rawRules === 'string') {\n            try {\n                rules = JSON.parse(rawRules);\n            } catch (e) {\n                console.warn('cellularAutomata: Invalid JSON rules, using defaults.', e);\n                rules = defaultRules;\n            }\n        } else if (typeof rawRules === 'object') {\n            rules = rawRules;\n        }\n    }\n\n    // 3. VALIDATE STRUCTURE\n    if (!Array.isArray(rules.survive)) rules.survive = defaultRules.survive;\n    if (!Array.isArray(rules.born)) rules.born = defaultRules.born;\n\n    // 4. INITIALIZE GRID (Nested 3D for Simulation Logic)\n    const grid = new Array(gridSize);\n    for (let x = 0; x < gridSize; x++) {\n        grid[x] = new Array(gridSize);\n        for (let y = 0; y < gridSize; y++) {\n            grid[x][y] = new Array(gridSize);\n            for (let z = 0; z < gridSize; z++) {\n                grid[x][y][z] = Math.random() > 0.5 ? 1 : 0;\n            }\n        }\n    }\n\n    // 5. SIMULATION LOOP\n    for (let iter = 0; iter < iterations; iter++) {\n        const newGrid = JSON.parse(JSON.stringify(grid));\n\n        for (let x = 0; x < gridSize; x++) {\n            for (let y = 0; y < gridSize; y++) {\n                for (let z = 0; z < gridSize; z++) {\n                    let neighbors = 0;\n\n                    // Count neighbors in 3x3x3 kernel\n                    for (let dx = -1; dx <= 1; dx++) {\n                        for (let dy = -1; dy <= 1; dy++) {\n                            for (let dz = -1; dz <= 1; dz++) {\n                                if (dx === 0 && dy === 0 && dz === 0) continue;\n                                const nx = x + dx, ny = y + dy, nz = z + dz;\n                                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && nz >= 0 && nz < gridSize) {\n                                    neighbors += grid[nx][ny][nz];\n                                }\n                            }\n                        }\n                    }\n\n                    // Apply Rules\n                    if (grid[x][y][z] === 1) {\n                        newGrid[x][y][z] = rules.survive.includes(neighbors) ? 1 : 0;\n                    } else {\n                        newGrid[x][y][z] = rules.born.includes(neighbors) ? 1 : 0;\n                    }\n                }\n            }\n        }\n\n        // Update grid\n        for (let x = 0; x < gridSize; x++) {\n            for (let y = 0; y < gridSize; y++) {\n                for (let z = 0; z < gridSize; z++) {\n                    grid[x][y][z] = newGrid[x][y][z];\n                }\n            }\n        }\n    }\n\n    // 6. FLATTEN GRID (Convert 3D to 1D Float32Array for MarchingCubes)\n    const flatGrid = new Float32Array(gridSize * gridSize * gridSize);\n    for (let z = 0; z < gridSize; z++) {\n        for (let y = 0; y < gridSize; y++) {\n            for (let x = 0; x < gridSize; x++) {\n                // Standard Stride: x + y*W + z*W*H\n                const index = x + y * gridSize + z * gridSize * gridSize;\n                flatGrid[index] = grid[x][y][z];\n            }\n        }\n    }\n\n    // \u2705 WRAPPED OUTPUT: Returns flattened data object\n    return wrapGridAsObject(flatGrid, gridSize, iterations, rules);",
    "outputType": "Data"
  },
  {
    "id": "reactionDiffusion",
    "name": "reactionDiffusion",
    "description": "Simulates how two chemicals react and spread, creating patterns like leopard spots or zebra stripes. Developed by Alan Turing (1952), explaining how biological patterns emerge from uniform starting conditions. You adjust diffusion rates (how fast chemicals spread) and feed/kill rates (reaction parameters). Pattern emerges automatically\u2014no hand-sculpting. Used for: generative design inspired by nature, procedural textures, understanding morphogenesis (how patterns form in living systems).",
    "category": "Basic Geometry",
    "paramsSchema": {
      "size": {
        "type": "number",
        "default": 32
      },
      "iterations": {
        "type": "number",
        "default": 50
      },
      "feed": {
        "type": "number",
        "default": 0.055
      },
      "kill": {
        "type": "number",
        "default": 0.062
      },
      "dt": {
        "type": "number",
        "default": 0.2
      }
    },
    "code": "const { \n        size = 32,\n        iterations = 50, \n        feed = 0.055,\n        kill = 0.062,\n        dt = 0.2 \n    } = params;\n\n    // 1. Initialize Grid\n    // Flattened array: x + y*size + z*size*size\n    const len = size * size * size;\n    let A = new Float32Array(len).fill(1.0);\n    let B = new Float32Array(len).fill(0.0);\n    \n    // 2. Seed Center\n    const center = Math.floor(size/2);\n    const radius = Math.max(2, Math.floor(size/8));\n    \n    console.log(`Starting RD Simulation: ${size}^3, ${iterations} steps, dt=${dt}`);\n\n    // Pre-seed pattern\n    for(let z=center-radius; z<=center+radius; z++) {\n        for(let y=center-radius; y<=center+radius; y++) {\n            for(let x=center-radius; x<=center+radius; x++) {\n                if ((x-center)**2 + (y-center)**2 + (z-center)**2 < radius**2) {\n                    if (x>=0 && x<size && y>=0 && y<size && z>=0 && z<size) {\n                        B[x + y*size + z*size*size] = 1.0;\n                    }\n                }\n            }\n        }\n    }\n\n    // 3. Simulation Helpers\n    const strideY = size;\n    const strideZ = size * size;\n\n    function getLaplacian(arr, i, x, y, z) {\n        // Toroidal (Wrap-around) Neighbors\n        const xm = (x > 0 ? i-1 : i+size-1);\n        const xp = (x < size-1 ? i+1 : i-size+1);\n        const ym = (y > 0 ? i-strideY : i-strideY+strideZ);\n        const yp = (y < size-1 ? i+strideY : i+strideY-strideZ);\n        const zm = (z > 0 ? i-strideZ : i-strideZ+len); \n        const zp = (z < size-1 ? i+strideZ : i-strideZ*(size-1));\n\n        return (arr[xm] + arr[xp] + arr[ym] + arr[yp] + arr[zm] + arr[zp] - 6 * arr[i]);\n    }\n\n    // 4. Simulation Loop\n    for(let iter=0; iter<iterations; iter++) {\n        const nextA = new Float32Array(len);\n        const nextB = new Float32Array(len);\n        let activeCount = 0;\n\n        for(let z=0; z<size; z++) {\n            for(let y=0; y<size; y++) {\n                for(let x=0; x<size; x++) {\n                    const i = x + y*size + z*size*size;\n                    const a = A[i];\n                    const b = B[i];\n                    \n                    const abb = a * b * b;\n                    const lapA = getLaplacian(A, i, x, y, z);\n                    const lapB = getLaplacian(B, i, x, y, z);\n                    \n                    // Gray-Scott Formulas\n                    nextA[i] = Math.max(0, Math.min(1, a + (1.0 * lapA - abb + feed * (1 - a)) * dt));\n                    nextB[i] = Math.max(0, Math.min(1, b + (0.5 * lapB + abb - (kill + feed) * b) * dt));\n                    \n                    if (nextB[i] > 0.01) activeCount++;\n                }\n            }\n        }\n        A = nextA;\n        B = nextB;\n\n        if (iter === iterations - 1) {\n             console.log(`RD Stats: Active Cells (>0.01) = ${activeCount}/${len}`);\n        }\n    }\n\n    // 5. Return Wrapped Object\n    // We explicitly set 'grid' and 'size' to ensure compatibility\n    return wrapGridAsObject(B, size, { \n        type: 'reaction-diffusion',\n        voxelSize: 1,\n        feed, \n        kill \n    });",
    "outputType": "Data"
  },
  {
    "id": "modifyGeometry",
    "name": "modifyGeometry",
    "description": "Generic geometry modification placeholder. Routes to specific deformation based on parameters. Utility wrapper for streamlined parameter-based transformations.",
    "category": "Deformation",
    "paramsSchema": {},
    "code": "console.log('modifyGeometry', params);\n\n    let { geometry, operations = [], expression, context = {} } = params;\n\n    if (expression) {\n        operations.push({ expression }); // Convert legacy single expression to array\n    }\n\n    if (!geometry) {\n        console.warn(\"modifyGeometry: No geometry\");\n        return null;\n    }\n\n    const geom = geometry.clone();\n    const positionAttribute = geom.attributes.position;\n    const normalAttribute = geom.attributes.normal;\n\n    if (!positionAttribute) return geom;\n\n    const count = positionAttribute.count;\n    const p = new THREE.Vector3();\n    const n = new THREE.Vector3();\n    const utils = Math;\n\n    // Pre-compile all operation functions\n    const funcs = operations.map(op => {\n        try {\n            return new Function('p', 'n', 'i', 'ctx', 'utils', 'v', op.expression);\n        } catch (e) {\n            console.error(\"modifyGeometry: Failed to compile expression\", op.expression, e);\n            return null;\n        }\n    });\n\n    // Iterate Vertices\n    for (let i = 0; i < count; i++) {\n        p.fromBufferAttribute(positionAttribute, i);\n        if (normalAttribute) n.fromBufferAttribute(normalAttribute, i);\n\n        // Run the pipeline\n        funcs.forEach(fn => {\n            if (fn) {\n                fn(p, n, i, context, utils, p);\n            }\n        });\n\n        positionAttribute.setXYZ(i, p.x, p.y, p.z);\n    }\n\n    geom.computeVertexNormals();\n    positionAttribute.needsUpdate = true;\n    return geom;",
    "outputType": "Geometry"
  },
  {
    "id": "meshFromMarchingCubes",
    "name": "meshFromMarchingCubes",
    "description": "Geometry extraction from marching cubes algorithm result. Wraps MC geometry with cleaned vertex data and proper normal computation. Returns refined mesh ready for rendering or export.",
    "category": "Curves & Paths",
    "paramsSchema": {
      "resolution": {
        "type": "number",
        "default": 32,
        "description": "Grid resolution for marching cubes (16-64 typical, higher = slower but more detail)"
      },
      "isovalue": {
        "type": "number",
        "default": 0.1,
        "description": "Threshold value for surface extraction (0.0-1.0 typical)"
      },
      "bounds": {
        "type": "number",
        "default": 10,
        "description": "World space bounds \u00b1bounds in all axes"
      },
      "field": {
        "type": "string",
        "default": "",
        "description": "Vector field or voxel grid variable name"
      },
      "expression": {
        "type": "string",
        "default": "",
        "description": "Math expression for field value: f(x,y,z) or just 'x*y*z', etc."
      }
    },
    "code": "const { resolution = 32, isovalue = 0.5, bounds = 10, field } = params; const dummyMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); const effect = new MarchingCubes(resolution, dummyMaterial, false, false, 200000); let fieldFn; let mode = 'unknown'; if (field && field.userData && (field.userData.grid || field.userData.voxels)) { mode = 'grid'; const gridArr = field.userData.grid || field.userData.voxels; const sizeVal = field.userData.size || field.userData.gridSize || resolution; const sx = Array.isArray(sizeVal) ? sizeVal[0] : sizeVal; const sy = Array.isArray(sizeVal) ? sizeVal[1] : sizeVal; const sz = Array.isArray(sizeVal) ? sizeVal[2] : sizeVal; fieldFn = (x, y, z) => { const u = (x + bounds) / (2 * bounds); const v = (y + bounds) / (2 * bounds); const w = (z + bounds) / (2 * bounds); if (u < 0 || u >= 1 || v < 0 || v >= 1 || w < 0 || w >= 1) return 0; const ix = Math.floor(u * sx); const iy = Math.floor(v * sy); const iz = Math.floor(w * sz); return gridArr[ix + iy*sx + iz*sx*sy]; }; } else if (field && field.userData && field.userData.segments) { mode = 'skeleton'; const segments = field.userData.segments; const count = segments.length; const starts = new Float32Array(count * 3); const ends = new Float32Array(count * 3); const radii = new Float32Array(count); for(let i=0; i<count; i++) { const [s, e, t] = segments[i]; starts[i*3] = s.x; starts[i*3+1] = s.y; starts[i*3+2] = s.z; ends[i*3] = e.x; ends[i*3+1] = e.y; ends[i*3+2] = e.z; ends[i*3] = e.x; ends[i*3+1] = e.y; ends[i*3+2] = e.z; radii[i] = (t || 0.1) * 3.0; } fieldFn = (x, y, z) => { let density = 0; for(let i=0; i<count; i++) { const sx = starts[i*3], sy = starts[i*3+1], sz = starts[i*3+2]; const ex = ends[i*3], ey = ends[i*3+1], ez = ends[i*3+2]; const l2 = (ex-sx)*(ex-sx) + (ey-sy)*(ey-sy) + (ez-sz)*(ez-sz); if (l2 === 0) continue; let t = ((x-sx)*(ex-sx) + (y-sy)*(ey-sy) + (z-sz)*(ez-sz)) / l2; t = Math.max(0, Math.min(1, t)); const px = sx + t * (ex - sx); const py = sy + t * (ey - sy); const pz = sz + t * (ez - sz); const distSq = (x-px)*(x-px) + (y-py)*(y-py) + (z-pz)*(z-pz); const r = radii[i]; if (distSq < r*r) { const dist = Math.sqrt(distSq); const val = (1.0 - (dist / r)); density = Math.max(density, val); } } return density; }; } else { fieldFn = (x, y, z) => noise.simplex3(x*0.1, y*0.1, z*0.1) + 0.5; } effect.isolation = isovalue; const halfRes = resolution / 2; for (let k = 0; k < resolution; k++) { for (let j = 0; j < resolution; j++) { for (let i = 0; i < resolution; i++) { const x = (i - halfRes) / halfRes * bounds; const y = (j - halfRes) / halfRes * bounds; const z = (k - halfRes) / halfRes * bounds; effect.field[i + j * resolution + k * resolution * resolution] = fieldFn(x, y, z); } } } try { effect.update(); const count = effect.geometry.drawRange.count; if (count > 0) { const rawPos = effect.geometry.attributes.position; const cleanPos = new Float32Array(count * 3); for (let i = 0; i < count; i++) { cleanPos[i*3] = rawPos.getX(i); cleanPos[i*3 + 1] = rawPos.getY(i); cleanPos[i*3 + 2] = rawPos.getZ(i); } const cleanGeom = new THREE.BufferGeometry(); cleanGeom.setAttribute('position', new THREE.BufferAttribute(cleanPos, 3)); cleanGeom.computeVertexNormals(); cleanGeom.scale(bounds, bounds, bounds); effect.geometry.dispose(); dummyMaterial.dispose(); return cleanGeom; } } catch (e) { console.error('MC Error', e); } return new THREE.BufferGeometry();",
    "outputType": "Geometry"
  },
  {
  "id": "lSystemGeometry",
  "name": "lSystemGeometry",
  "description": "Generates fractal patterns (plants/trees). Exports geometry AND raw segments for density field generation.",
  "category": "Procedural",
  "paramsSchema": {
    "axiom": { "type": "string", "default": "X" },
    "rules": { "type": "string", "default": "{\"X\": \"F[&+X][^--X][&^X]\", \"F\": \"FF\"}" },
    "iterations": { "type": "number", "default": 4 },
    "angle": { "type": "number", "default": 25 },
    "scale": { "type": "number", "default": 0.8 },
    "segmentLength": { "type": "number", "default": 1 },
    "thickness": { "type": "number", "default": 0.1 },
    "mode": { "type": "string", "default": "3d" }
  },
  "code": "const { axiom = 'X', rules = { 'X': 'F[&+X][^--X][&^X]', 'F': 'FF' }, iterations = 4, angle = 25, segmentLength = 1, thickness = 0.1, mode = '3d', scale = 0.8 } = params; let parsedRules = rules; if (typeof rules === 'string') { try { parsedRules = JSON.parse(rules); } catch (e) { console.warn('lSystemGeometry: Invalid JSON rules', e); parsedRules = {}; } } let current = axiom; for (let i = 0; i < iterations; i++) { let next = ''; for (const char of current) { next += parsedRules[char] || char; } current = next; } const segments = []; const angleRad = angle * Math.PI / 180; let position = new THREE.Vector3(0, 0, 0); const stepLength = segmentLength * Math.pow(scale, iterations > 0 ? iterations - 1 : 0); if (mode === '2d') { const stack = []; let direction = new THREE.Vector3(0, 1, 0); for (const char of current) { if (char === 'F') { const newPos = position.clone().add(direction.clone().multiplyScalar(stepLength)); segments.push([position.clone(), newPos.clone(), thickness]); position.copy(newPos); } else if (char === '+') { direction.applyAxisAngle(new THREE.Vector3(0, 0, 1), angleRad); } else if (char === '-') { direction.applyAxisAngle(new THREE.Vector3(0, 0, 1), -angleRad); } else if (char === '[') { stack.push([position.clone(), direction.clone()]); } else if (char === ']') { if (stack.length > 0) { const [pos, dir] = stack.pop(); position.copy(pos); direction.copy(dir); } } } } else { const stack = []; let rotation = new THREE.Quaternion(); const rotateTurtle = (axis, rads) => { const rotQuat = new THREE.Quaternion(); rotQuat.setFromAxisAngle(axis, rads); rotation.multiply(rotQuat); }; for (const char of current) { if (char === 'F') { const direction = new THREE.Vector3(0, 1, 0).applyQuaternion(rotation); const newPos = position.clone().add(direction.multiplyScalar(stepLength)); segments.push([position.clone(), newPos.clone(), thickness]); position.copy(newPos); } else if (char === '+') { rotateTurtle(new THREE.Vector3(0, 0, 1), angleRad); } else if (char === '-') { rotateTurtle(new THREE.Vector3(0, 0, 1), -angleRad); } else if (char === '&') { rotateTurtle(new THREE.Vector3(1, 0, 0), angleRad); } else if (char === '^') { rotateTurtle(new THREE.Vector3(1, 0, 0), -angleRad); } else if (char === '\\\\') { rotateTurtle(new THREE.Vector3(0, 1, 0), angleRad); } else if (char === '/') { rotateTurtle(new THREE.Vector3(0, 1, 0), -angleRad); } else if (char === '[') { stack.push({ pos: position.clone(), rot: rotation.clone() }); } else if (char === ']') { if (stack.length > 0) { const state = stack.pop(); position.copy(state.pos); rotation.copy(state.rot); } } } } const geometries = []; for (const [start, end, thick] of segments) { const curve = new THREE.LineCurve3(start, end); const tubeGeom = new THREE.TubeGeometry(curve, 1, thick, 4, false); geometries.push(tubeGeom); } const finalGeom = geometries.length > 0 ? BufferGeometryUtils.mergeGeometries(geometries) : new THREE.BufferGeometry(); finalGeom.userData = { type: 'l-system', segments: segments }; return finalGeom;",
  "outputType": "Geometry"
},
  {
    "id": "differentialGrowth",
    "name": "differentialGrowth",
    "description": "Simulates how biological surfaces grow unevenly, causing natural buckling and wrinkles. Imagine: outer skin grows faster than inner layer \u2192 fabric wrinkles and folds (like flower petals). The algorithm: 1) expands edges beyond their original length, 2) applies smoothing so mesh stays coherent, 3) repeats. Creates organic-looking folds and warping without explicit sculpting. Used for: fabric draping, leaf patterns, bone development, architectural form-finding inspired by nature.",
    "category": "Organic Growth",
    "paramsSchema": {
      "// Optional: Start from existing curve/edges\n        pointsCount": {
        "type": "number",
        "default": 50
      },
      "// Start with a circle of this many points\n        radius": {
        "type": "number",
        "default": 2.0
      },
      "// Radius of starting circle\n        iterations": {
        "type": "number",
        "default": 100
      },
      "// Growth steps\n        maxEdgeLength": {
        "type": "number",
        "default": 0.2
      },
      "// Threshold to add new points\n        repulsionRadius": {
        "type": "number",
        "default": 1.0
      },
      "// How far nodes push each other\n        repulsionForce": {
        "type": "number",
        "default": 0.5
      },
      "attractionForce": {
        "type": "number",
        "default": 0.8
      },
      "// Spring force keeping line together\n        noiseForce": {
        "type": "number",
        "default": 0.1
      },
      "// Random motion to break symmetry\n        outputType": {
        "type": "string",
        "default": "'line'  // 'line' or 'mesh' (ribbon)"
      },
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Reference to geometry variable"
      },
      "iterations": {
        "type": "number",
        "default": 100
      },
      "maxEdgeLength": {
        "type": "number",
        "default": 0.2
      },
      "noiseForce": {
        "type": "number",
        "default": 0.1
      },
      "outputType": {
        "type": "string",
        "default": "line'  // 'line' or 'mesh' (ribbon)"
      },
      "pointsCount": {
        "type": "number",
        "default": 50
      },
      "radius": {
        "type": "number",
        "default": 2.0
      },
      "repulsionForce": {
        "type": "number",
        "default": 0.5
      },
      "repulsionRadius": {
        "type": "number",
        "default": 1.0
      }
    },
    "code": "const { \n        geometry,            // Optional: Start from existing curve/edges\n        pointsCount = 50,    // Start with a circle of this many points\n        radius = 2.0,        // Radius of starting circle\n        iterations = 100,    // Growth steps\n        maxEdgeLength = 0.2, // Threshold to add new points\n        repulsionRadius = 1.0, // How far nodes push each other\n        repulsionForce = 0.5,\n        attractionForce = 0.8, // Spring force keeping line together\n        noiseForce = 0.1,    // Random motion to break symmetry\n        outputType = 'line'  // 'line' or 'mesh' (ribbon)\n    } = params;\n\n    // 1. Initialize Nodes (Circle)\n    let nodes = [];\n    \n    // If input geometry is a Line/Curve, extract points\n    if (geometry && geometry.isBufferGeometry) {\n        const pos = geometry.attributes.position;\n        for(let i=0; i<pos.count; i++) {\n            nodes.push(new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i)));\n        }\n    } else {\n        // Create Circle\n        for (let i = 0; i < pointsCount; i++) {\n            const theta = (i / pointsCount) * Math.PI * 2;\n            nodes.push(new THREE.Vector3(\n                Math.cos(theta) * radius, \n                Math.sin(theta) * radius, \n                0\n            ));\n        }\n    }\n\n    // 2. Simulation Loop\n    for (let iter = 0; iter < iterations; iter++) {\n        const newPositions = nodes.map(n => n.clone());\n        const count = nodes.length;\n\n        // Build Spatial Hash (Simple grid) for optimization\n        // (Skipping full implementation for brevity, doing brute force with optimization check)\n        \n        for (let i = 0; i < count; i++) {\n            const p = nodes[i];\n            let force = new THREE.Vector3();\n\n            // A. Repulsion (Push away from non-neighbors)\n            // Check random subset or nearby nodes to save perf\n            for (let j = 0; j < count; j++) {\n                if (i === j) continue;\n                // Ignore immediate neighbors (handled by springs)\n                // const isNeighbor = (j === (i + 1) % count) || (j === (i - 1 + count) % count);\n                // Actually, in Diff Growth, even neighbors push to expand circle!\n                \n                const other = nodes[j];\n                const distSq = p.distanceToSquared(other);\n                \n                if (distSq < repulsionRadius * repulsionRadius && distSq > 0) {\n                    const dist = Math.sqrt(distSq);\n                    const dir = p.clone().sub(other).normalize();\n                    // Force stronger when closer\n                    force.add(dir.multiplyScalar((repulsionRadius - dist) * repulsionForce));\n                }\n            }\n\n            // B. Spring / Attraction (Stay close to neighbors)\n            const prev = nodes[(i - 1 + count) % count];\n            const next = nodes[(i + 1) % count];\n            \n            const vecToPrev = prev.clone().sub(p);\n            const vecToNext = next.clone().sub(p);\n            \n            // Move towards midpoint of neighbors (Laplacian smoothing)\n            const smooth = vecToPrev.add(vecToNext).multiplyScalar(attractionForce * 0.5);\n            force.add(smooth);\n            \n            // C. Brownian Motion (Noise)\n            force.x += (Math.random() - 0.5) * noiseForce;\n            force.y += (Math.random() - 0.5) * noiseForce;\n\n            // Apply\n            newPositions[i].add(force.multiplyScalar(0.1)); // Time step\n            // Constrain Z (Planar growth often looks better)\n            newPositions[i].z *= 0.9; \n        }\n        \n        nodes = newPositions;\n\n        // 3. Subdivision (Growth)\n        // If edge is too long, split it\n        const nextNodes = [];\n        for (let i = 0; i < nodes.length; i++) {\n            const p1 = nodes[i];\n            const p2 = nodes[(i + 1) % nodes.length]; // Loop\n            \n            nextNodes.push(p1);\n            \n            if (p1.distanceTo(p2) > maxEdgeLength) {\n                // Add new node in middle\n                const mid = p1.clone().add(p2).multiplyScalar(0.5);\n                nextNodes.push(mid);\n            }\n        }\n        nodes = nextNodes;\n        \n        // Limit runaway growth\n        if (nodes.length > 2000) break;\n    }\n\n    // 4. Output\n    if (outputType === 'mesh') {\n        // Extrude logic (Simple Ribbon)\n        const shape = new THREE.Shape();\n        shape.moveTo(nodes[0].x, nodes[0].y);\n        for(let i=1; i<nodes.length; i++) shape.lineTo(nodes[i].x, nodes[i].y);\n        shape.closePath();\n        \n        return new THREE.ExtrudeGeometry(shape, { depth: 0.5, bevelEnabled: false });\n    } else {\n        // Line Loop\n        const geom = new THREE.BufferGeometry().setFromPoints([...nodes, nodes[0]]);\n        // Return as Line Loop visual\n        return new THREE.Line(geom, new THREE.LineBasicMaterial({ color: 0xffffff }));\n    }",
    "outputType": "Geometry"
  },
  {
    "id": "differentialGrowthSurface",
    "name": "differentialGrowthSurface",
    "description": "2D differential growth on mesh surface. Points move along surface normals while maintaining repulsion. Simulates surface expansion, erosion, and organic thickening. Advanced algorithm used in growth form studies.",
    "category": "Organic Growth",
    "paramsSchema": {
      "pointsCount": {
        "type": "number",
        "default": 80
      },
      "radius": {
        "type": "number",
        "default": 0.5
      },
      "generations": {
        "type": "number",
        "default": 15
      },
      "stepsPerGen": {
        "type": "number",
        "default": 10
      },
      "maxEdgeLength": {
        "type": "number",
        "default": 0.3
      },
      "repulsionRadius": {
        "type": "number",
        "default": 0.8
      },
      "repulsionForce": {
        "type": "number",
        "default": 0.8
      },
      "heightPerGen": {
        "type": "number",
        "default": 0.1
      }
    },
    "code": "const { \n        pointsCount = 80, \n        radius = 0.5,\n        generations = 15, \n        stepsPerGen = 10, \n        maxEdgeLength = 0.3, \n        repulsionRadius = 0.8, \n        repulsionForce = 0.8,\n        heightPerGen = 0.1 \n    } = params;\n\n    console.log(`Growing Surface: ${generations} gens, start radius ${radius}`);\n\n    let nodes = [];\n    // Init Circle\n    for (let i = 0; i < pointsCount; i++) {\n        const theta = (i / pointsCount) * Math.PI * 2;\n        nodes.push(new THREE.Vector3(Math.cos(theta)*radius, Math.sin(theta)*radius, 0));\n    }\n\n    const profiles = []; // To be used by createLoft\n\n    // Evolution Loop\n    for (let gen = 0; gen < generations; gen++) {\n        \n        // 1. Capture Snapshot (Profile)\n        // Deep copy and apply height offset\n        const ring = nodes.map(n => {\n            const v = n.clone();\n            v.z = gen * heightPerGen; \n            return [v.x, v.y, v.z]; // Export as array [x,y,z] for universality\n        });\n        \n        // Close the loop explicitly for lofting if needed, \n        // though createLoft 'closed' param handles connections.\n        profiles.push(ring);\n\n        // 2. Simulate Growth (The \"Folding\")\n        for (let step = 0; step < stepsPerGen; step++) {\n            const newPositions = nodes.map(n => n.clone());\n            const count = nodes.length;\n\n            // A. Forces\n            for (let i = 0; i < count; i++) {\n                const p = nodes[i];\n                let force = new THREE.Vector3();\n                \n                // Simple Repulsion (Check localized sample to save perf)\n                // Scan every 5th node to approximate density pressure\n                for (let j = 0; j < count; j+=5) { \n                    const other = nodes[j];\n                    if (p === other) continue;\n                    const d2 = p.distanceToSquared(other);\n                    if (d2 < repulsionRadius*repulsionRadius) {\n                        const d = Math.sqrt(d2);\n                        const push = p.clone().sub(other).normalize();\n                        force.add(push.multiplyScalar((repulsionRadius - d) * repulsionForce));\n                    }\n                }\n                \n                // Laplacian Smoothing (Keep curve fair)\n                const prev = nodes[(i - 1 + count) % count];\n                const next = nodes[(i + 1) % count];\n                const smooth = prev.clone().add(next).sub(p.clone().multiplyScalar(2)).multiplyScalar(0.5);\n                force.add(smooth);\n\n                newPositions[i].add(force.multiplyScalar(0.1));\n            }\n            nodes = newPositions;\n\n            // B. Subdivision (Add Geometry)\n            const nextNodes = [];\n            for(let i=0; i<nodes.length; i++) {\n                const p1 = nodes[i];\n                const p2 = nodes[(i+1)%nodes.length];\n                nextNodes.push(p1);\n                if (p1.distanceTo(p2) > maxEdgeLength) {\n                    nextNodes.push(p1.clone().add(p2).multiplyScalar(0.5));\n                }\n            }\n            nodes = nextNodes;\n        }\n    }\n\n    // Return as a wrapped object that createLoft can understand\n    // We use a dummy geometry to carry the data through the pipeline\n    const dummyGeom = new THREE.BufferGeometry();\n    dummyGeom.userData = {\n        type: 'profiles',\n        profiles: profiles // Array of Array of Points\n    };\n    return dummyGeom;",
    "outputType": "Geometry"
  },
  {
    "id": "differentialGrowth3DSimple",
    "name": "differentialGrowth3DSimple",
    "description": "Simplified 3D differential growth using spatial hashing for neighbor queries. Each point moves via exponential repulsion from neighbors. Returns evolved point cloud as geometry. Used for packing problems and self-avoiding walks.",
    "category": "Organic Growth",
    "paramsSchema": {
      "iterations": {
        "type": "number",
        "default": 20
      },
      "repulsionRadius": {
        "type": "number",
        "default": 0.5
      },
      "growthForce": {
        "type": "number",
        "default": 0.1
      },
      "// Expansion speed\n        smoothing": {
        "type": "number",
        "default": 0.5
      },
      "// Laplacian smoothing strength\n        mode": {
        "type": "string",
        "default": "'line'      // 'line' (curve growth) or 'mesh' (surface folding)"
      },
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Reference to geometry variable"
      },
      "mode": {
        "type": "string",
        "default": "line'      // 'line' (curve growth) or 'mesh' (surface folding)"
      },
      "smoothing": {
        "type": "number",
        "default": 0.5
      }
    },
    "code": "const { \n        geometry, \n        iterations = 20, \n        repulsionRadius = 0.5, \n        growthForce = 0.1, // Expansion speed\n        smoothing = 0.5,   // Laplacian smoothing strength\n        mode = 'line'      // 'line' (curve growth) or 'mesh' (surface folding)\n    } = params;\n\n    // ========================================================================\n    // MODE 1: LINE / RIBBON (Previous Implementation)\n    // ========================================================================\n    if (mode === 'line' || !geometry || !geometry.isBufferGeometry) {\n        // ... (Keep your existing Line/Ribbon logic here) ...\n        // [Paste the previous curve-based logic if you want to keep it]\n        return new THREE.BufferGeometry(); \n    }\n\n    // ========================================================================\n    // MODE 2: MESH SURFACE GROWTH (New)\n    // ========================================================================\n    // Clone to avoid modifying original\n    const geom = geometry.clone();\n    \n    // Ensure we have topological data (Index)\n    if (!geom.index) {\n        geom = BufferGeometryUtils.mergeVertices(geom); // Create index if missing\n    }\n    \n    const positions = geom.attributes.position;\n    const normals = geom.attributes.normal;\n    const vertexCount = positions.count;\n\n    // 1. Build Adjacency Graph (Neighbor lookup)\n    // This is expensive but needed for smoothing\n    const neighbors = new Array(vertexCount).fill(0).map(() => []);\n    const index = geom.index.array;\n    for (let i = 0; i < index.length; i += 3) {\n        const a = index[i], b = index[i+1], c = index[i+2];\n        if(!neighbors[a].includes(b)) neighbors[a].push(b);\n        if(!neighbors[a].includes(c)) neighbors[a].push(c);\n        if(!neighbors[b].includes(a)) neighbors[b].push(a);\n        if(!neighbors[b].includes(c)) neighbors[b].push(c);\n        if(!neighbors[c].includes(a)) neighbors[c].push(a);\n        if(!neighbors[c].includes(b)) neighbors[c].push(b);\n    }\n\n    // 2. Simulation Loop\n    const tempPos = new Float32Array(positions.array);\n    const p = new THREE.Vector3();\n    const n = new THREE.Vector3();\n    const neighborP = new THREE.Vector3();\n    const avgP = new THREE.Vector3();\n    \n    for (let iter = 0; iter < iterations; iter++) {\n        \n        for (let i = 0; i < vertexCount; i++) {\n            p.set(tempPos[i*3], tempPos[i*3+1], tempPos[i*3+2]);\n            n.set(normals.getX(i), normals.getY(i), normals.getZ(i));\n\n            // A. Laplacian Smoothing (Relaxation)\n            // Pull vertex towards average of neighbors to remove spikes\n            avgP.set(0,0,0);\n            const myNeighbors = neighbors[i];\n            if (myNeighbors.length === 0) continue;\n            \n            for(const nid of myNeighbors) {\n                neighborP.set(tempPos[nid*3], tempPos[nid*3+1], tempPos[nid*3+2]);\n                avgP.add(neighborP);\n            }\n            avgP.divideScalar(myNeighbors.length);\n            \n            // Vector to average\n            const smoothVec = avgP.sub(p); \n            \n            // B. Growth / Buckling Force\n            // We push vertices OUT along their normal, but constrained by smoothing.\n            // The conflict between expanding (Normal) and staying connected (Smooth) creates folds.\n            \n            // Tangential Repulsion approximation:\n            // If neighbors are too close, push away? \n            // For simple folding, just expanding surface area works well.\n            \n            // Apply forces\n            p.addScaledVector(smoothVec, smoothing); // Pull together\n            p.addScaledVector(n, growthForce);       // Push out (Expand)\n            \n            // Optional: Collision/Self-intersection check is too slow for JS\n            \n            // Store result\n            positions.setXYZ(i, p.x, p.y, p.z);\n        }\n        \n        // Recompute normals every few frames to guide growth\n        if (iter % 2 === 0) {\n            geom.computeVertexNormals();\n        }\n        \n        // Update temp array for next step dependency\n        for(let k=0; k<positions.array.length; k++) tempPos[k] = positions.array[k];\n    }\n\n    positions.needsUpdate = true;\n    geom.computeVertexNormals();\n    return geom;",
    "outputType": "Geometry"
  },
 {
  "id": "differentialSurfaceGrowth3D",
  "name": "differentialSurfaceGrowth3D",
  "description": "Complex 3D surface growth with normal-constrained movement. Points grow perpendicular to surface while maintaining local topology. Simulates biological growth and structural swelling in volumetric forms.",
  "category": "Organic Growth",
  "paramsSchema": {
    "inputGeometry": {
      "type": "string",
      "default": "params.geometry"
    },
    "iterations": {
      "type": "number",
      "default": 45
    },
    "maxEdgeLength": {
      "type": "number",
      "default": 1.8
    },
    "minEdgeLength": {
      "type": "number",
      "default": 0.5
    },
    "repulsionRadius": {
      "type": "number",
      "default": 1.4
    },
    "repulsionStrength": {
      "type": "number",
      "default": 0.5
    },
    "springStiffness": {
      "type": "number",
      "default": 0.2
    },
    "boundaryGrowthPush": {
      "type": "number",
      "default": 0.15
    },
    "dt": {
      "type": "number",
      "default": 0.04
    },
    "maxVertices": {
      "type": "number",
      "default": 30000
    },
    "maxVelocity": {
      "type": "number",
      "default": 0.5
    },
    "initialJitter": {
      "type": "number",
      "default": 0.02
    }
  },
  "code": "// --- 1. INPUT HANDLING & ORIENTATION FIX ---\nlet inputGeometry = params.inputGeometry || params.geometry;\nif (inputGeometry && inputGeometry.isObject3D && inputGeometry.geometry) {\n  inputGeometry = inputGeometry.geometry;\n}\nif (!inputGeometry || !inputGeometry.isBufferGeometry) {\n  console.error(\"differentialSurfaceGrowth3D: Invalid geometry.\");\n  return new THREE.BufferGeometry();\n}\n\n// CLONE & ROTATE: Ensure we start flat on the XZ plane (Horizontal)\n// Three.js CircleGeometry defaults to XY plane (facing Z).\n// We rotate it -90 deg around X to make it lie flat on XZ.\nconst workingGeometry = inputGeometry.clone();\nworkingGeometry.rotateX(-Math.PI / 2);\n// Now Y is \"Up\".\n\n// --- 2. CONFIGURATION ---\nconst {\n  iterations = 50,\n  maxEdgeLength = 0.2,\n  minEdgeLength = 0.05,\n  repulsionRadius = 0.25,\n  repulsionStrength = 1.0,\n  springStiffness = 0.4,\n  boundaryGrowthPush = 0.2,\n  dt = 0.04,\n  maxVertices = 30000,\n  maxVelocity = 0.5,\n  initialJitter = 0.02,\n\n  // Symmetric (deterministic) buckling controls (used when initialJitter === 0)\n  symmetryLobes = 6,\n  symmetryBucklingAmp = 0.03\n} = params;\n\n// Symmetry mode = no randomness; still allow buckling via deterministic field\nconst keepSymmetry = (initialJitter === 0);\n\n// Split cap: unlimited when preserving symmetry, default cap otherwise.\nconst MAX_SPLITS_DEFAULT = 200;\nconst MAX_SPLITS = keepSymmetry ? Number.MAX_SAFE_INTEGER : MAX_SPLITS_DEFAULT;\n\n// --- 3. DATA INITIALIZATION ---\nlet nodes = [];\nlet faces = [];\n\nconst posAttr = workingGeometry.attributes.position;\nconst indexAttr = workingGeometry.index;\n\n// Import Nodes\nfor (let i = 0; i < posAttr.count; i++) {\n  const x = posAttr.getX(i);\n  const y = posAttr.getY(i);\n  const z = posAttr.getZ(i);\n\n  // If keepSymmetry: deterministic N-fold radial buckling on Y\n  // Else: the original random jitter\n  let jitterY = 0;\n  if (keepSymmetry) {\n    const theta = Math.atan2(z, x);\n    jitterY = symmetryBucklingAmp * Math.sin(symmetryLobes * theta);\n  } else {\n    jitterY = (Math.random() - 0.5) * initialJitter * 2.0;\n  }\n\n  nodes.push({\n    x: x,\n    y: y + jitterY,\n    z: z,\n    vx: 0, vy: 0, vz: 0,\n    fx: 0, fy: 0, fz: 0,\n    isBoundary: false\n  });\n}\n\n// Import Faces\nif (indexAttr) {\n  for (let i = 0; i < indexAttr.count; i += 3) {\n    faces.push([indexAttr.getX(i), indexAttr.getY(i), indexAttr.getZ(i)]);\n  }\n} else {\n  for (let i = 0; i < posAttr.count; i += 3) {\n    faces.push([i, i + 1, i + 2]);\n  }\n}\n\n// Spatial Hash\nclass SpatialHash {\n  constructor(cellSize) {\n    this.cellSize = cellSize;\n    this.cells = new Map();\n  }\n  key(x, y, z) {\n    return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)},${Math.floor(z / this.cellSize)}`;\n  }\n  add(idx, x, y, z) {\n    const k = this.key(x, y, z);\n    if (!this.cells.has(k)) this.cells.set(k, []);\n    this.cells.get(k).push(idx);\n  }\n  query(x, y, z) {\n    const k = this.key(x, y, z);\n    const parts = k.split(',').map(Number);\n    const cx = parts[0], cy = parts[1], cz = parts[2];\n    const neighbors = [];\n    for (let i = cx - 1; i <= cx + 1; i++) {\n      for (let j = cy - 1; j <= cy + 1; j++) {\n        for (let l = cz - 1; l <= cz + 1; l++) {\n          const cell = this.cells.get(`${i},${j},${l}`);\n          if (cell) neighbors.push(...cell);\n        }\n      }\n    }\n    return neighbors;\n  }\n}\n\n// --- SIMULATION LOOP ---\nconsole.time(\"Differential Growth\");\n\nfor (let iter = 0; iter < iterations; iter++) {\n  if (nodes.length >= maxVertices) break;\n\n  // A. TOPOLOGY\n  const edgeMap = new Map();\n  nodes.forEach(n => n.isBoundary = false);\n\n  faces.forEach((f, fIdx) => {\n    const edges = [[f[0], f[1]], [f[1], f[2]], [f[2], f[0]]];\n    edges.forEach(([a, b]) => {\n      const key = a < b ? `${a},${b}` : `${b},${a}`;\n      if (!edgeMap.has(key)) edgeMap.set(key, []);\n      edgeMap.get(key).push(fIdx);\n    });\n  });\n\n  for (const entry of edgeMap.entries()) {\n    const key = entry[0];\n    const fIndices = entry[1];\n    if (fIndices.length === 1) {\n      const parts = key.split(',').map(Number);\n      const u = parts[0], v = parts[1];\n      nodes[u].isBoundary = true;\n      nodes[v].isBoundary = true;\n    }\n  }\n\n  // B. PHYSICS\n  const spatialHash = new SpatialHash(repulsionRadius);\n  nodes.forEach((n, i) => {\n    n.fx = 0; n.fy = 0; n.fz = 0;\n    spatialHash.add(i, n.x, n.y, n.z);\n  });\n\n  // 1. Repulsion\n  for (let i = 0; i < nodes.length; i++) {\n    const n = nodes[i];\n    const neighbors = spatialHash.query(n.x, n.y, n.z);\n    for (const otherIdx of neighbors) {\n      if (otherIdx === i) continue;\n      const other = nodes[otherIdx];\n      const dx = n.x - other.x;\n      const dy = n.y - other.y;\n      const dz = n.z - other.z;\n      const d2 = dx*dx + dy*dy + dz*dz;\n      if (d2 < repulsionRadius*repulsionRadius && d2 > 1e-6) {\n        const d = Math.sqrt(d2);\n        const f = (repulsionRadius - d) / d * repulsionStrength;\n        n.fx += dx * f; n.fy += dy * f; n.fz += dz * f;\n      }\n    }\n  }\n\n  // 2. Springs & Boundary Push\n  for (const entry of edgeMap.entries()) {\n    const key = entry[0];\n    const fIndices = entry[1];\n\n    const parts = key.split(',').map(Number);\n    const u = parts[0], v = parts[1];\n\n    const n1 = nodes[u], n2 = nodes[v];\n    const dx = n2.x - n1.x;\n    const dy = n2.y - n1.y;\n    const dz = n2.z - n1.z;\n    const d = Math.sqrt(dx*dx + dy*dy + dz*dz);\n\n    if (d > 1e-6) {\n      const isBoundary = (fIndices.length === 1);\n      const targetLen = isBoundary ? maxEdgeLength * 1.1 : minEdgeLength;\n      const force = (d - targetLen) * springStiffness;\n\n      const fx = (dx / d) * force;\n      const fy = (dy / d) * force;\n      const fz = (dz / d) * force;\n\n      n1.fx += fx; n1.fy += fy; n1.fz += fz;\n      n2.fx -= fx; n2.fy -= fy; n2.fz -= fz;\n\n      if (isBoundary && boundaryGrowthPush > 0) {\n        const push = boundaryGrowthPush;\n        n2.fx += (dx / d) * push; n2.fy += (dy / d) * push; n2.fz += (dz / d) * push;\n        n1.fx -= (dx / d) * push; n1.fy -= (dy / d) * push; n1.fz -= (dz / d) * push;\n      }\n    }\n  }\n\n  // 3. Integrate\n  const maxVelSq = maxVelocity * maxVelocity;\n  for (let i = 0; i < nodes.length; i++) {\n    const n = nodes[i];\n    n.vx = (n.vx + n.fx * dt) * 0.9;\n    n.vy = (n.vy + n.fy * dt) * 0.9;\n    n.vz = (n.vz + n.fz * dt) * 0.9;\n\n    const vSq = n.vx*n.vx + n.vy*n.vy + n.vz*n.vz;\n    if (vSq > maxVelSq) {\n      const s = maxVelocity / Math.sqrt(vSq);\n      n.vx *= s; n.vy *= s; n.vz *= s;\n    }\n\n    n.x += n.vx;\n    n.y += n.vy;\n    n.z += n.vz;\n  }\n\n  // C. GROWTH\n  const edgesToSplit = [];\n  for (const entry of edgeMap.entries()) {\n    const key = entry[0];\n    const fIndices = entry[1];\n\n    const parts = key.split(',').map(Number);\n    const u = parts[0], v = parts[1];\n\n    const n1 = nodes[u], n2 = nodes[v];\n    const ddx = n1.x - n2.x;\n    const ddy = n1.y - n2.y;\n    const ddz = n1.z - n2.z;\n    const d2 = ddx*ddx + ddy*ddy + ddz*ddz;\n\n    if (d2 > maxEdgeLength * maxEdgeLength) {\n      edgesToSplit.push({ key, u, v, fIndices, isBoundary: fIndices.length === 1 });\n    }\n  }\n\n  // Deterministic ordering so a cap doesn't bias one side\n  edgesToSplit.sort((a, b) => {\n    if (a.isBoundary !== b.isBoundary) return (b.isBoundary ? 1 : 0) - (a.isBoundary ? 1 : 0);\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  });\n\n  const processedFaces = new Set();\n  const facesToRemove = new Set();\n  const facesToAdd = [];\n  let splitsDone = 0;\n\n  for (const split of edgesToSplit) {\n    if (splitsDone >= MAX_SPLITS) break;\n    if (split.fIndices.some(fIdx => processedFaces.has(fIdx))) continue;\n\n    const u = split.u;\n    const v = split.v;\n    const fIndices = split.fIndices;\n\n    const n1 = nodes[u], n2 = nodes[v];\n\n    // Deterministic symmetric buckle when keepSymmetry (still pushes out of plane)\n    let buckle = 0;\n    if (keepSymmetry) {\n      const mx = (n1.x + n2.x) * 0.5;\n      const mz = (n1.z + n2.z) * 0.5;\n      const thetaMid = Math.atan2(mz, mx);\n      buckle = symmetryBucklingAmp * Math.sin(symmetryLobes * thetaMid);\n    } else {\n      buckle = (Math.random() - 0.5) * 0.05;\n    }\n\n    nodes.push({\n      x: (n1.x + n2.x) * 0.5,\n      y: (n1.y + n2.y) * 0.5 + buckle,\n      z: (n1.z + n2.z) * 0.5,\n      vx: (n1.vx + n2.vx) * 0.5,\n      vy: (n1.vy + n2.vy) * 0.5,\n      vz: (n1.vz + n2.vz) * 0.5,\n      fx: 0, fy: 0, fz: 0,\n      isBoundary: n1.isBoundary && n2.isBoundary\n    });\n\n    const midIdx = nodes.length - 1;\n\n    for (const fIdx of fIndices) {\n      processedFaces.add(fIdx);\n      facesToRemove.add(fIdx);\n\n      const oldFace = faces[fIdx];\n      const t1 = oldFace.slice();\n      const t2 = oldFace.slice();\n\n      t1[t1.indexOf(v)] = midIdx;\n      t2[t2.indexOf(u)] = midIdx;\n\n      facesToAdd.push(t1, t2);\n    }\n\n    splitsDone++;\n  }\n\n  if (facesToAdd.length > 0) {\n    const nextFaces = [];\n    for (let i = 0; i < faces.length; i++) {\n      if (!facesToRemove.has(i)) nextFaces.push(faces[i]);\n    }\n    faces = nextFaces.concat(facesToAdd);\n  }\n}\n\nconsole.timeEnd(\"Differential Growth\");\n\n// --- EXPORT ---\nconst newGeo = new THREE.BufferGeometry();\nconst positions = new Float32Array(nodes.length * 3);\nfor (let i = 0; i < nodes.length; i++) {\n  positions[i*3] = nodes[i].x;\n  positions[i*3+1] = nodes[i].y;\n  positions[i*3+2] = nodes[i].z;\n}\n\nconst indices = [];\nfor (const f of faces) indices.push(f[0], f[1], f[2]);\n\nnewGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));\nnewGeo.setIndex(indices);\nnewGeo.computeVertexNormals();\nnewGeo.computeBoundingSphere();\n\nreturn newGeo;",
  "outputType": "Geometry"
}
,
  {
    "id": "buckleGeometry",
    "name": "buckleGeometry",
    "description": "Buckling instability simulation under compression. Adds sinusoidal perturbations along compression axis with amplitude scaled by compression ratio. Used for studying structural failure modes and creased forms.",
    "category": "Deformation",
    "paramsSchema": {},
    "code": "let {\n        geometry,\n        iterations = 50,\n        expansion = 1.01,        // Target edge length multiplier (1.01 = 1% growth)\n        constraints = 'boundary', // 'boundary' (lock edges), 'center' (lock center), 'none'\n        noiseAmount = 0.1,       // Initial perturbation\n        smoothness = 0.5,        // Laplacian smoothing strength\n        dt = 0.2                 // Time step\n    } = params;\n\n    if (!geometry || !geometry.isBufferGeometry) return new THREE.BufferGeometry();\n\n    // Clone geometry to avoid mutating the original source if cached\n    const geo = geometry.clone();\n    const posAttr = geo.attributes.position;\n    const count = posAttr.count;\n\n    // 1. Build Adjacency (Neighbors)\n    // We need this to run physics\n    const neighbors = Array.from({length: count}, () => []);\n    const edges = [];\n    \n    // Read edges from index or implicit\n    const addEdge = (a, b) => {\n        neighbors[a].push(b);\n        neighbors[b].push(a);\n        edges.push([a, b]); // Store unique edge for length constraint\n    };\n\n    if (geo.index) {\n        const idx = geo.index;\n        for (let i = 0; i < idx.count; i += 3) {\n            const a = idx.getX(i), b = idx.getY(i), c = idx.getZ(i);\n            addEdge(a, b); addEdge(b, c); addEdge(c, a);\n        }\n    } else {\n        for (let i = 0; i < count; i += 3) {\n            addEdge(i, i+1); addEdge(i+1, i+2); addEdge(i+2, i);\n        }\n    }\n\n    // 2. Initialize Physics State\n    const nodes = [];\n    for (let i = 0; i < count; i++) {\n        const x = posAttr.getX(i);\n        const y = posAttr.getY(i);\n        const z = posAttr.getZ(i);\n        \n        // Detect Constraints\n        let isFixed = false;\n        const dist = Math.sqrt(x*x + y*y + z*z);\n        \n        if (constraints === 'boundary') {\n            // Naive boundary check: nodes with fewer neighbors often boundary\n            // Or check distance from center for Circle/Plane\n            if (dist > 4.8) isFixed = true; // Assuming Radius 5 circle\n        } else if (constraints === 'center') {\n            if (dist < 1.0) isFixed = true;\n        }\n\n        nodes.push({\n            x, y, \n            // Add noise to Z to break symmetry and allow buckling\n            z: z + (Math.random() - 0.5) * noiseAmount, \n            vx: 0, vy: 0, vz: 0,\n            isFixed\n        });\n    }\n\n    // Pre-calculate Rest Lengths (The \"Target\" Lengths)\n    // We set the target length to be LARGER than current length to force buckling\n    const edgeConstraints = edges.map(([a, b]) => {\n        const na = nodes[a], nb = nodes[b];\n        const curLen = Math.sqrt((na.x-nb.x)**2 + (na.y-nb.y)**2 + (na.z-nb.z)**2);\n        return { a, b, target: curLen * expansion };\n    });\n\n    console.log(`Starting Buckle Sim: ${count} verts, ${iterations} steps`);\n\n    // 3. Simulation Loop\n    for (let iter = 0; iter < iterations; iter++) {\n        \n        // A. Expansion Constraints (The \"Growth\")\n        for (const {a, b, target} of edgeConstraints) {\n            const na = nodes[a];\n            const nb = nodes[b];\n            \n            const dx = na.x - nb.x;\n            const dy = na.y - nb.y;\n            const dz = na.z - nb.z;\n            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);\n            \n            if (dist === 0) continue;\n\n            // Hooke's Law / Constraint Projection\n            // We want dist to become target.\n            // Force pushes them apart if dist < target\n            const diff = (dist - target) / dist; // Normalized error\n            \n            // Apply half to A, half to B\n            const moveX = dx * diff * 0.5;\n            const moveY = dy * diff * 0.5;\n            const moveZ = dz * diff * 0.5;\n\n            if (!na.isFixed) { na.x -= moveX; na.y -= moveY; na.z -= moveZ; }\n            if (!nb.isFixed) { nb.x += moveX; nb.y += moveY; nb.z += moveZ; }\n        }\n\n        // B. Smoothing (The \"Fabric\" Feel)\n        // Without this, it looks like noise. With this, it looks like cloth.\n        const tempNodes = nodes.map(n => ({...n})); // Snapshot positions\n        \n        for (let i = 0; i < count; i++) {\n            const n = nodes[i];\n            if (n.isFixed) continue;\n\n            let avgX=0, avgY=0, avgZ=0, c=0;\n            for (const neighborIdx of neighbors[i]) {\n                const nb = tempNodes[neighborIdx];\n                avgX += nb.x;\n                avgY += nb.y;\n                avgZ += nb.z;\n                c++;\n            }\n            \n            if (c > 0) {\n                // Move towards average\n                n.x += (avgX/c - n.x) * smoothness;\n                n.y += (avgY/c - n.y) * smoothness;\n                n.z += (avgZ/c - n.z) * smoothness;\n            }\n        }\n    }\n\n    // 4. Update Geometry\n    for (let i = 0; i < count; i++) {\n        posAttr.setXYZ(i, nodes[i].x, nodes[i].y, nodes[i].z);\n    }\n    \n    posAttr.needsUpdate = true;\n    geo.computeVertexNormals();\n    \n    return geo;",
    "outputType": "Geometry"
  },
  {
    "id": "meshFromVoxelGrid",
    "name": "meshFromVoxelGrid",
    "description": "Converts a grid of voxels (3D pixels) into a surface mesh. Useful when you have volumetric data (from cellular automata, reaction-diffusion, or 3D imaging) and need to visualize the boundary surface. The algorithm finds which voxels are inside vs outside, then triangulates the boundary.",
    "category": "Distribution",
    "paramsSchema": {
      "grid": {
        "type": "string",
        "default": "",
        "description": "Voxel grid variable name (3D array or flat array from cellularAutomata, reactionDiffusion, etc.)"
      },
      "voxelSize": {
        "type": "number",
        "default": 1,
        "description": "Size of each individual voxel cube"
      },
      "size": {
        "type": "array",
        "default": [
          10,
          10,
          10
        ],
        "description": "Grid dimensions [width, height, depth] - auto-inferred if not provided"
      }
    },
    "code": "let { grid, voxelSize = 1, size = null } = params;\n\n    // --- 1. STANDARDIZE INPUT (Universal Accessor) ---\n    let accessFn, sizeX, sizeY, sizeZ;\n\n    // DEBUG: Identify what we actually got\n    // console.log(\"meshFromVoxelGrid input:\", grid?.constructor?.name || typeof grid);\n\n    // CASE A: Wrapped Object (userData pattern)\n    if (grid && grid.userData) {\n        const data = grid.userData;\n        // If it contains a grid, extract it and recurse/continue\n        if (data.grid) {\n            grid = data.grid;\n            if (data.size) size = data.size;\n            if (data.voxelSize) voxelSize = data.voxelSize;\n        }\n    }\n\n    // CASE B: Raw Flat Array (Float32Array, Uint8Array, or flat Array)\n    // This often happens if the executor auto-unwraps the 'grid' property\n    if (grid instanceof Float32Array || grid instanceof Uint8Array || (Array.isArray(grid) && !Array.isArray(grid[0]))) {\n        const len = grid.length;\n        \n        // 1. Use explicit size if provided\n        if (size) {\n            sizeX = Array.isArray(size) ? size[0] : size;\n            sizeY = Array.isArray(size) ? size[1] : size;\n            sizeZ = Array.isArray(size) ? size[2] : size;\n        } \n        // 2. Auto-infer cubic size\n        else {\n            const cubicRoot = Math.round(Math.pow(len, 1/3));\n            if (Math.abs(cubicRoot * cubicRoot * cubicRoot - len) < 1) {\n                sizeX = sizeY = sizeZ = cubicRoot;\n                // console.log(`meshFromVoxelGrid: Inferred cubic size ${sizeX}`);\n            } else {\n                console.warn(`meshFromVoxelGrid: Array length ${len} is not cubic. Result may be skewed.`);\n                sizeX = sizeY = sizeZ = Math.floor(Math.pow(len, 1/3));\n            }\n        }\n\n        // Accessor: Flat index logic\n        // Check > 0.1 to filter out near-zero noise\n        accessFn = (x, y, z) => grid[x + y*sizeX + z*sizeX*sizeY] > 0.1; \n    }\n\n    // CASE C: Standard Nested 3D Array ([[[]]])\n    else if (Array.isArray(grid) && Array.isArray(grid[0])) {\n        // Use resolver or manual check\n        const resolved = resolveVoxelGrid(grid);\n        if (resolved) {\n            sizeX = resolved.length;\n            sizeY = resolved[0]?.length || 0;\n            sizeZ = resolved[0]?.[0]?.length || 0;\n            accessFn = (x, y, z) => resolved[x][y][z];\n        }\n    }\n\n    if (!accessFn) {\n        console.warn(\"meshFromVoxelGrid: Invalid input format. Returning empty geometry.\");\n        return new THREE.BufferGeometry();\n    }\n\n    // --- 2. FAST GEOMETRY GENERATION (Constructive) ---\n    const vertices = [];\n    const normals = [];\n    const indices = [];\n    let vertexCount = 0;\n\n    const hs = voxelSize / 2; // Half size\n    \n    // Pre-calculated cube data\n    const corners = [\n        [-hs, -hs,  hs], [ hs, -hs,  hs], [ hs,  hs,  hs], [-hs,  hs,  hs], // Front (0,1,2,3)\n        [-hs, -hs, -hs], [-hs,  hs, -hs], [ hs,  hs, -hs], [ hs, -hs, -hs]  // Back  (4,5,6,7)\n    ];\n\n    // Face definitions: [c1, c2, c3, c4, normal]\n    const faces = [\n        [0, 1, 2, 3, [ 0,  0,  1]], // Front\n        [1, 7, 6, 2, [ 1,  0,  0]], // Right\n        [7, 4, 5, 6, [ 0,  0, -1]], // Back\n        [4, 0, 3, 5, [-1,  0,  0]], // Left\n        [3, 2, 6, 5, [ 0,  1,  0]], // Top\n        [4, 7, 1, 0, [ 0, -1,  0]]  // Bottom\n    ];\n\n    const offsetX = -sizeX * voxelSize / 2;\n    const offsetY = -sizeY * voxelSize / 2;\n    const offsetZ = -sizeZ * voxelSize / 2;\n\n    for (let x = 0; x < sizeX; x++) {\n        for (let y = 0; y < sizeY; y++) {\n            for (let z = 0; z < sizeZ; z++) {\n                \n                if (accessFn(x, y, z)) {\n                    const cx = offsetX + x * voxelSize + hs;\n                    const cy = offsetY + y * voxelSize + hs;\n                    const cz = offsetZ + z * voxelSize + hs;\n\n                    // Neighbor Checks for Culling\n                    // (Boundary checks included in condition)\n                    const neighbors = [\n                        z < sizeZ-1 && accessFn(x,y,z+1), // Front\n                        x < sizeX-1 && accessFn(x+1,y,z), // Right\n                        z > 0       && accessFn(x,y,z-1), // Back\n                        x > 0       && accessFn(x-1,y,z), // Left\n                        y < sizeY-1 && accessFn(x,y+1,z), // Top\n                        y > 0       && accessFn(x,y-1,z)  // Bottom\n                    ];\n\n                    for (let f = 0; f < 6; f++) {\n                        // Cull internal faces\n                        if (neighbors[f]) continue;\n\n                        const [c1, c2, c3, c4, n] = faces[f];\n                        \n                        // Push Vertices\n                        vertices.push(\n                            cx + corners[c1][0], cy + corners[c1][1], cz + corners[c1][2],\n                            cx + corners[c2][0], cy + corners[c2][1], cz + corners[c2][2],\n                            cx + corners[c3][0], cy + corners[c3][1], cz + corners[c3][2],\n                            cx + corners[c4][0], cy + corners[c4][1], cz + corners[c4][2]\n                        );\n\n                        // Push Normals\n                        for(let i=0; i<4; i++) normals.push(n[0], n[1], n[2]);\n\n                        // Push Indices\n                        indices.push(\n                            vertexCount, vertexCount + 1, vertexCount + 2,\n                            vertexCount, vertexCount + 2, vertexCount + 3\n                        );\n\n                        vertexCount += 4;\n                    }\n                }\n            }\n        }\n    }\n\n    const geometry = new THREE.BufferGeometry();\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n    geometry.setIndex(indices);\n\n    return geometry;",
    "outputType": "Geometry"
  },
  {
    "id": "pointSetCentroid",
    "name": "pointSetCentroid",
    "description": "Computes center of mass from point cloud. Simple average of all positions. Utility for geometric center calculation and coordinate transformation.",
    "category": "Complex Algorithms",
    "paramsSchema": {
      "points": {
        "type": "string",
        "default": "",
        "description": "Reference to points variable"
      }
    },
    "code": "const { points } = params;\n\n    if (!points || points.length === 0) return new THREE.Vector3();\n\n    const centroid = new THREE.Vector3();\n    for (const p of points) {\n        const vec = Array.isArray(p) ? new THREE.Vector3(...p) : p;\n        centroid.add(vec);\n    }\n\n    centroid.divideScalar(points.length);\n    return centroid;",
    "outputType": "Data"
  },
  {
    "id": "pointSetBoundingBox",
    "name": "pointSetBoundingBox",
    "description": "Alias for boundingBox - computes AABB from point set returning min/max corners.",
    "category": "Basic Geometry",
    "paramsSchema": {
      "points": {
        "type": "string",
        "default": "",
        "description": "Reference to points variable"
      }
    },
    "code": "const { points } = params;\n\n    if (!points || points.length === 0) return new THREE.Box3();\n\n    const box = new THREE.Box3();\n    for (const p of points) {\n        const vec = Array.isArray(p) ? new THREE.Vector3(...p) : p;\n        box.expandByPoint(vec);\n    }\n\n    return box;",
    "outputType": "Data"
  },
  {
    "id": "closestPointOnCurve",
    "name": "closestPointOnCurve",
    "description": "Nearest point on curve to given target point via uniform sampling. O(samples) complexity for typical geometries. Used for snapping, constraint projection, and closest-point queries.",
    "category": "Curves & Paths",
    "paramsSchema": {
      "samples": {
        "type": "number",
        "default": 100
      },
      "curve": {
        "type": "string",
        "default": "",
        "description": "Reference to curve variable"
      },
      "point": {
        "type": "string",
        "default": "",
        "description": "Reference to point variable"
      }
    },
    "code": "const { curve, point, samples = 100 } = params;\n\n    if (!curve || !point) return new THREE.Vector3();\n\n    // \u2705 RESOLVER: Handle wrapped curves\n    const resolvedCurve = resolveCurve(curve);\n    if (!resolvedCurve) return new THREE.Vector3();\n\n    const targetPoint = Array.isArray(point) ? new THREE.Vector3(...point) : point;\n    let closestPoint = resolvedCurve.getPoint(0);\n    let minDist = closestPoint.distanceTo(targetPoint);\n\n    for (let i = 1; i <= samples; i++) {\n        const t = i / samples;\n        const p = resolvedCurve.getPoint(t);\n        const dist = p.distanceTo(targetPoint);\n\n        if (dist < minDist) {\n            minDist = dist;\n            closestPoint = p;\n        }\n    }\n\n    return closestPoint;",
    "outputType": "Data"
  },
  {
    "id": "signedDistanceToMesh",
    "name": "signedDistanceToMesh",
    "description": "Signed distance estimation from point to mesh surface using ray casting. Raycaster method counts intersections to determine inside/outside. Used for level-set computations and inside/outside testing.",
    "category": "Complex Algorithms",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Reference to geometry variable"
      },
      "point": {
        "type": "string",
        "default": "",
        "description": "Reference to point variable"
      }
    },
    "code": "const { geometry, point } = params;\n\n    if (!geometry || !point) return 0;\n\n    const targetPoint = Array.isArray(point) ? new THREE.Vector3(...point) : point;\n    const raycaster = new THREE.Raycaster(targetPoint, new THREE.Vector3(1, 0, 0));\n    const tempMesh = new THREE.Mesh(geometry);\n    const intersects = raycaster.intersectObject(tempMesh);\n\n    if (intersects.length === 0) return Infinity;\n\n    const closestDist = intersects[0].distance;\n    return intersects.length % 2 === 0 ? closestDist : -closestDist;",
    "outputType": "Data"
  },
  {
    "id": "measureVolume",
    "name": "measureVolume",
    "description": "Volume calculation via divergence theorem (signed volume summation over faces). Computes geometric volume of closed mesh. Used for material quantity estimation and structural analysis.",
    "category": "Complex Algorithms",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Reference to geometry variable"
      }
    },
    "code": "const { geometry } = params;\n\n    if (!geometry) return 0;\n\n    let volume = 0;\n    const positions = geometry.attributes.position;\n    const index = geometry.index;\n\n    if (index) {\n        for (let i = 0; i < index.count; i += 3) {\n            const a = index.getX(i), b = index.getX(i+1), c = index.getX(i+2);\n            const v1 = new THREE.Vector3(positions.getX(a), positions.getY(a), positions.getZ(a));\n            const v2 = new THREE.Vector3(positions.getX(b), positions.getY(b), positions.getZ(b));\n            const v3 = new THREE.Vector3(positions.getX(c), positions.getY(c), positions.getZ(c));\n            volume += v1.dot(new THREE.Vector3().crossVectors(v2, v3)) / 6;\n        }\n    }\n\n    return Math.abs(volume);",
    "outputType": "Data"
  },
  {
    "id": "measureArea",
    "name": "measureArea",
    "description": "Surface area calculation by summing triangle areas via cross-product magnitude. O(n) complexity for n triangles. Used for material budgeting and thermal analysis.",
    "category": "Complex Algorithms",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Reference to geometry variable"
      }
    },
    "code": "const { geometry } = params;\n\n    if (!geometry) return 0;\n\n    let area = 0;\n    const positions = geometry.attributes.position;\n    const index = geometry.index;\n\n    if (index) {\n        for (let i = 0; i < index.count; i += 3) {\n            const a = index.getX(i), b = index.getX(i+1), c = index.getX(i+2);\n            const v1 = new THREE.Vector3(positions.getX(a), positions.getY(a), positions.getZ(a));\n            const v2 = new THREE.Vector3(positions.getX(b), positions.getY(b), positions.getZ(b));\n            const v3 = new THREE.Vector3(positions.getX(c), positions.getY(c), positions.getZ(c));\n            const edge1 = v2.clone().sub(v1);\n            const edge2 = v3.clone().sub(v1);\n            area += edge1.cross(edge2).length() / 2;\n        }\n    }\n\n    return area;",
    "outputType": "Data"
  },
  {
  "id": "subdivisionSurface",
  "name": "subdivisionSurface",
  "description": "Mesh smoothing via Catmull-Clark subdivision. Recursively refines geometry while preserving original shape in limit. Used for creating smooth surfaces from coarse control meshes (NURBS approximation). Requires SubdivisionModifier from three/examples.",
  "category": "Complex Algorithms",
  "paramsSchema": {
    "geometry": {
      "type": "string",
      "default": "",
      "description": "Reference to geometry variable"
    },
    "iterations": {
      "type": "number",
      "default": 1,
      "description": "Number of subdivision iterations (1-3 typical, higher = smoother but slower)"
    }
  },
  "code": "const geometry = params.geometry; const rawIterations = params.iterations ?? 1; const iterations = Math.max(0, Math.min(3, Math.floor(rawIterations))); if (!geometry) { if (helpers && helpers.log) { helpers.log('warn', 'subdivisionSurface: No geometry provided'); } return new THREE.BufferGeometry(); } let geom = geometry.isBufferGeometry ? geometry.clone() : geometry; if (!geom.isBufferGeometry) { if (helpers && helpers.log) { helpers.log('error', 'subdivisionSurface: Input is not a BufferGeometry'); } return new THREE.BufferGeometry(); } if (geom.index) { try { geom = BufferGeometryUtils.mergeVertices(geom); } catch (e) { if (helpers && helpers.log) { helpers.log('warn', 'subdivisionSurface: mergeVertices failed: ' + e.message); } } } const posAttr = geom.attributes && geom.attributes.position; const vertexCount = posAttr ? posAttr.count : 0; let safeIterations = iterations; if (vertexCount > 30000 && iterations > 1) { safeIterations = 1; if (helpers && helpers.log) { helpers.log('warn', 'subdivisionSurface: High vertex count (' + vertexCount + '), clamping iterations to 1'); } } try { const result = LoopSubdivision.modify(geom, safeIterations); if (result && result.computeVertexNormals) { result.computeVertexNormals(); } if (helpers && helpers.log) { helpers.log('info', 'subdivisionSurface: Subdivided ' + vertexCount + ' verts with ' + safeIterations + ' iterations'); } return result; } catch (e) { if (helpers && helpers.log) { helpers.log('error', 'subdivisionSurface: Subdivision failed: ' + e.message); } return geom; }",
  "outputType": "Geometry"
},
  {
    "id": "voronoiDivision",
    "name": "voronoiDivision",
    "description": "Voronoi diagram generation from seed points creating space partition. Each region contains all points closer to seed than any other seed. Used for cellular patterns, territory mapping, and spatial analysis in architectural systems.",
    "category": "Basic Geometry",
    "paramsSchema": {},
    "code": "console.warn('voronoiDivision: Complex algorithm - requires external library');\n    return new THREE.BufferGeometry();",
    "outputType": "Geometry"
  },
  {
    "id": "smoothGeometry",
    "name": "smoothGeometry",
    "description": "Laplacian mesh smoothing via iterative vertex averaging with adjacent neighbors. Each iteration moves vertices toward local average position. Used for noise removal, fairing, and geometric refinement. Iterations and factor control smoothing strength.",
    "category": "Deformation",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": "",
        "description": "Geometry to smooth"
      },
      "iterations": {
        "type": "number",
        "default": 5
      },
      "factor": {
        "type": "number",
        "default": 0.5,
        "description": "Smoothing strength (0.0 - 1.0)"
      }
    },
    "code": "const { geometry, iterations = 5, factor = 0.5 } = params;\n\n    if (!geometry || !geometry.isBufferGeometry) return new THREE.BufferGeometry();\n\n    let geom = geometry.clone();\n\n    // 1. SAFE MERGE CHECK\n    let mergeFn = null;\n    if (typeof BufferGeometryUtils !== 'undefined') {\n        if (typeof BufferGeometryUtils.mergeVertices === 'function') mergeFn = BufferGeometryUtils.mergeVertices;\n        else if (BufferGeometryUtils.default && typeof BufferGeometryUtils.default.mergeVertices === 'function') mergeFn = BufferGeometryUtils.default.mergeVertices;\n    }\n\n    if (!geom.index && mergeFn) {\n        try {\n            geom = mergeFn(geom);\n        } catch(e) { console.warn('Merge failed', e); }\n    }\n\n    const positionAttribute = geom.attributes.position;\n    const positions = positionAttribute.array;\n    \n    // 2. SANITIZE INPUT (Critical for Marching Cubes)\n    // Fix any NaNs from the input generation step\n    let nanCount = 0;\n    for (let i = 0; i < positions.length; i++) {\n        if (isNaN(positions[i])) {\n            positions[i] = 0;\n            nanCount++;\n        }\n    }\n    if (nanCount > 0) console.warn(`smoothGeometry: Fixed ${nanCount} NaN input values`);\n\n    // 3. BUILD NEIGHBORS\n    if (!geom.index) return geom; // Cannot smooth without index\n    const indices = geom.index.array;\n    const vertexCount = positionAttribute.count;\n    const neighborMap = new Array(vertexCount).fill(0).map(() => []);\n\n    for (let i = 0; i < indices.length; i += 3) {\n        const a = indices[i], b = indices[i + 1], c = indices[i + 2];\n        if (!neighborMap[a].includes(b)) neighborMap[a].push(b);\n        if (!neighborMap[a].includes(c)) neighborMap[a].push(c);\n        if (!neighborMap[b].includes(a)) neighborMap[b].push(a);\n        if (!neighborMap[b].includes(c)) neighborMap[b].push(c);\n        if (!neighborMap[c].includes(a)) neighborMap[c].push(a);\n        if (!neighborMap[c].includes(b)) neighborMap[c].push(b);\n    }\n\n    // 4. ITERATIVE SMOOTHING\n    const newPositions = new Float32Array(positions);\n    const lambda = Math.max(0, Math.min(1, factor));\n\n    for (let k = 0; k < iterations; k++) {\n        for (let i = 0; i < vertexCount; i++) {\n            const neighbors = neighborMap[i];\n            const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;\n            \n            if (neighbors.length === 0) {\n                newPositions[ix] = positions[ix];\n                newPositions[iy] = positions[iy];\n                newPositions[iz] = positions[iz];\n                continue;\n            }\n\n            let avgX = 0, avgY = 0, avgZ = 0;\n            let validCount = 0;\n\n            for (let n = 0; n < neighbors.length; n++) {\n                const nid = neighbors[n];\n                const nx = positions[nid * 3];\n                const ny = positions[nid * 3 + 1];\n                const nz = positions[nid * 3 + 2];\n\n                if (isNaN(nx) || isNaN(ny) || isNaN(nz)) continue;\n\n                avgX += nx; avgY += ny; avgZ += nz;\n                validCount++;\n            }\n\n            if (validCount === 0) {\n                newPositions[ix] = positions[ix];\n                newPositions[iy] = positions[iy];\n                newPositions[iz] = positions[iz];\n                continue;\n            }\n\n            avgX /= validCount;\n            avgY /= validCount;\n            avgZ /= validCount;\n\n            newPositions[ix] = positions[ix] + (avgX - positions[ix]) * lambda;\n            newPositions[iy] = positions[iy] + (avgY - positions[iy]) * lambda;\n            newPositions[iz] = positions[iz] + (avgZ - positions[iz]) * lambda;\n        }\n        positions.set(newPositions);\n    }\n\n    positionAttribute.needsUpdate = true;\n    geom.computeVertexNormals();\n    geom.computeBoundingSphere(); // Recompute to verify fix\n    return geom;",
    "outputType": "Geometry"
  },
  {
    "id": "weldGeometry",
    "name": "weldGeometry",
    "description": "Vertex merging operation combining nearly-coincident vertices within tolerance. Reduces vertex count and closes gaps from numerical precision loss. Preprocessing step for clean mesh topology.",
    "category": "Boolean Operations",
    "paramsSchema": {
      "geometry": {
        "type": "string",
        "default": ""
      },
      "tolerance": {
        "type": "number",
        "default": 0.0001
      }
    },
    "code": "const { geometry, tolerance = 0.0001 } = params;\n    if (!geometry) return new THREE.BufferGeometry();\n    \n    // Find merge function\n    let mergeFn = null;\n    if (typeof BufferGeometryUtils !== 'undefined') {\n         if (typeof BufferGeometryUtils.mergeVertices === 'function') mergeFn = BufferGeometryUtils.mergeVertices;\n         else if (BufferGeometryUtils.default && typeof BufferGeometryUtils.default.mergeVertices === 'function') mergeFn = BufferGeometryUtils.default.mergeVertices;\n    }\n\n    if (!mergeFn) {\n        console.warn('weldGeometry: mergeVertices not found');\n        return geometry.clone();\n    }\n\n    // Force merge\n    const welded = mergeFn(geometry, tolerance);\n    console.log(`weldGeometry: Reduced vertices from ${geometry.attributes.position.count} to ${welded.attributes.position.count}`);\n    return welded;",
    "outputType": "Geometry"
  }, 
  {
  "id": "copyToPoints",
  "name": "Copy To Points",
  "description": "Copies a source geometry onto every vertex of a points geometry. Uses position + optional normal for orientation.",
  "category": "Instancing",
  "paramsSchema": {
    "source": { "type": "string", "default": "", "description": "Prototype geometry variable name" },
    "points": { "type": "string", "default": "", "description": "Points geometry variable name" },
    "orientToNormal": { "type": "boolean", "default": true },
    "scale": { "type": "number", "default": 1.0 }
  },
  "code": "const { source, points, orientToNormal = true, scale: scaleFactor = 1.0 } = params; if (!source || !points || !points.attributes || !points.attributes.position) { console.warn('copyToPoints: invalid inputs'); return new THREE.BufferGeometry(); } const posAttr = points.attributes.position; const normAttr = points.attributes.normal; const up = new THREE.Vector3(0, 1, 0); const dummy = new THREE.Object3D(); const p = new THREE.Vector3(); const n = new THREE.Vector3(); const geoms = []; const count = posAttr.count || 0; for (let i = 0; i < count; i++) { p.fromBufferAttribute(posAttr, i); dummy.position.copy(p); dummy.quaternion.set(0, 0, 0, 1); if (orientToNormal && normAttr) { n.fromBufferAttribute(normAttr, i); if (n.lengthSq() > 1e-8) dummy.quaternion.setFromUnitVectors(up, n.normalize()); } dummy.scale.set(scaleFactor, scaleFactor, scaleFactor); dummy.updateMatrix(); const inst = source.clone(); inst.applyMatrix4(dummy.matrix); geoms.push(inst); } return geoms.length ? BufferGeometryUtils.mergeGeometries(geoms) : new THREE.BufferGeometry();",
  "outputType": "Geometry"
},
  {
  "id": "filterPoints",
  "name": "Filter Points (threshold param)",
  "description": "Filters vertices/points from a geometry using a boolean expression fn(p,i,noise,threshold). Keeps points where expression returns true.",
  "category": "Modification",
  "paramsSchema": {
    "geometry": {
      "type": "string",
      "default": "",
      "description": "Geometry variable (must have attributes.position)"
    },
    "expression": {
      "type": "string",
      "default": "noise.simplex3(p.x*0.1, p.y*0.1, p.z*0.1) > threshold",
      "description": "Boolean expression using p,i,noise,threshold. Example: noise.simplex3(p.x*0.1,p.y*0.1,p.z*0.1) > threshold"
    },
    "threshold": {
      "type": "number",
      "default": 0.2,
      "description": "Numeric threshold passed into the expression as 'threshold'"
    }
  },
  "code": "const { geometry, expression, threshold = 0.2 } = params; if (!geometry || !geometry.attributes || !geometry.attributes.position) { console.warn('filterPoints: no geometry/position'); return new THREE.BufferGeometry(); } const posAttr = geometry.attributes.position; const normAttr = geometry.attributes.normal; const count = posAttr.count || 0; if (count === 0) return new THREE.BufferGeometry(); let fn; try { const expr = (typeof expression === 'string' && expression.trim().length) ? expression : 'true'; fn = new Function('p','i','noise','threshold', `return (${expr});`); } catch (e) { console.warn('filterPoints: expression compile failed, keeping all points', e); fn = () => true; } const outPos = []; const outNorm = []; const p = new THREE.Vector3(); for (let i = 0; i < count; i++) { p.fromBufferAttribute(posAttr, i); let keep = false; try { keep = !!fn(p, i, noise, threshold); } catch (e) { keep = false; } if (!keep) continue; outPos.push(p.x, p.y, p.z); if (normAttr) outNorm.push(normAttr.getX(i), normAttr.getY(i), normAttr.getZ(i)); } const out = new THREE.BufferGeometry(); if (outPos.length === 0) return out; out.setAttribute('position', new THREE.Float32BufferAttribute(outPos, 3)); if (outNorm.length === outPos.length) out.setAttribute('normal', new THREE.Float32BufferAttribute(outNorm, 3)); return out;",
  "outputType": "Geometry"
},
  {
  "id": "crawlCurvesOnGeometry",
  "name": "crawlCurvesOnGeometry",
  "description": "Crawls agent-like stripes over any input mesh (BufferGeometry) using raycasting projection to stay on the surface. Outputs a LineSegments object for preview and stores raw segment data in userData.segments for downstream uses (e.g., meshing via Marching Cubes after converting segments into a scalar field).",
  "category": "Curves Paths",
  "outputType": "Geometry",
  "paramsSchema": {
    "geometry": { "type": "string", "default": "", "description": "Geometry variable to crawl on (BufferGeometry). Use output name from a previous step." },

    "stripeCount": { "type": "number", "default": 30, "description": "Number of separate crawlers/stripes to generate." },
    "stepsPerStripe": { "type": "number", "default": 250, "description": "Number of integration steps per stripe." },
    "stepSize": { "type": "number", "default": 0.05, "description": "World-space step length along surface per step." },

    "lift": { "type": "number", "default": 0.03, "description": "Small offset along the surface normal before re-projecting (helps avoid self-intersection / sticking)." },
    "retryRays": { "type": "number", "default": 12, "description": "How many random rays to try when choosing a start point on the surface." },

    "fieldFreq": { "type": "number", "default": 1.25, "description": "Frequency for noise sampling in the driving field." },
    "fieldNoise": { "type": "number", "default": 0.85, "description": "Strength of the noise component in the driving field." },
    "vortex": { "type": "number", "default": 1.2, "description": "Strength of the vortex (cross-product) components in the driving field." },

    "seed": { "type": "number", "default": 42, "description": "Deterministic seed controlling starting points and field axes." },

    "thickness": { "type": "number", "default": 0.06, "description": "Stored per-segment thickness (used later if you convert segments to tubes or density)." }
  },
  "code": "const {\n  geometry,\n  stripeCount = 30,\n  stepsPerStripe = 250,\n  stepSize = 0.05,\n  lift = 0.03,\n  retryRays = 12,\n  fieldFreq = 1.25,\n  fieldNoise = 0.85,\n  vortex = 1.2,\n  seed = 42,\n  thickness = 0.06\n} = params;\n\n// Accept either BufferGeometry or Mesh-like input\nlet geom = geometry;\nif (geom && geom.isObject3D && geom.geometry) geom = geom.geometry;\n\nif (!geom || !geom.isBufferGeometry) {\n  console.warn('crawlCurvesOnGeometry: invalid geometry');\n  return new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xffffff }));\n}\n\n// Deterministic RNG\nfunction mulberry32(a){\n  return function(){\n    let t = a += 0x6D2B79F5;\n    t = Math.imul(t ^ (t >>> 15), t | 1);\n    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n  };\n}\nconst rnd = mulberry32(Math.floor(seed));\n\nfunction randOnSphere(){\n  const u = rnd();\n  const v = rnd();\n  const theta = 2 * Math.PI * u;\n  const z = 2 * v - 1;\n  const r = Math.sqrt(Math.max(0, 1 - z*z));\n  return new THREE.Vector3(r*Math.cos(theta), z, r*Math.sin(theta));\n}\n\n// Mesh for raycasting\nconst mesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial());\nmesh.updateMatrixWorld(true);\n\ngeom.computeBoundingSphere();\nconst bs = geom.boundingSphere;\nconst center = bs ? bs.center.clone() : new THREE.Vector3(0,0,0);\nconst radius = bs ? bs.radius : 1.0;\n\n// Random axes for vortex field\nconst axisA = randOnSphere().normalize();\nconst axisB = randOnSphere().normalize();\n\nfunction fieldRawAt(p){\n  const f = fieldFreq;\n  const nx = noise.simplex3(p.x*f, p.y*f, 11.1);\n  const ny = noise.simplex3(p.y*f, p.z*f, 22.2);\n  const nz = noise.simplex3(p.z*f, p.x*f, 33.3);\n  const nVec = new THREE.Vector3(nx, ny, nz).multiplyScalar(fieldNoise);\n\n  // Vortex-like tendencies\n  const vA = new THREE.Vector3().crossVectors(axisA, p).multiplyScalar(vortex);\n  const vB = new THREE.Vector3().crossVectors(axisB, p).multiplyScalar(0.6 * vortex);\n\n  return nVec.add(vA).add(vB);\n}\n\nfunction projectToTangent(raw, normal){\n  const n = normal.clone().normalize();\n  const t = raw.clone().sub(n.clone().multiplyScalar(raw.dot(n)));\n  const L = t.length();\n  return (L < 1e-6) ? new THREE.Vector3(1,0,0) : t.multiplyScalar(1/L);\n}\n\nfunction raycastToSurface(origin, dir){\n  const raycaster = new THREE.Raycaster(origin, dir.clone().normalize(), 0, radius * 10);\n  const hits = raycaster.intersectObject(mesh, false);\n  return (hits && hits.length) ? hits[0] : null;\n}\n\nfunction randomSurfaceHit(){\n  for (let k = 0; k < Math.max(1, Math.floor(retryRays)); k++){\n    const d = randOnSphere();\n    const origin = center.clone().add(d.clone().multiplyScalar(radius * 2.5));\n    const hit = raycastToSurface(origin, d.clone().multiplyScalar(-1));\n    if (hit) return hit;\n  }\n  return null;\n}\n\nconst segments = [];\nconst positions = [];\n\nfor (let s = 0; s < Math.max(1, Math.floor(stripeCount)); s++){\n  const firstHit = randomSurfaceHit();\n  if (!firstHit) continue;\n\n  let p = firstHit.point.clone();\n  let n = (firstHit.face && firstHit.face.normal) ? firstHit.face.normal.clone().normalize() : new THREE.Vector3(0,1,0);\n\n  for (let i = 0; i < Math.max(2, Math.floor(stepsPerStripe)); i++){\n    const raw = fieldRawAt(p);\n    const dirT = projectToTangent(raw, n);\n\n    const start = p.clone();\n\n    // move tangentially, then lift off the surface slightly before projecting back\n    const pTry = p.clone().add(dirT.multiplyScalar(stepSize)).add(n.clone().multiplyScalar(lift));\n\n    // project back: first along -normal, then fallback +normal\n    const hitA = raycastToSurface(pTry.clone().add(n.clone().multiplyScalar(radius * 0.05)), n.clone().multiplyScalar(-1));\n    const hitB = hitA ? null : raycastToSurface(pTry.clone().add(n.clone().multiplyScalar(-radius * 0.05)), n.clone());\n    const hit = hitA || hitB;\n\n    if (!hit) break;\n\n    p = hit.point.clone();\n    n = (hit.face && hit.face.normal) ? hit.face.normal.clone().normalize() : n;\n\n    const end = p.clone();\n\n    // store for downstream\n    segments.push([start.clone(), end.clone(), thickness]);\n\n    // preview line positions\n    positions.push(start.x, start.y, start.z, end.x, end.y, end.z);\n  }\n}\n\nconst lineGeom = new THREE.BufferGeometry();\nif (positions.length) {\n  lineGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));\n}\n\nconst lineObj = new THREE.LineSegments(lineGeom, new THREE.LineBasicMaterial({ color: 0xffffff }));\nlineObj.userData = lineObj.userData || {};\nlineObj.userData.type = 'crawled-curves';\nlineObj.userData.segments = segments;\nreturn lineObj;\n"
}, 
  {
  "id": "splitMeshToTopologyStripMeshes",
  "name": "splitMeshToTopologyStripMeshes",
  "description": "v6: curvature-following + one-directional guide + quantized adjacency + absorb fill.",
  "category": "Curves Paths",
  "outputType": "Geometry",
  "paramsSchema": {
    "geometry": { "type": "string", "default": "" },

    "seedCount": { "type": "number", "default": 180 },
    "maxFacesPerStrip": { "type": "number", "default": 1200 },
    "minStripFaces": { "type": "number", "default": 60 },

    "turnPenalty": { "type": "number", "default": 1.1 },

    "flowMode": { "type": "string", "default": "curvatureMax" },
    "guideAxis": { "type": "array", "default": [0, 1, 0] },
    "guideBlend": { "type": "number", "default": 0.35 },
    "enforceForward": { "type": "boolean", "default": true },

    "curvatureSmoothIters": { "type": "number", "default": 8 },
    "curvatureNeighborWeight": { "type": "number", "default": 1.0 },

    "positionEps": { "type": "number", "default": 0.01 },

    "fillMode": { "type": "string", "default": "absorb" },
    "absorbIters": { "type": "number", "default": 8 },

    "palette": { "type": "array", "default": [16711680, 65280, 255] },
    "colorMode": { "type": "string", "default": "random" },
    "seed": { "type": "number", "default": 42 },

    "debug": { "type": "boolean", "default": false }
  },
  "code": "const {\n  geometry,\n  seedCount = 180,\n  maxFacesPerStrip = 1200,\n  minStripFaces = 60,\n  turnPenalty = 1.1,\n\n  flowMode = 'curvatureMax',\n  guideAxis = [0, 1, 0],\n  guideBlend = 0.35,\n  enforceForward = true,\n\n  curvatureSmoothIters = 8,\n  curvatureNeighborWeight = 1.0,\n\n  positionEps = 0.01,\n\n  fillMode = 'absorb',\n  absorbIters = 8,\n\n  palette = [0xffffff],\n  colorMode = 'random',\n  seed = 42,\n  debug = false,\n} = params;\n\nlet geom = geometry;\nif (geom && geom.isObject3D && geom.geometry) geom = geom.geometry;\nif (!geom || !geom.isBufferGeometry) return [];\n\nif (!geom.attributes.normal) geom.computeVertexNormals();\nif (!geom.index) {\n  console.warn('splitMeshToTopologyStripMeshes: geometry has no index.');\n  return [];\n}\n\nconst pos = geom.attributes.position;\nconst nor = geom.attributes.normal;\nconst ind = geom.index.array;\nconst faceCount = Math.floor(ind.length / 3);\n\n// RNG\nlet seedVal = seed;\nfunction random() { const x = Math.sin(seedVal++) * 10000; return x - Math.floor(x); }\nfunction getCol(i) { return colorMode === 'random' ? palette[Math.floor(random() * palette.length)] : palette[i % palette.length]; }\nfunction getRGB(hex) { if (typeof hex === 'string') hex = parseInt(hex.replace('#',''), 16); return [((hex>>16)&255)/255, ((hex>>8)&255)/255, (hex&255)/255]; }\n\n// Precompute face centers (used for flow + strip stepping)\nconst faceCenter = new Float32Array(faceCount * 3);\n{\n  const v0 = new THREE.Vector3(), v1 = new THREE.Vector3(), v2 = new THREE.Vector3();\n  const c = new THREE.Vector3();\n  for (let f = 0; f < faceCount; f++) {\n    const ia = ind[3*f], ib = ind[3*f+1], ic = ind[3*f+2];\n    v0.fromBufferAttribute(pos, ia);\n    v1.fromBufferAttribute(pos, ib);\n    v2.fromBufferAttribute(pos, ic);\n    c.copy(v0).add(v1).add(v2).multiplyScalar(1/3);\n    faceCenter[3*f] = c.x;\n    faceCenter[3*f+1] = c.y;\n    faceCenter[3*f+2] = c.z;\n  }\n}\n\n// -------------------------------\n// 1) Curvature-following direction field (approx principal direction)\n// -------------------------------\nconst vCount = pos.count;\n\n// Build 1-ring vertex neighbors\nconst vNbr = Array.from({ length: vCount }, () => []);\n{\n  const sets = Array.from({ length: vCount }, () => new Set());\n  for (let i = 0; i < ind.length; i += 3) {\n    const a = ind[i], b = ind[i+1], c = ind[i+2];\n    sets[a].add(b); sets[a].add(c);\n    sets[b].add(a); sets[b].add(c);\n    sets[c].add(a); sets[c].add(b);\n  }\n  for (let i = 0; i < vCount; i++) vNbr[i] = Array.from(sets[i]);\n}\n\nconst _n = new THREE.Vector3();\nconst _t1 = new THREE.Vector3();\nconst _t2 = new THREE.Vector3();\n\nfunction makeTangentBasis(nx, ny, nz) {\n  _n.set(nx, ny, nz);\n  if (_n.lengthSq() < 1e-12) _n.set(0, 1, 0);\n  _n.normalize();\n\n  const up = Math.abs(_n.y) < 0.9 ? new THREE.Vector3(0, 1, 0) : new THREE.Vector3(1, 0, 0);\n  _t1.copy(up).cross(_n);\n  if (_t1.lengthSq() < 1e-12) _t1.set(1, 0, 0);\n  _t1.normalize();\n  _t2.copy(_n).cross(_t1).normalize();\n\n  return { n: _n.clone(), t1: _t1.clone(), t2: _t2.clone() };\n}\n\nfunction eigen2x2(a, b, d, pickMax = true) {\n  // symmetric matrix [a b; b d]\n  const tr = a + d;\n  const det = a * d - b * b;\n  const disc = Math.max(0, tr * tr / 4 - det);\n  const s = Math.sqrt(disc);\n  const l1 = tr / 2 + s;\n  const l2 = tr / 2 - s;\n  const lam = pickMax ? l1 : l2;\n\n  // eigenvector for lam\n  let x = b;\n  let y = lam - a;\n  if (Math.abs(x) + Math.abs(y) < 1e-12) {\n    x = lam - d;\n    y = b;\n  }\n  const len = Math.hypot(x, y) || 1;\n  return { ex: x / len, ey: y / len };\n}\n\nconst vDir = Array.from({ length: vCount }, () => new THREE.Vector3(1, 0, 0));\n{\n  const pi = new THREE.Vector3(), pj = new THREE.Vector3();\n  const ni = new THREE.Vector3(), nj = new THREE.Vector3();\n\n  for (let i = 0; i < vCount; i++) {\n    const nxi = nor.getX(i), nyi = nor.getY(i), nzi = nor.getZ(i);\n    const basis = makeTangentBasis(nxi, nyi, nzi);\n    const n0 = basis.n, t1 = basis.t1, t2 = basis.t2;\n\n    pi.fromBufferAttribute(pos, i);\n    ni.set(nxi, nyi, nzi);\n    if (ni.lengthSq() < 1e-12) ni.set(0, 1, 0);\n    ni.normalize();\n\n    let A00 = 0, A01 = 0, A10 = 0, A11 = 0;\n    let B00 = 0, B01 = 0, B11 = 0;\n\n    const nbrs = vNbr[i];\n    for (let k = 0; k < nbrs.length; k++) {\n      const j = nbrs[k];\n      pj.fromBufferAttribute(pos, j);\n      nj.set(nor.getX(j), nor.getY(j), nor.getZ(j));\n      if (nj.lengthSq() < 1e-12) continue;\n      nj.normalize();\n\n      const dp = pj.clone().sub(pi);\n      const dpT = dp.clone().sub(n0.clone().multiplyScalar(dp.dot(n0)));\n      const px = dpT.dot(t1);\n      const py = dpT.dot(t2);\n      const pLen2 = px * px + py * py;\n      if (pLen2 < 1e-10) continue;\n\n      const dn = nj.clone().sub(ni);\n      const dnT = dn.clone().sub(n0.clone().multiplyScalar(dn.dot(n0)));\n      const qx = dnT.dot(t1);\n      const qy = dnT.dot(t2);\n\n      const w = (curvatureNeighborWeight) / (pLen2 + 1e-8);\n\n      A00 += w * qx * px;\n      A01 += w * qx * py;\n      A10 += w * qy * px;\n      A11 += w * qy * py;\n\n      B00 += w * px * px;\n      B01 += w * px * py;\n      B11 += w * py * py;\n    }\n\n    const detB = B00 * B11 - B01 * B01;\n    if (Math.abs(detB) < 1e-12) {\n      vDir[i].copy(t1);\n      continue;\n    }\n\n    const invB00 = B11 / detB;\n    const invB01 = -B01 / detB;\n    const invB11 = B00 / detB;\n\n    const S00 = A00 * invB00 + A01 * invB01;\n    const S01 = A00 * invB01 + A01 * invB11;\n    const S10 = A10 * invB00 + A11 * invB01;\n    const S11 = A10 * invB01 + A11 * invB11;\n\n    // symmetrize\n    const M00 = S00;\n    const M01 = 0.5 * (S01 + S10);\n    const M11 = S11;\n\n    const pickMax = (flowMode !== 'curvatureMin');\n    const ev = eigen2x2(M00, M01, M11, pickMax);\n\n    vDir[i].copy(t1).multiplyScalar(ev.ex).add(t2.clone().multiplyScalar(ev.ey));\n    if (vDir[i].lengthSq() < 1e-12) vDir[i].copy(t1);\n    vDir[i].normalize();\n  }\n}\n\n// Smooth direction field with sign-consistent averaging\nfor (let it = 0; it < curvatureSmoothIters; it++) {\n  const next = vDir.map(v => v.clone());\n  for (let i = 0; i < vCount; i++) {\n    const acc = vDir[i].clone();\n    for (const j of vNbr[i]) {\n      const dj = vDir[j];\n      acc.add(acc.dot(dj) < 0 ? dj.clone().multiplyScalar(-1) : dj);\n    }\n    if (acc.lengthSq() > 1e-12) acc.normalize();\n    next[i] = acc;\n  }\n  for (let i = 0; i < vCount; i++) vDir[i].copy(next[i]);\n}\n\n// Build per-face flow from curvature dirs + guide alignment\nconst faceFlow = new Float32Array(faceCount * 3);\n{\n  const guide = new THREE.Vector3(...guideAxis);\n  if (guide.lengthSq() < 1e-12) guide.set(0, 1, 0);\n  guide.normalize();\n\n  const v0 = new THREE.Vector3(), v1 = new THREE.Vector3(), v2 = new THREE.Vector3();\n  const fn = new THREE.Vector3(), d = new THREE.Vector3(), gproj = new THREE.Vector3();\n\n  for (let f = 0; f < faceCount; f++) {\n    const ia = ind[3*f], ib = ind[3*f+1], ic = ind[3*f+2];\n\n    v0.fromBufferAttribute(pos, ia);\n    v1.fromBufferAttribute(pos, ib);\n    v2.fromBufferAttribute(pos, ic);\n    fn.copy(v1).sub(v0).cross(v2.clone().sub(v0));\n    if (fn.lengthSq() < 1e-12) fn.set(0, 1, 0);\n    fn.normalize();\n\n    d.copy(vDir[ia]).add(vDir[ib]).add(vDir[ic]).multiplyScalar(1/3);\n    d.sub(fn.clone().multiplyScalar(d.dot(fn)));\n    if (d.lengthSq() < 1e-12) d.set(1, 0, 0);\n    d.normalize();\n\n    gproj.copy(guide).sub(fn.clone().multiplyScalar(guide.dot(fn)));\n    if (gproj.lengthSq() > 1e-12) gproj.normalize();\n\n    if (enforceForward && gproj.lengthSq() > 1e-12) {\n      if (d.dot(gproj) < 0) d.multiplyScalar(-1);\n    }\n\n    if (guideBlend > 0 && gproj.lengthSq() > 1e-12) {\n      d.multiplyScalar(1 - guideBlend).add(gproj.multiplyScalar(guideBlend));\n      if (d.lengthSq() < 1e-12) d.set(1, 0, 0);\n      else d.normalize();\n    }\n\n    faceFlow[3*f] = d.x;\n    faceFlow[3*f+1] = d.y;\n    faceFlow[3*f+2] = d.z;\n  }\n}\n\n// -------------------------------\n// 2) Quantized adjacency (robust to duplicated vertex indices)\n// -------------------------------\nfunction vKey(vi) {\n  const x = pos.getX(vi), y = pos.getY(vi), z = pos.getZ(vi);\n  const qx = Math.round(x / positionEps);\n  const qy = Math.round(y / positionEps);\n  const qz = Math.round(z / positionEps);\n  return `${qx},${qy},${qz}`;\n}\n\nconst neighbor = new Int32Array(faceCount * 3).fill(-1);\nconst edgeMap = new Map();\n\nfor (let f = 0; f < faceCount; f++) {\n  const a = ind[3*f], b = ind[3*f+1], c = ind[3*f+2];\n  const edges = [[a, b, 0], [b, c, 1], [c, a, 2]];\n  for (const [u, v, e] of edges) {\n    const ku = vKey(u), kv = vKey(v);\n    const key = ku < kv ? `${ku}|${kv}` : `${kv}|${ku}`;\n    if (!edgeMap.has(key)) edgeMap.set(key, []);\n    edgeMap.get(key).push({ f, e });\n  }\n}\n\nlet connections = 0;\nfor (const list of edgeMap.values()) {\n  if (list.length < 2) continue;\n  // stable manifold-ish pairing (first two)\n  const a = list[0], b = list[1];\n  neighbor[3*a.f + a.e] = b.f;\n  neighbor[3*b.f + b.e] = a.f;\n  connections += 2;\n}\n\nif (debug) {\n  console.log('Face count:', faceCount);\n  console.log('Edge connections (quantized):', connections);\n}\n\n// -------------------------------\n// 3) Grow long strips (seeded) + optional absorb fill\n// -------------------------------\nconst occupied = new Uint8Array(faceCount);\nconst label = new Int32Array(faceCount).fill(-1);\nlet stripId = 0;\n\nfunction pickSeed() {\n  const start = Math.floor(random() * faceCount);\n  for (let k = 0; k < faceCount; k++) {\n    const f = (start + k) % faceCount;\n    if (!occupied[f]) return f;\n  }\n  return -1;\n}\n\nfunction growFrom(seedFace, maxLen) {\n  const faces = [];\n  let curr = seedFace;\n  let lastDir = null;\n\n  for (let step = 0; step < maxLen; step++) {\n    if (occupied[curr]) break;\n    occupied[curr] = 1;\n    faces.push(curr);\n\n    const cx = faceCenter[3*curr], cy = faceCenter[3*curr+1], cz = faceCenter[3*curr+2];\n    const fx = faceFlow[3*curr], fy = faceFlow[3*curr+1], fz = faceFlow[3*curr+2];\n\n    let bestN = -1;\n    let bestScore = -Infinity;\n    let bestDir = null;\n\n    for (let e = 0; e < 3; e++) {\n      const nf = neighbor[3*curr + e];\n      if (nf === -1 || occupied[nf]) continue;\n\n      let dx = faceCenter[3*nf] - cx;\n      let dy = faceCenter[3*nf+1] - cy;\n      let dz = faceCenter[3*nf+2] - cz;\n      const len = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1;\n      dx /= len; dy /= len; dz /= len;\n\n      const align = fx*dx + fy*dy + fz*dz;\n      let turn = 0;\n      if (lastDir) turn = 1.0 - (lastDir.x*dx + lastDir.y*dy + lastDir.z*dz);\n\n      // forward-only bias: disallow strong backwards steps\n      if (align < 0.05) continue;\n\n      const score = align - turn * turnPenalty;\n      if (score > bestScore) {\n        bestScore = score;\n        bestN = nf;\n        bestDir = { x: dx, y: dy, z: dz };\n      }\n    }\n\n    if (bestN === -1) break;\n    curr = bestN;\n    lastDir = bestDir;\n  }\n\n  return faces;\n}\n\nconst stripsFaces = [];\nfor (let s = 0; s < seedCount; s++) {\n  const sf = pickSeed();\n  if (sf === -1) break;\n\n  const faces = growFrom(sf, maxFacesPerStrip);\n\n  if (faces.length >= minStripFaces) {\n    const id = stripId++;\n    stripsFaces[id] = faces;\n    for (const f of faces) label[f] = id;\n  } else {\n    // free them; let them be absorbed instead of becoming tiny strips\n    for (const f of faces) occupied[f] = 0;\n  }\n}\n\nif (fillMode === 'absorb') {\n  for (let iter = 0; iter < absorbIters; iter++) {\n    let changed = 0;\n    for (let f = 0; f < faceCount; f++) {\n      if (label[f] !== -1) continue;\n      let best = -1;\n      for (let e = 0; e < 3; e++) {\n        const nf = neighbor[3*f + e];\n        if (nf === -1) continue;\n        const lid = label[nf];\n        if (lid !== -1) { best = lid; break; }\n      }\n      if (best !== -1) {\n        label[f] = best;\n        changed++;\n      }\n    }\n    if (changed === 0) break;\n  }\n\n  // remaining truly-disconnected faces become their own strips (should be rare)\n  for (let f = 0; f < faceCount; f++) {\n    if (label[f] === -1) {\n      const id = stripId++;\n      label[f] = id;\n      stripsFaces[id] = [f];\n    }\n  }\n\n  // rebuild face lists by label (keeps geometry creation simple)\n  const buckets = new Array(stripId);\n  for (let i = 0; i < stripId; i++) buckets[i] = [];\n  for (let f = 0; f < faceCount; f++) buckets[label[f]].push(f);\n  for (let i = 0; i < stripId; i++) stripsFaces[i] = buckets[i];\n}\n\n// -------------------------------\n// 4) Output geometries\n// -------------------------------\nconst out = [];\nfor (let i = 0; i < stripsFaces.length; i++) {\n  const faces = stripsFaces[i];\n  if (!faces || faces.length === 0) continue;\n\n  const col = getRGB(getCol(out.length));\n  const sPos = [];\n  const sCol = [];\n\n  for (const f of faces) {\n    const ia = ind[3*f], ib = ind[3*f+1], ic = ind[3*f+2];\n    sPos.push(pos.getX(ia), pos.getY(ia), pos.getZ(ia));\n    sPos.push(pos.getX(ib), pos.getY(ib), pos.getZ(ib));\n    sPos.push(pos.getX(ic), pos.getY(ic), pos.getZ(ic));\n    sCol.push(...col, ...col, ...col);\n  }\n\n  const g2 = new THREE.BufferGeometry();\n  g2.setAttribute('position', new THREE.Float32BufferAttribute(sPos, 3));\n  g2.setAttribute('color', new THREE.Float32BufferAttribute(sCol, 3));\n  g2.computeVertexNormals();\n  g2.userData = { type: 'strip', faceCount: faces.length };\n  out.push(g2);\n}\n\nif (debug) {\n  console.log('Generated strips:', out.length);\n}\n\nreturn out;\n"
}, 
  {
  "id": "transformEach",
  "name": "transformEach",
  "description": "Apply per-element translate/rotate/scale to an array of geometries using expressions (i, n, t, pos, userData). Per-axis TRS params (no arrays). Supports pivoted rotation/scale around bbox center by default.",
  "category": "Distribution",
  "paramsSchema": {
    "geometries": {
      "type": "string",
      "default": "",
      "description": "Array of geometries (or a single geometry) to transform"
    },

    "translateX": { "type": "string", "default": "0", "description": "Translate X (number or expression)" },
    "translateY": { "type": "string", "default": "0", "description": "Translate Y (number or expression)" },
    "translateZ": { "type": "string", "default": "0", "description": "Translate Z (number or expression)" },

    "rotateX": { "type": "string", "default": "0", "description": "Rotate X in radians (number or expression)" },
    "rotateY": { "type": "string", "default": "0", "description": "Rotate Y in radians (number or expression)" },
    "rotateZ": { "type": "string", "default": "0", "description": "Rotate Z in radians (number or expression)" },

    "scaleX": { "type": "string", "default": "1", "description": "Scale X (number or expression)" },
    "scaleY": { "type": "string", "default": "1", "description": "Scale Y (number or expression)" },
    "scaleZ": { "type": "string", "default": "1", "description": "Scale Z (number or expression)" },

    "pivotMode": {
      "type": "string",
      "default": "center",
      "description": "Pivot for rotate/scale: center | origin | bboxMin | bboxMax | custom"
    },
    "pivotX": { "type": "string", "default": "", "description": "Custom pivot X (used if pivotMode=custom). Expression allowed, default=center.x" },
    "pivotY": { "type": "string", "default": "", "description": "Custom pivot Y (used if pivotMode=custom). Expression allowed, default=center.y" },
    "pivotZ": { "type": "string", "default": "", "description": "Custom pivot Z (used if pivotMode=custom). Expression allowed, default=center.z" },

    "clone": {
      "type": "boolean",
      "default": true,
      "description": "Clone each geometry before transforming"
    },
    "autoMerge": {
      "type": "boolean",
      "default": false,
      "description": "Merge output into one BufferGeometry"
    }
  },
  "code": "const {\n  geometries,\n  translateX, translateY, translateZ,\n  rotateX, rotateY, rotateZ,\n  scaleX, scaleY, scaleZ,\n  pivotMode,\n  pivotX, pivotY, pivotZ,\n  clone = true,\n  autoMerge = false,\n  translate,\n  rotate,\n  scale,\n  pivot\n} = params;\n\nlet items = [];\nif (Array.isArray(geometries)) items = geometries;\nelse if (geometries && geometries.isBufferGeometry) items = [geometries];\nelse return autoMerge ? new THREE.BufferGeometry() : [];\n\nconst parseVec3 = (v, fallback) => {\n  if (v == null) return fallback;\n  if (Array.isArray(v)) return [v[0], v[1], v[2]];\n  if (typeof v === 'string') {\n    let s = v.trim();\n    s = s.replace(/^\\[/, '').replace(/\\]$/, '');\n    try {\n      const j = JSON.parse(v);\n      if (Array.isArray(j)) return [j[0], j[1], j[2]];\n    } catch (e) {\n      const parts = s.split(',').map(x => x.trim());\n      if (parts.length >= 3) return [parts[0], parts[1], parts[2]];\n    }\n  }\n  return [v, v, v];\n};\n\nconst evalExpr = (expr, ctx, fallback = 0) => {\n  if (expr == null) return fallback;\n  if (typeof expr === 'number') return Number.isFinite(expr) ? expr : fallback;\n  if (typeof expr === 'boolean') return fallback;\n\n  const s = String(expr).trim();\n  if (s === '') return fallback;\n  if (!isNaN(Number(s))) return Number(s);\n\n  try {\n    // Expose userData properties + hierarchy variables as top-level in scope\n    const userData = ctx.userData || {};\n    const userDataVars = Object.keys(userData).reduce((acc, key) => {\n      acc[`const ${key} = userData.${key};`] = true;\n      return acc;\n    }, {});\n    const userDataDecls = Object.keys(userData).map(k => `const ${k} = userData['${k}'];`).join('');\n    \n    const fn = new Function('i','n','t','pos','userData','Math', userDataDecls + `return (${s});`);\n    const v = fn(ctx.i, ctx.n, ctx.t, ctx.pos, ctx.userData, Math);\n    return Number.isFinite(v) ? v : fallback;\n  } catch (e) {\n    return fallback;\n  }\n};\n\nconst modeRaw = (pivotMode != null && String(pivotMode).trim() !== '') ? String(pivotMode) : (pivot != null ? String(pivot) : 'center');\nconst mode = modeRaw.trim();\n\nconst results = [];\nconst n = items.length;\n\nconst tmpCenter = new THREE.Vector3();\nconst tmpMin = new THREE.Vector3();\nconst tmpMax = new THREE.Vector3();\n\nfor (let i = 0; i < n; i++) {\n  const g0 = items[i];\n  if (!g0 || !g0.isBufferGeometry) continue;\n\n  const g = (clone && g0.clone) ? g0.clone() : g0;\n\n  g.computeBoundingBox();\n  const bb = g.boundingBox;\n  if (!bb) continue;\n\n  bb.getCenter(tmpCenter);\n  tmpMin.copy(bb.min);\n  tmpMax.copy(bb.max);\n\n  const ud = g0.userData || {};\n  const pos = tmpCenter.clone();\n  const ctx = { i, n, t: (n <= 1 ? 0 : i / (n - 1)), pos, userData: ud };\n\n  let px = tmpCenter.x, py = tmpCenter.y, pz = tmpCenter.z;\n  if (mode === 'origin') {\n    px = 0; py = 0; pz = 0;\n  } else if (mode === 'bboxMin') {\n    px = tmpMin.x; py = tmpMin.y; pz = tmpMin.z;\n  } else if (mode === 'bboxMax') {\n    px = tmpMax.x; py = tmpMax.y; pz = tmpMax.z;\n  } else if (mode === 'custom') {\n    px = evalExpr(pivotX, ctx, tmpCenter.x);\n    py = evalExpr(pivotY, ctx, tmpCenter.y);\n    pz = evalExpr(pivotZ, ctx, tmpCenter.z);\n  }\n\n  const legacyT = parseVec3(translate, [0,0,0]);\n  const tx = (translateX != null && String(translateX).trim() !== '') ? evalExpr(translateX, ctx, 0) : evalExpr(legacyT[0], ctx, 0);\n  const ty = (translateY != null && String(translateY).trim() !== '') ? evalExpr(translateY, ctx, 0) : evalExpr(legacyT[1], ctx, 0);\n  const tz = (translateZ != null && String(translateZ).trim() !== '') ? evalExpr(translateZ, ctx, 0) : evalExpr(legacyT[2], ctx, 0);\n\n  const legacyR = parseVec3(rotate, [0,0,0]);\n  const rx = (rotateX != null && String(rotateX).trim() !== '') ? evalExpr(rotateX, ctx, 0) : evalExpr(legacyR[0], ctx, 0);\n  const ry = (rotateY != null && String(rotateY).trim() !== '') ? evalExpr(rotateY, ctx, 0) : evalExpr(legacyR[1], ctx, 0);\n  const rz = (rotateZ != null && String(rotateZ).trim() !== '') ? evalExpr(rotateZ, ctx, 0) : evalExpr(legacyR[2], ctx, 0);\n\n  const legacyS = parseVec3(scale, [1,1,1]);\n  const sx = (scaleX != null && String(scaleX).trim() !== '') ? evalExpr(scaleX, ctx, 1) : evalExpr(legacyS[0], ctx, 1);\n  const sy = (scaleY != null && String(scaleY).trim() !== '') ? evalExpr(scaleY, ctx, 1) : evalExpr(legacyS[1], ctx, 1);\n  const sz = (scaleZ != null && String(scaleZ).trim() !== '') ? evalExpr(scaleZ, ctx, 1) : evalExpr(legacyS[2], ctx, 1);\n\n  g.translate(-px, -py, -pz);\n  g.scale(sx, sy, sz);\n  if (rx !== 0) g.rotateX(rx);\n  if (ry !== 0) g.rotateY(ry);\n  if (rz !== 0) g.rotateZ(rz);\n  g.translate(px, py, pz);\n\n  if (tx !== 0 || ty !== 0 || tz !== 0) g.translate(tx, ty, tz);\n\n  g.userData = { ...ud, ...g.userData, _transformEach: { i, n, t: ctx.t } };\n\n  results.push(g);\n}\n\nreturn autoMerge ? BufferGeometryUtils.mergeGeometries(results.filter(r => r && r.isBufferGeometry)) : results;",
  "outputType": "Geometry"
}, 
  {
    "id": "repeatGroupLinear3d",
    "name": "repeatGroupLinear3d",
    "description": "Repeat a geometry or group of geometries along a straight axis, returning a flat array (or merged geometry) with hierarchy metadata accessible by levelName.",
    "category": "Distribution",
    "paramsSchema": {
      "group": { "type": "string", "default": "", "description": "Geometry or array of geometries to repeat" },
      "count": { "type": "number", "default": 3, "description": "Number of repeats" },
      "spacing": { "type": "number", "default": 1, "description": "Distance between repeats" },
      "axis": { "type": "string", "default": "x", "description": "x | y | z" },
      "centered": { "type": "boolean", "default": false, "description": "Center the whole repeated sequence around the origin" },
      "levelName": { "type": "string", "default": "", "description": "Variable name for this hierarchy level (e.g. 'floor', 'tower'). Leave blank for auto-generated level_N" },
      "clone": { "type": "boolean", "default": true, "description": "Clone input geometries before translating" },
      "autoMerge": { "type": "boolean", "default": false, "description": "Merge all results into one BufferGeometry" }
    },
    "code": "const { group, count = 3, spacing = 1, axis = 'x', centered = false, levelName = '', clone = true, autoMerge = false } = params;\n\n// Normalize group -> array\nlet base = [];\nif (Array.isArray(group)) base = group;\nelse if (group && group.isBufferGeometry) base = [group];\nelse return autoMerge ? new THREE.BufferGeometry() : [];\n\nconst n = Math.max(0, Math.floor(count));\nif (n === 0) return autoMerge ? new THREE.BufferGeometry() : [];\n\nconst ax = String(axis).toLowerCase().replace(/\"/g, '').trim();\nconst axisVec = (ax === 'y') ? new THREE.Vector3(0,1,0) : (ax === 'z') ? new THREE.Vector3(0,0,1) : new THREE.Vector3(1,0,0);\n\nconst offset = centered ? -spacing * (n - 1) / 2 : 0;\n\n// Determine level variable name\nconst varName = (levelName && String(levelName).trim() !== '') ? String(levelName).trim() : 'level_0';\n\nconst results = [];\n\nfor (let i = 0; i < n; i++) {\n  const d = offset + i * spacing;\n  for (let gi = 0; gi < base.length; gi++) {\n    const g0 = base[gi];\n    if (!g0 || !g0.isBufferGeometry) continue;\n\n    const g = (clone && g0.clone) ? g0.clone() : g0;\n    g.translate(axisVec.x * d, axisVec.y * d, axisVec.z * d);\n\n    const ud0 = g0.userData || {};\n    const udG = g.userData || {};\n    \n    // Preserve earlier hierarchy metadata, add current level\n    g.userData = {\n      ...ud0,\n      ...udG,\n      [varName]: i,\n      [`${varName}Count`]: n,\n      [`${varName}Spacing`]: spacing,\n      [`${varName}Axis`]: ax,\n      [`${varName}Centered`]: centered\n    };\n\n    results.push(g);\n  }\n}\n\nreturn autoMerge ? BufferGeometryUtils.mergeGeometries(results.filter(r => r && r.isBufferGeometry)) : results;",
    "outputType": "Geometry"
  },
  {
    "id": "distributeGroupOnGrid3d",
    "name": "distributeGroupOnGrid3d",
    "description": "Distribute a geometry or group of geometries on a 3D grid, returning a flat array (or merged geometry) with hierarchy metadata accessible by levelName.",
    "category": "Distribution",
    "paramsSchema": {
      "group": { "type": "string", "default": "", "description": "Geometry or array of geometries to distribute" },
      "x": { "type": "number", "default": 3, "description": "Count X" },
      "y": { "type": "number", "default": 1, "description": "Count Y" },
      "z": { "type": "number", "default": 3, "description": "Count Z" },
      "spacing": { "type": "array", "default": [1, 1, 1], "description": "Spacing: number or [sx,sy,sz]" },
      "centered": { "type": "boolean", "default": true, "description": "Center grid around origin" },
      "levelName": { "type": "string", "default": "", "description": "Variable name for this hierarchy level (e.g. 'grid', 'pattern'). Leave blank for auto-generated level_N" },
      "clone": { "type": "boolean", "default": true, "description": "Clone input geometries before translating" },
      "autoMerge": { "type": "boolean", "default": false, "description": "Merge all results into one BufferGeometry" }
    },
    "code": "const { group, x = 3, y = 1, z = 3, spacing = [1,1,1], centered = true, levelName = '', clone = true, autoMerge = false } = params;\n\n// Normalize group -> array\nlet base = [];\nif (Array.isArray(group)) base = group;\nelse if (group && group.isBufferGeometry) base = [group];\nelse return autoMerge ? new THREE.BufferGeometry() : [];\n\nconst nx = Math.max(0, Math.floor(x));\nconst ny = Math.max(0, Math.floor(y));\nconst nz = Math.max(0, Math.floor(z));\nif (nx * ny * nz === 0) return autoMerge ? new THREE.BufferGeometry() : [];\n\nconst sx = Array.isArray(spacing) ? (spacing[0] ?? 1) : spacing;\nconst sy = Array.isArray(spacing) ? (spacing[1] ?? spacing[0] ?? 1) : spacing;\nconst sz = Array.isArray(spacing) ? (spacing[2] ?? spacing[0] ?? 1) : spacing;\n\nconst ox = centered ? -sx * (nx - 1) / 2 : 0;\nconst oy = centered ? -sy * (ny - 1) / 2 : 0;\nconst oz = centered ? -sz * (nz - 1) / 2 : 0;\n\n// Determine level variable name\nconst varName = (levelName && String(levelName).trim() !== '') ? String(levelName).trim() : 'level_0';\n\nconst results = [];\nlet flatIndex = 0;\n\nfor (let ix = 0; ix < nx; ix++) {\n  for (let iy = 0; iy < ny; iy++) {\n    for (let iz = 0; iz < nz; iz++) {\n      const tx = ox + ix * sx;\n      const ty = oy + iy * sy;\n      const tz = oz + iz * sz;\n\n      for (let gi = 0; gi < base.length; gi++) {\n        const g0 = base[gi];\n        if (!g0 || !g0.isBufferGeometry) continue;\n\n        const g = (clone && g0.clone) ? g0.clone() : g0;\n        g.translate(tx, ty, tz);\n\n        const ud0 = g0.userData || {};\n        const udG = g.userData || {};\n        \n        // Preserve earlier hierarchy metadata, add current level\n        g.userData = {\n          ...ud0,\n          ...udG,\n          [varName]: flatIndex,\n          [`${varName}IX`]: ix,\n          [`${varName}IY`]: iy,\n          [`${varName}IZ`]: iz,\n          [`${varName}NX`]: nx,\n          [`${varName}NY`]: ny,\n          [`${varName}NZ`]: nz,\n          [`${varName}Spacing`]: [sx, sy, sz],\n          [`${varName}Centered`]: centered\n        };\n\n        results.push(g);\n      }\n\n      flatIndex++;\n    }\n  }\n}\n\nreturn autoMerge ? BufferGeometryUtils.mergeGeometries(results.filter(r => r && r.isBufferGeometry)) : results;",
    "outputType": "Geometry"
  },
  {
    "id": "repeatGroupRadial3d",
    "name": "repeatGroupRadial3d",
    "description": "Repeat a geometry or group of geometries radially around an axis, returning a flat array (or merged geometry) with hierarchy metadata accessible by levelName.",
    "category": "Distribution",
    "paramsSchema": {
      "group": { "type": "string", "default": "", "description": "Geometry or array of geometries to repeat" },
      "count": { "type": "number", "default": 8, "description": "Number of repeats" },
      "radius": { "type": "number", "default": 5, "description": "Radius" },
      "startAngle": { "type": "number", "default": 0, "description": "Start angle (radians)" },
      "endAngle": { "type": "number", "default": 6.283185307179586, "description": "End angle (radians, default 2π)" },
      "axis": { "type": "string", "default": "y", "description": "x | y | z axis to rotate around" },
      "faceCenter": { "type": "boolean", "default": true, "description": "Rotate each copy to face outward" },
      "levelName": { "type": "string", "default": "", "description": "Variable name for this hierarchy level (e.g. 'ring', 'petal'). Leave blank for auto-generated level_N" },
      "clone": { "type": "boolean", "default": true, "description": "Clone input geometries before transforming" },
      "autoMerge": { "type": "boolean", "default": false, "description": "Merge all results into one BufferGeometry" }
    },
    "code": "const { group, count = 8, radius = 5, startAngle = 0, endAngle = Math.PI * 2, axis = 'y', faceCenter = true, levelName = '', clone = true, autoMerge = false } = params;\n\n// Normalize group -> array\nlet base = [];\nif (Array.isArray(group)) base = group;\nelse if (group && group.isBufferGeometry) base = [group];\nelse return autoMerge ? new THREE.BufferGeometry() : [];\n\nconst n = Math.max(0, Math.floor(count));\nif (n === 0) return autoMerge ? new THREE.BufferGeometry() : [];\n\nconst ax = String(axis).toLowerCase().replace(/\"/g, '').trim();\n\n// If full circle, distribute evenly by n; if arc, distribute by n-1\nconst isFullCircle = Math.abs((endAngle - startAngle) - (Math.PI * 2)) < 1e-3;\nconst divisor = (n > 1 && !isFullCircle) ? (n - 1) : n;\n\n// Determine level variable name\nconst varName = (levelName && String(levelName).trim() !== '') ? String(levelName).trim() : 'level_0';\n\nconst results = [];\n\nfor (let i = 0; i < n; i++) {\n  const t = (n <= 1) ? 0 : i / divisor;\n  const angle = startAngle + (endAngle - startAngle) * t;\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n\n  for (let gi = 0; gi < base.length; gi++) {\n    const g0 = base[gi];\n    if (!g0 || !g0.isBufferGeometry) continue;\n\n    const g = (clone && g0.clone) ? g0.clone() : g0;\n\n    // Rotate first, then translate (matches your existing radial helper behavior)\n    if (ax === 'x') {\n      if (faceCenter) g.rotateX(angle);\n      g.translate(0, radius * c, radius * s);\n    } else if (ax === 'z') {\n      if (faceCenter) g.rotateZ(angle);\n      g.translate(radius * c, radius * s, 0);\n    } else {\n      // y-axis default (XZ plane)\n      if (faceCenter) g.rotateY(-angle);\n      g.translate(radius * c, 0, radius * s);\n    }\n\n    const ud0 = g0.userData || {};\n    const udG = g.userData || {};\n    \n    // Preserve earlier hierarchy metadata, add current level\n    g.userData = {\n      ...ud0,\n      ...udG,\n      [varName]: i,\n      [`${varName}T`]: t,\n      [`${varName}Angle`]: angle,\n      [`${varName}Count`]: n,\n      [`${varName}Radius`]: radius,\n      [`${varName}Axis`]: ax,\n      [`${varName}FaceCenter`]: faceCenter\n    };\n\n    results.push(g);\n  }\n}\n\nreturn autoMerge ? BufferGeometryUtils.mergeGeometries(results.filter(r => r && r.isBufferGeometry)) : results;",
    "outputType": "Geometry"
  },
  {
    "id": "repeatGroupAlongCurve3d",
    "name": "repeatGroupAlongCurve3d",
    "description": "Repeat a geometry or group of geometries along a curve, returning a flat array (or merged geometry) with hierarchy metadata accessible by levelName.",
    "category": "Distribution",
    "paramsSchema": {
      "group": { "type": "string", "default": "", "description": "Geometry or array of geometries to distribute along curve" },
      "curve": { "type": "string", "default": "", "description": "Curve object/variable to follow (supports wrapped curves via resolveCurve if available)" },
      "count": { "type": "number", "default": 10, "description": "Number of repeats" },
      "align": { "type": "boolean", "default": true, "description": "Align each copy to the curve tangent" },
      "up": { "type": "array", "default": [0, 1, 0], "description": "Up vector for frame construction [x,y,z]" },
      "levelName": { "type": "string", "default": "", "description": "Variable name for this hierarchy level (e.g. 'point', 'station'). Leave blank for auto-generated level_N" },
      "clone": { "type": "boolean", "default": true, "description": "Clone input geometries before transforming" },
      "autoMerge": { "type": "boolean", "default": false, "description": "Merge all results into one BufferGeometry" }
    },
    "code": "const { group, curve, count = 10, align = true, up = [0,1,0], levelName = '', clone = true, autoMerge = false } = params;\n\n// Normalize group -> array\nlet base = [];\nif (Array.isArray(group)) base = group;\nelse if (group && group.isBufferGeometry) base = [group];\nelse return autoMerge ? new THREE.BufferGeometry() : [];\n\nconst n = Math.max(0, Math.floor(count));\nif (n === 0) return autoMerge ? new THREE.BufferGeometry() : [];\n\n// Resolve curve (supports your existing resolveCurve wrapper if present)\nlet resolvedCurve = curve;\ntry {\n  if (typeof resolveCurve === 'function') resolvedCurve = resolveCurve(curve);\n} catch (e) {}\n\nif (!resolvedCurve || typeof resolvedCurve.getPoint !== 'function') {\n  return autoMerge ? new THREE.BufferGeometry() : [];\n}\n\nconst upVec = Array.isArray(up) ? new THREE.Vector3(up[0] ?? 0, up[1] ?? 1, up[2] ?? 0) : new THREE.Vector3(0,1,0);\nif (upVec.lengthSq() < 1e-12) upVec.set(0,1,0);\nupVec.normalize();\n\n// Determine level variable name\nconst varName = (levelName && String(levelName).trim() !== '') ? String(levelName).trim() : 'level_0';\n\nconst results = [];\nconst pos = new THREE.Vector3();\nconst tangent = new THREE.Vector3();\n\nfor (let i = 0; i < n; i++) {\n  const t = (n <= 1) ? 0.5 : i / (n - 1);\n  const p = resolvedCurve.getPoint(t);\n  pos.set(p.x, p.y, p.z);\n\n  if (align && typeof resolvedCurve.getTangent === 'function') {\n    const tg = resolvedCurve.getTangent(t);\n    tangent.set(tg.x, tg.y, tg.z);\n    if (tangent.lengthSq() < 1e-12) tangent.set(1,0,0);\n    tangent.normalize();\n  } else {\n    tangent.set(1,0,0);\n  }\n\n  // Build a stable frame: x=tangent, y=orthogonalUp, z=normal\n  const normal = new THREE.Vector3().crossVectors(tangent, upVec);\n  if (normal.lengthSq() < 1e-12) {\n    // Tangent nearly parallel to up -> pick another up\n    const altUp = Math.abs(upVec.y) > 0.9 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);\n    normal.crossVectors(tangent, altUp);\n  }\n  normal.normalize();\n  const orthUp = new THREE.Vector3().crossVectors(normal, tangent).normalize();\n\n  const rotMatrix = new THREE.Matrix4().makeBasis(tangent, orthUp, normal);\n\n  for (let gi = 0; gi < base.length; gi++) {\n    const g0 = base[gi];\n    if (!g0 || !g0.isBufferGeometry) continue;\n\n    const g = (clone && g0.clone) ? g0.clone() : g0;\n\n    // Position\n    g.translate(pos.x, pos.y, pos.z);\n\n    // Orientation\n    if (align) g.applyMatrix4(rotMatrix);\n\n    const ud0 = g0.userData || {};\n    const udG = g.userData || {};\n    \n    // Preserve earlier hierarchy metadata, add current level\n    g.userData = {\n      ...ud0,\n      ...udG,\n      [varName]: i,\n      [`${varName}T`]: t,\n      [`${varName}Count`]: n,\n      [`${varName}Position`]: { x: pos.x, y: pos.y, z: pos.z },\n      [`${varName}Tangent`]: { x: tangent.x, y: tangent.y, z: tangent.z },\n      [`${varName}Align`]: align\n    };\n\n    results.push(g);\n  }\n}\n\nreturn autoMerge ? BufferGeometryUtils.mergeGeometries(results.filter(r => r && r.isBufferGeometry)) : results;",
    "outputType": "Geometry"
  },
 {
  "id": "createGroup",
  "name": "createGroup",
  "description": "Combine multiple geometries into an array (group) for use with distribution helpers.",
  "paramsSchema": {
    "geometries": { 
      "type": "string", 
      "default": "", 
      "description": "Comma-separated geometry names (e.g., 'cg, st') OR pre-resolved array" 
    }
  },
  "code": "const { geometries = [] } = params;\n\nlet items = [];\n\nif (Array.isArray(geometries)) {\n  // Already resolved by executor - just filter valid geometries\n  items = geometries.filter(g => g && g.isBufferGeometry);\n} else if (typeof geometries === 'string') {\n  // Fallback for string (shouldn't happen with new executor)\n  console.warn('createGroup: received string instead of array. This is unexpected.');\n  items = [];\n}\n\nreturn items.length > 0 ? items : [];",
  "outputType": "Geometry"
},
  {
  "id": "deformGeometryStack",
  "name": "deformGeometryStack",
  "description": "Applies a stack of deformations in sequence.",
  "category": "Deformation",
  "paramsSchema": {
    "geometry": { "type": "string" },
    "stack": { 
      "type": "array", 
      "default": [],
      "description": "Array of objects: [{ mode: 'twist', params: {...} }, ...]"
    },
    "recomputeNormals": { "type": "boolean", "default": true }
  },
  "code": "const { geometry, stack = [], recomputeNormals = true } = params;\n\nif (!geometry || !geometry.isBufferGeometry) return new THREE.BufferGeometry();\n\nconst geom = geometry.clone();\nconst posAttr = geom.attributes.position;\nconst normAttr = geom.attributes.normal;\nconst count = posAttr.count;\n\nconst p = new THREE.Vector3();\nconst n = new THREE.Vector3();\n\n// Prepare the stack functions\nconst pipeline = stack.map(item => {\n  const def = DeformerRegistry[item.mode];\n  if (!def) return null;\n  return {\n    func: def.func,\n    ctx: { params: { ...def.defaults, ...(item.params || {}) } }\n  };\n}).filter(Boolean);\n\nif (pipeline.length === 0) return geom;\n\nfor (let i = 0; i < count; i++) {\n  p.fromBufferAttribute(posAttr, i);\n  if (normAttr) n.fromBufferAttribute(normAttr, i);\n  else n.set(0, 1, 0);\n\n  // Run pipeline on this vertex\n  for (let step of pipeline) {\n    // Result of step 1 becomes input of step 2\n    const res = step.func(p, n, step.ctx);\n    p.set(res.x, res.y, res.z);\n  }\n\n  posAttr.setXYZ(i, p.x, p.y, p.z);\n}\n\nposAttr.needsUpdate = true;\nif (recomputeNormals) geom.computeVertexNormals();\n\nreturn geom;",
  "outputType": "Geometry"
}


]